
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamInvite
 * 
 */
export type TeamInvite = $Result.DefaultSelection<Prisma.$TeamInvitePayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model ApiKeyUsage
 * 
 */
export type ApiKeyUsage = $Result.DefaultSelection<Prisma.$ApiKeyUsagePayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model MailingList
 * 
 */
export type MailingList = $Result.DefaultSelection<Prisma.$MailingListPayload>
/**
 * Model Subscriber
 * 
 */
export type Subscriber = $Result.DefaultSelection<Prisma.$SubscriberPayload>
/**
 * Model SentEmail
 * 
 */
export type SentEmail = $Result.DefaultSelection<Prisma.$SentEmailPayload>
/**
 * Model EmailTracking
 * 
 */
export type EmailTracking = $Result.DefaultSelection<Prisma.$EmailTrackingPayload>
/**
 * Model EmailJob
 * 
 */
export type EmailJob = $Result.DefaultSelection<Prisma.$EmailJobPayload>
/**
 * Model EmailJobLog
 * 
 */
export type EmailJobLog = $Result.DefaultSelection<Prisma.$EmailJobLogPayload>
/**
 * Model CampaignAnalytics
 * 
 */
export type CampaignAnalytics = $Result.DefaultSelection<Prisma.$CampaignAnalyticsPayload>
/**
 * Model EmailCategory
 * 
 */
export type EmailCategory = $Result.DefaultSelection<Prisma.$EmailCategoryPayload>
/**
 * Model SmtpConfig
 * 
 */
export type SmtpConfig = $Result.DefaultSelection<Prisma.$SmtpConfigPayload>
/**
 * Model Automation
 * 
 */
export type Automation = $Result.DefaultSelection<Prisma.$AutomationPayload>
/**
 * Model AutomationNode
 * 
 */
export type AutomationNode = $Result.DefaultSelection<Prisma.$AutomationNodePayload>
/**
 * Model AutomationNodeEdge
 * 
 */
export type AutomationNodeEdge = $Result.DefaultSelection<Prisma.$AutomationNodeEdgePayload>
/**
 * Model CustomDomain
 * 
 */
export type CustomDomain = $Result.DefaultSelection<Prisma.$CustomDomainPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CampaignSchedule: {
  ONE_TIME: 'ONE_TIME',
  RECURRING: 'RECURRING'
};

export type CampaignSchedule = (typeof CampaignSchedule)[keyof typeof CampaignSchedule]


export const CampaignRecurringSchedule: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  CUSTOM: 'CUSTOM'
};

export type CampaignRecurringSchedule = (typeof CampaignRecurringSchedule)[keyof typeof CampaignRecurringSchedule]


export const TrackingType: {
  CLICKED: 'CLICKED',
  OPENED: 'OPENED',
  BOUNCED: 'BOUNCED',
  FAILED: 'FAILED'
};

export type TrackingType = (typeof TrackingType)[keyof typeof TrackingType]


export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const EmailStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  BOUNCED: 'BOUNCED',
  OPENED: 'OPENED',
  CLICKED: 'CLICKED'
};

export type EmailStatus = (typeof EmailStatus)[keyof typeof EmailStatus]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  SENDING: 'SENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  PAUSED: 'PAUSED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const SubscriberStatus: {
  ACTIVE: 'ACTIVE',
  UNSUBSCRIBED: 'UNSUBSCRIBED',
  BOUNCED: 'BOUNCED',
  COMPLAINED: 'COMPLAINED'
};

export type SubscriberStatus = (typeof SubscriberStatus)[keyof typeof SubscriberStatus]


export const JobStatus: {
  QUEUED: 'QUEUED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const LogLevel: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  ERROR: 'ERROR'
};

export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel]


export const InviteStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const NodeType: {
  START: 'START',
  EMAIL: 'EMAIL',
  WAIT: 'WAIT',
  CONDITION: 'CONDITION',
  WEBHOOK: 'WEBHOOK',
  ADD_TO_LIST: 'ADD_TO_LIST',
  REMOVE_FROM_LIST: 'REMOVE_FROM_LIST',
  UPDATE_SUBSCRIBER: 'UPDATE_SUBSCRIBER',
  CHECK_ENGAGEMENT: 'CHECK_ENGAGEMENT',
  SEGMENT: 'SEGMENT',
  TAG: 'TAG',
  UNSUBSCRIBE: 'UNSUBSCRIBE',
  CUSTOM_CODE: 'CUSTOM_CODE',
  EXIT: 'EXIT'
};

export type NodeType = (typeof NodeType)[keyof typeof NodeType]


export const WebhookEventType: {
  EMAIL_SENT: 'EMAIL_SENT',
  EMAIL_OPENED: 'EMAIL_OPENED',
  EMAIL_CLICKED: 'EMAIL_CLICKED',
  EMAIL_BOUNCED: 'EMAIL_BOUNCED',
  CAMPAIGN_STARTED: 'CAMPAIGN_STARTED',
  CAMPAIGN_COMPLETED: 'CAMPAIGN_COMPLETED',
  CAMPAIGN_FAILED: 'CAMPAIGN_FAILED',
  SUBSCRIPTION_UPDATED: 'SUBSCRIPTION_UPDATED',
  CUSTOM_DOMAIN_VERIFIED: 'CUSTOM_DOMAIN_VERIFIED',
  SUBSCRIBER_CREATED: 'SUBSCRIBER_CREATED',
  SUBSCRIBER_UPDATED: 'SUBSCRIBER_UPDATED',
  SUBSCRIBER_DELETED: 'SUBSCRIBER_DELETED',
  ADDED_TO_LIST: 'ADDED_TO_LIST',
  REMOVED_FROM_LIST: 'REMOVED_FROM_LIST'
};

export type WebhookEventType = (typeof WebhookEventType)[keyof typeof WebhookEventType]

}

export type CampaignSchedule = $Enums.CampaignSchedule

export const CampaignSchedule: typeof $Enums.CampaignSchedule

export type CampaignRecurringSchedule = $Enums.CampaignRecurringSchedule

export const CampaignRecurringSchedule: typeof $Enums.CampaignRecurringSchedule

export type TrackingType = $Enums.TrackingType

export const TrackingType: typeof $Enums.TrackingType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type EmailStatus = $Enums.EmailStatus

export const EmailStatus: typeof $Enums.EmailStatus

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type SubscriberStatus = $Enums.SubscriberStatus

export const SubscriberStatus: typeof $Enums.SubscriberStatus

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type LogLevel = $Enums.LogLevel

export const LogLevel: typeof $Enums.LogLevel

export type InviteStatus = $Enums.InviteStatus

export const InviteStatus: typeof $Enums.InviteStatus

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type NodeType = $Enums.NodeType

export const NodeType: typeof $Enums.NodeType

export type WebhookEventType = $Enums.WebhookEventType

export const WebhookEventType: typeof $Enums.WebhookEventType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more EmailTemplates
 * const emailTemplates = await prisma.emailTemplate.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more EmailTemplates
   * const emailTemplates = await prisma.emailTemplate.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.teamInvite`: Exposes CRUD operations for the **TeamInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamInvites
    * const teamInvites = await prisma.teamInvite.findMany()
    * ```
    */
  get teamInvite(): Prisma.TeamInviteDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.apiKeyUsage`: Exposes CRUD operations for the **ApiKeyUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeyUsages
    * const apiKeyUsages = await prisma.apiKeyUsage.findMany()
    * ```
    */
  get apiKeyUsage(): Prisma.ApiKeyUsageDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.mailingList`: Exposes CRUD operations for the **MailingList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MailingLists
    * const mailingLists = await prisma.mailingList.findMany()
    * ```
    */
  get mailingList(): Prisma.MailingListDelegate<ExtArgs>;

  /**
   * `prisma.subscriber`: Exposes CRUD operations for the **Subscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribers
    * const subscribers = await prisma.subscriber.findMany()
    * ```
    */
  get subscriber(): Prisma.SubscriberDelegate<ExtArgs>;

  /**
   * `prisma.sentEmail`: Exposes CRUD operations for the **SentEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SentEmails
    * const sentEmails = await prisma.sentEmail.findMany()
    * ```
    */
  get sentEmail(): Prisma.SentEmailDelegate<ExtArgs>;

  /**
   * `prisma.emailTracking`: Exposes CRUD operations for the **EmailTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTrackings
    * const emailTrackings = await prisma.emailTracking.findMany()
    * ```
    */
  get emailTracking(): Prisma.EmailTrackingDelegate<ExtArgs>;

  /**
   * `prisma.emailJob`: Exposes CRUD operations for the **EmailJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailJobs
    * const emailJobs = await prisma.emailJob.findMany()
    * ```
    */
  get emailJob(): Prisma.EmailJobDelegate<ExtArgs>;

  /**
   * `prisma.emailJobLog`: Exposes CRUD operations for the **EmailJobLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailJobLogs
    * const emailJobLogs = await prisma.emailJobLog.findMany()
    * ```
    */
  get emailJobLog(): Prisma.EmailJobLogDelegate<ExtArgs>;

  /**
   * `prisma.campaignAnalytics`: Exposes CRUD operations for the **CampaignAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignAnalytics
    * const campaignAnalytics = await prisma.campaignAnalytics.findMany()
    * ```
    */
  get campaignAnalytics(): Prisma.CampaignAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.emailCategory`: Exposes CRUD operations for the **EmailCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailCategories
    * const emailCategories = await prisma.emailCategory.findMany()
    * ```
    */
  get emailCategory(): Prisma.EmailCategoryDelegate<ExtArgs>;

  /**
   * `prisma.smtpConfig`: Exposes CRUD operations for the **SmtpConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmtpConfigs
    * const smtpConfigs = await prisma.smtpConfig.findMany()
    * ```
    */
  get smtpConfig(): Prisma.SmtpConfigDelegate<ExtArgs>;

  /**
   * `prisma.automation`: Exposes CRUD operations for the **Automation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automation.findMany()
    * ```
    */
  get automation(): Prisma.AutomationDelegate<ExtArgs>;

  /**
   * `prisma.automationNode`: Exposes CRUD operations for the **AutomationNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationNodes
    * const automationNodes = await prisma.automationNode.findMany()
    * ```
    */
  get automationNode(): Prisma.AutomationNodeDelegate<ExtArgs>;

  /**
   * `prisma.automationNodeEdge`: Exposes CRUD operations for the **AutomationNodeEdge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationNodeEdges
    * const automationNodeEdges = await prisma.automationNodeEdge.findMany()
    * ```
    */
  get automationNodeEdge(): Prisma.AutomationNodeEdgeDelegate<ExtArgs>;

  /**
   * `prisma.customDomain`: Exposes CRUD operations for the **CustomDomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomDomains
    * const customDomains = await prisma.customDomain.findMany()
    * ```
    */
  get customDomain(): Prisma.CustomDomainDelegate<ExtArgs>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.0.1
   * Query Engine version: 5dbef10bdbfb579e07d35cc85fb1518d357cb99e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    EmailTemplate: 'EmailTemplate',
    User: 'User',
    Team: 'Team',
    TeamInvite: 'TeamInvite',
    ApiKey: 'ApiKey',
    ApiKeyUsage: 'ApiKeyUsage',
    Campaign: 'Campaign',
    MailingList: 'MailingList',
    Subscriber: 'Subscriber',
    SentEmail: 'SentEmail',
    EmailTracking: 'EmailTracking',
    EmailJob: 'EmailJob',
    EmailJobLog: 'EmailJobLog',
    CampaignAnalytics: 'CampaignAnalytics',
    EmailCategory: 'EmailCategory',
    SmtpConfig: 'SmtpConfig',
    Automation: 'Automation',
    AutomationNode: 'AutomationNode',
    AutomationNodeEdge: 'AutomationNodeEdge',
    CustomDomain: 'CustomDomain',
    Webhook: 'Webhook',
    WebhookEvent: 'WebhookEvent',
    WebhookDelivery: 'WebhookDelivery'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "emailTemplate" | "user" | "team" | "teamInvite" | "apiKey" | "apiKeyUsage" | "campaign" | "mailingList" | "subscriber" | "sentEmail" | "emailTracking" | "emailJob" | "emailJobLog" | "campaignAnalytics" | "emailCategory" | "smtpConfig" | "automation" | "automationNode" | "automationNodeEdge" | "customDomain" | "webhook" | "webhookEvent" | "webhookDelivery"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamInvite: {
        payload: Prisma.$TeamInvitePayload<ExtArgs>
        fields: Prisma.TeamInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>
          }
          findFirst: {
            args: Prisma.TeamInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>
          }
          findMany: {
            args: Prisma.TeamInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>[]
          }
          create: {
            args: Prisma.TeamInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>
          }
          createMany: {
            args: Prisma.TeamInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>[]
          }
          delete: {
            args: Prisma.TeamInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>
          }
          update: {
            args: Prisma.TeamInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>
          }
          deleteMany: {
            args: Prisma.TeamInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>
          }
          aggregate: {
            args: Prisma.TeamInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamInvite>
          }
          groupBy: {
            args: Prisma.TeamInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamInviteCountArgs<ExtArgs>
            result: $Utils.Optional<TeamInviteCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      ApiKeyUsage: {
        payload: Prisma.$ApiKeyUsagePayload<ExtArgs>
        fields: Prisma.ApiKeyUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          findFirst: {
            args: Prisma.ApiKeyUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          findMany: {
            args: Prisma.ApiKeyUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>[]
          }
          create: {
            args: Prisma.ApiKeyUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          createMany: {
            args: Prisma.ApiKeyUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>[]
          }
          delete: {
            args: Prisma.ApiKeyUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          update: {
            args: Prisma.ApiKeyUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          aggregate: {
            args: Prisma.ApiKeyUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKeyUsage>
          }
          groupBy: {
            args: Prisma.ApiKeyUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyUsageCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyUsageCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      MailingList: {
        payload: Prisma.$MailingListPayload<ExtArgs>
        fields: Prisma.MailingListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MailingListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MailingListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>
          }
          findFirst: {
            args: Prisma.MailingListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MailingListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>
          }
          findMany: {
            args: Prisma.MailingListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>[]
          }
          create: {
            args: Prisma.MailingListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>
          }
          createMany: {
            args: Prisma.MailingListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MailingListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>[]
          }
          delete: {
            args: Prisma.MailingListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>
          }
          update: {
            args: Prisma.MailingListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>
          }
          deleteMany: {
            args: Prisma.MailingListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MailingListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MailingListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailingListPayload>
          }
          aggregate: {
            args: Prisma.MailingListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMailingList>
          }
          groupBy: {
            args: Prisma.MailingListGroupByArgs<ExtArgs>
            result: $Utils.Optional<MailingListGroupByOutputType>[]
          }
          count: {
            args: Prisma.MailingListCountArgs<ExtArgs>
            result: $Utils.Optional<MailingListCountAggregateOutputType> | number
          }
        }
      }
      Subscriber: {
        payload: Prisma.$SubscriberPayload<ExtArgs>
        fields: Prisma.SubscriberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findFirst: {
            args: Prisma.SubscriberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findMany: {
            args: Prisma.SubscriberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          create: {
            args: Prisma.SubscriberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          createMany: {
            args: Prisma.SubscriberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          delete: {
            args: Prisma.SubscriberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          update: {
            args: Prisma.SubscriberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          deleteMany: {
            args: Prisma.SubscriberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          aggregate: {
            args: Prisma.SubscriberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriber>
          }
          groupBy: {
            args: Prisma.SubscriberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriberCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriberCountAggregateOutputType> | number
          }
        }
      }
      SentEmail: {
        payload: Prisma.$SentEmailPayload<ExtArgs>
        fields: Prisma.SentEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SentEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SentEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          findFirst: {
            args: Prisma.SentEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SentEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          findMany: {
            args: Prisma.SentEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>[]
          }
          create: {
            args: Prisma.SentEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          createMany: {
            args: Prisma.SentEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SentEmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>[]
          }
          delete: {
            args: Prisma.SentEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          update: {
            args: Prisma.SentEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          deleteMany: {
            args: Prisma.SentEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SentEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SentEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          aggregate: {
            args: Prisma.SentEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSentEmail>
          }
          groupBy: {
            args: Prisma.SentEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<SentEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.SentEmailCountArgs<ExtArgs>
            result: $Utils.Optional<SentEmailCountAggregateOutputType> | number
          }
        }
      }
      EmailTracking: {
        payload: Prisma.$EmailTrackingPayload<ExtArgs>
        fields: Prisma.EmailTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          findFirst: {
            args: Prisma.EmailTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          findMany: {
            args: Prisma.EmailTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>[]
          }
          create: {
            args: Prisma.EmailTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          createMany: {
            args: Prisma.EmailTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>[]
          }
          delete: {
            args: Prisma.EmailTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          update: {
            args: Prisma.EmailTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          deleteMany: {
            args: Prisma.EmailTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          aggregate: {
            args: Prisma.EmailTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTracking>
          }
          groupBy: {
            args: Prisma.EmailTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTrackingCountAggregateOutputType> | number
          }
        }
      }
      EmailJob: {
        payload: Prisma.$EmailJobPayload<ExtArgs>
        fields: Prisma.EmailJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>
          }
          findFirst: {
            args: Prisma.EmailJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>
          }
          findMany: {
            args: Prisma.EmailJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>[]
          }
          create: {
            args: Prisma.EmailJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>
          }
          createMany: {
            args: Prisma.EmailJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>[]
          }
          delete: {
            args: Prisma.EmailJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>
          }
          update: {
            args: Prisma.EmailJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>
          }
          deleteMany: {
            args: Prisma.EmailJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobPayload>
          }
          aggregate: {
            args: Prisma.EmailJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailJob>
          }
          groupBy: {
            args: Prisma.EmailJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailJobCountArgs<ExtArgs>
            result: $Utils.Optional<EmailJobCountAggregateOutputType> | number
          }
        }
      }
      EmailJobLog: {
        payload: Prisma.$EmailJobLogPayload<ExtArgs>
        fields: Prisma.EmailJobLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailJobLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailJobLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>
          }
          findFirst: {
            args: Prisma.EmailJobLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailJobLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>
          }
          findMany: {
            args: Prisma.EmailJobLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>[]
          }
          create: {
            args: Prisma.EmailJobLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>
          }
          createMany: {
            args: Prisma.EmailJobLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailJobLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>[]
          }
          delete: {
            args: Prisma.EmailJobLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>
          }
          update: {
            args: Prisma.EmailJobLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailJobLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailJobLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailJobLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailJobLogPayload>
          }
          aggregate: {
            args: Prisma.EmailJobLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailJobLog>
          }
          groupBy: {
            args: Prisma.EmailJobLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailJobLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailJobLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailJobLogCountAggregateOutputType> | number
          }
        }
      }
      CampaignAnalytics: {
        payload: Prisma.$CampaignAnalyticsPayload<ExtArgs>
        fields: Prisma.CampaignAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.CampaignAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>
          }
          findMany: {
            args: Prisma.CampaignAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>[]
          }
          create: {
            args: Prisma.CampaignAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>
          }
          createMany: {
            args: Prisma.CampaignAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.CampaignAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>
          }
          update: {
            args: Prisma.CampaignAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.CampaignAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.CampaignAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignAnalytics>
          }
          groupBy: {
            args: Prisma.CampaignAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      EmailCategory: {
        payload: Prisma.$EmailCategoryPayload<ExtArgs>
        fields: Prisma.EmailCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>
          }
          findFirst: {
            args: Prisma.EmailCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>
          }
          findMany: {
            args: Prisma.EmailCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>[]
          }
          create: {
            args: Prisma.EmailCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>
          }
          createMany: {
            args: Prisma.EmailCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>[]
          }
          delete: {
            args: Prisma.EmailCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>
          }
          update: {
            args: Prisma.EmailCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>
          }
          deleteMany: {
            args: Prisma.EmailCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCategoryPayload>
          }
          aggregate: {
            args: Prisma.EmailCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailCategory>
          }
          groupBy: {
            args: Prisma.EmailCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCategoryCountAggregateOutputType> | number
          }
        }
      }
      SmtpConfig: {
        payload: Prisma.$SmtpConfigPayload<ExtArgs>
        fields: Prisma.SmtpConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SmtpConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SmtpConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          findFirst: {
            args: Prisma.SmtpConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SmtpConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          findMany: {
            args: Prisma.SmtpConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>[]
          }
          create: {
            args: Prisma.SmtpConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          createMany: {
            args: Prisma.SmtpConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SmtpConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>[]
          }
          delete: {
            args: Prisma.SmtpConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          update: {
            args: Prisma.SmtpConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          deleteMany: {
            args: Prisma.SmtpConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SmtpConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SmtpConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          aggregate: {
            args: Prisma.SmtpConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSmtpConfig>
          }
          groupBy: {
            args: Prisma.SmtpConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SmtpConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SmtpConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SmtpConfigCountAggregateOutputType> | number
          }
        }
      }
      Automation: {
        payload: Prisma.$AutomationPayload<ExtArgs>
        fields: Prisma.AutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findFirst: {
            args: Prisma.AutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findMany: {
            args: Prisma.AutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          create: {
            args: Prisma.AutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          createMany: {
            args: Prisma.AutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          delete: {
            args: Prisma.AutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          update: {
            args: Prisma.AutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          deleteMany: {
            args: Prisma.AutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          aggregate: {
            args: Prisma.AutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomation>
          }
          groupBy: {
            args: Prisma.AutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationCountAggregateOutputType> | number
          }
        }
      }
      AutomationNode: {
        payload: Prisma.$AutomationNodePayload<ExtArgs>
        fields: Prisma.AutomationNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>
          }
          findFirst: {
            args: Prisma.AutomationNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>
          }
          findMany: {
            args: Prisma.AutomationNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>[]
          }
          create: {
            args: Prisma.AutomationNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>
          }
          createMany: {
            args: Prisma.AutomationNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>[]
          }
          delete: {
            args: Prisma.AutomationNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>
          }
          update: {
            args: Prisma.AutomationNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>
          }
          deleteMany: {
            args: Prisma.AutomationNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodePayload>
          }
          aggregate: {
            args: Prisma.AutomationNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationNode>
          }
          groupBy: {
            args: Prisma.AutomationNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationNodeCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationNodeCountAggregateOutputType> | number
          }
        }
      }
      AutomationNodeEdge: {
        payload: Prisma.$AutomationNodeEdgePayload<ExtArgs>
        fields: Prisma.AutomationNodeEdgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationNodeEdgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationNodeEdgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>
          }
          findFirst: {
            args: Prisma.AutomationNodeEdgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationNodeEdgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>
          }
          findMany: {
            args: Prisma.AutomationNodeEdgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>[]
          }
          create: {
            args: Prisma.AutomationNodeEdgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>
          }
          createMany: {
            args: Prisma.AutomationNodeEdgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationNodeEdgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>[]
          }
          delete: {
            args: Prisma.AutomationNodeEdgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>
          }
          update: {
            args: Prisma.AutomationNodeEdgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>
          }
          deleteMany: {
            args: Prisma.AutomationNodeEdgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationNodeEdgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationNodeEdgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationNodeEdgePayload>
          }
          aggregate: {
            args: Prisma.AutomationNodeEdgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationNodeEdge>
          }
          groupBy: {
            args: Prisma.AutomationNodeEdgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationNodeEdgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationNodeEdgeCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationNodeEdgeCountAggregateOutputType> | number
          }
        }
      }
      CustomDomain: {
        payload: Prisma.$CustomDomainPayload<ExtArgs>
        fields: Prisma.CustomDomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomDomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomDomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>
          }
          findFirst: {
            args: Prisma.CustomDomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomDomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>
          }
          findMany: {
            args: Prisma.CustomDomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>[]
          }
          create: {
            args: Prisma.CustomDomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>
          }
          createMany: {
            args: Prisma.CustomDomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomDomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>[]
          }
          delete: {
            args: Prisma.CustomDomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>
          }
          update: {
            args: Prisma.CustomDomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>
          }
          deleteMany: {
            args: Prisma.CustomDomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomDomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomDomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomDomainPayload>
          }
          aggregate: {
            args: Prisma.CustomDomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomDomain>
          }
          groupBy: {
            args: Prisma.CustomDomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomDomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomDomainCountArgs<ExtArgs>
            result: $Utils.Optional<CustomDomainCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    campaigns: number
    sentEmails: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | EmailTemplateCountOutputTypeCountCampaignsArgs
    sentEmails?: boolean | EmailTemplateCountOutputTypeCountSentEmailsArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountSentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    invitesSent: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitesSent?: boolean | UserCountOutputTypeCountInvitesSentArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInviteWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    users: number
    invites: number
    templates: number
    lists: number
    automations: number
    campaigns: number
    apiKeys: number
    smtpConfigs: number
    sentEmails: number
    customDomains: number
    webhooks: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TeamCountOutputTypeCountUsersArgs
    invites?: boolean | TeamCountOutputTypeCountInvitesArgs
    templates?: boolean | TeamCountOutputTypeCountTemplatesArgs
    lists?: boolean | TeamCountOutputTypeCountListsArgs
    automations?: boolean | TeamCountOutputTypeCountAutomationsArgs
    campaigns?: boolean | TeamCountOutputTypeCountCampaignsArgs
    apiKeys?: boolean | TeamCountOutputTypeCountApiKeysArgs
    smtpConfigs?: boolean | TeamCountOutputTypeCountSmtpConfigsArgs
    sentEmails?: boolean | TeamCountOutputTypeCountSentEmailsArgs
    customDomains?: boolean | TeamCountOutputTypeCountCustomDomainsArgs
    webhooks?: boolean | TeamCountOutputTypeCountWebhooksArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInviteWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailingListWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSmtpConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmtpConfigWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountCustomDomainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomDomainWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
  }


  /**
   * Count Type ApiKeyCountOutputType
   */

  export type ApiKeyCountOutputType = {
    usageStats: number
  }

  export type ApiKeyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageStats?: boolean | ApiKeyCountOutputTypeCountUsageStatsArgs
  }

  // Custom InputTypes
  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyCountOutputType
     */
    select?: ApiKeyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeCountUsageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyUsageWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    sentEmails: number
    emailJobs: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentEmails?: boolean | CampaignCountOutputTypeCountSentEmailsArgs
    emailJobs?: boolean | CampaignCountOutputTypeCountEmailJobsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEmailJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailJobWhereInput
  }


  /**
   * Count Type MailingListCountOutputType
   */

  export type MailingListCountOutputType = {
    subscribers: number
    campaigns: number
  }

  export type MailingListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscribers?: boolean | MailingListCountOutputTypeCountSubscribersArgs
    campaigns?: boolean | MailingListCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * MailingListCountOutputType without action
   */
  export type MailingListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingListCountOutputType
     */
    select?: MailingListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MailingListCountOutputType without action
   */
  export type MailingListCountOutputTypeCountSubscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberWhereInput
  }

  /**
   * MailingListCountOutputType without action
   */
  export type MailingListCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type SubscriberCountOutputType
   */

  export type SubscriberCountOutputType = {
    sentEmails: number
  }

  export type SubscriberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentEmails?: boolean | SubscriberCountOutputTypeCountSentEmailsArgs
  }

  // Custom InputTypes
  /**
   * SubscriberCountOutputType without action
   */
  export type SubscriberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberCountOutputType
     */
    select?: SubscriberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriberCountOutputType without action
   */
  export type SubscriberCountOutputTypeCountSentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
  }


  /**
   * Count Type SentEmailCountOutputType
   */

  export type SentEmailCountOutputType = {
    tracking: number
  }

  export type SentEmailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracking?: boolean | SentEmailCountOutputTypeCountTrackingArgs
  }

  // Custom InputTypes
  /**
   * SentEmailCountOutputType without action
   */
  export type SentEmailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmailCountOutputType
     */
    select?: SentEmailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SentEmailCountOutputType without action
   */
  export type SentEmailCountOutputTypeCountTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTrackingWhereInput
  }


  /**
   * Count Type EmailJobCountOutputType
   */

  export type EmailJobCountOutputType = {
    sentEmails: number
    logs: number
  }

  export type EmailJobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentEmails?: boolean | EmailJobCountOutputTypeCountSentEmailsArgs
    logs?: boolean | EmailJobCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * EmailJobCountOutputType without action
   */
  export type EmailJobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobCountOutputType
     */
    select?: EmailJobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailJobCountOutputType without action
   */
  export type EmailJobCountOutputTypeCountSentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
  }

  /**
   * EmailJobCountOutputType without action
   */
  export type EmailJobCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailJobLogWhereInput
  }


  /**
   * Count Type EmailCategoryCountOutputType
   */

  export type EmailCategoryCountOutputType = {
    templates: number
  }

  export type EmailCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templates?: boolean | EmailCategoryCountOutputTypeCountTemplatesArgs
  }

  // Custom InputTypes
  /**
   * EmailCategoryCountOutputType without action
   */
  export type EmailCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategoryCountOutputType
     */
    select?: EmailCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailCategoryCountOutputType without action
   */
  export type EmailCategoryCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
  }


  /**
   * Count Type SmtpConfigCountOutputType
   */

  export type SmtpConfigCountOutputType = {
    campaigns: number
  }

  export type SmtpConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | SmtpConfigCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * SmtpConfigCountOutputType without action
   */
  export type SmtpConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfigCountOutputType
     */
    select?: SmtpConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SmtpConfigCountOutputType without action
   */
  export type SmtpConfigCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type AutomationCountOutputType
   */

  export type AutomationCountOutputType = {
    nodes: number
    edges: number
  }

  export type AutomationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | AutomationCountOutputTypeCountNodesArgs
    edges?: boolean | AutomationCountOutputTypeCountEdgesArgs
  }

  // Custom InputTypes
  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationCountOutputType
     */
    select?: AutomationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationNodeWhereInput
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationNodeEdgeWhereInput
  }


  /**
   * Count Type AutomationNodeCountOutputType
   */

  export type AutomationNodeCountOutputType = {
    edgesFrom: number
    edgesTo: number
  }

  export type AutomationNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edgesFrom?: boolean | AutomationNodeCountOutputTypeCountEdgesFromArgs
    edgesTo?: boolean | AutomationNodeCountOutputTypeCountEdgesToArgs
  }

  // Custom InputTypes
  /**
   * AutomationNodeCountOutputType without action
   */
  export type AutomationNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeCountOutputType
     */
    select?: AutomationNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationNodeCountOutputType without action
   */
  export type AutomationNodeCountOutputTypeCountEdgesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationNodeEdgeWhereInput
  }

  /**
   * AutomationNodeCountOutputType without action
   */
  export type AutomationNodeCountOutputTypeCountEdgesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationNodeEdgeWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    events: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | WebhookCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    categoryId: string | null
    html: string | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    categoryId: string | null
    html: string | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    content: number
    variables: number
    createdAt: number
    updatedAt: number
    teamId: number
    categoryId: number
    html: number
    design: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    categoryId?: true
    html?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    categoryId?: true
    html?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    variables?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    categoryId?: true
    html?: true
    design?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    content: string | null
    variables: string[]
    createdAt: Date
    updatedAt: Date
    teamId: string
    categoryId: string
    html: string | null
    design: JsonValue | null
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    categoryId?: boolean
    html?: boolean
    design?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    campaigns?: boolean | EmailTemplate$campaignsArgs<ExtArgs>
    sentEmails?: boolean | EmailTemplate$sentEmailsArgs<ExtArgs>
    category?: boolean | EmailCategoryDefaultArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    categoryId?: boolean
    html?: boolean
    design?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    category?: boolean | EmailCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    categoryId?: boolean
    html?: boolean
    design?: boolean
  }

  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    campaigns?: boolean | EmailTemplate$campaignsArgs<ExtArgs>
    sentEmails?: boolean | EmailTemplate$sentEmailsArgs<ExtArgs>
    category?: boolean | EmailCategoryDefaultArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    category?: boolean | EmailCategoryDefaultArgs<ExtArgs>
  }

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      sentEmails: Prisma.$SentEmailPayload<ExtArgs>[]
      category: Prisma.$EmailCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      content: string | null
      variables: string[]
      createdAt: Date
      updatedAt: Date
      teamId: string
      categoryId: string
      html: string | null
      design: Prisma.JsonValue | null
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaigns<T extends EmailTemplate$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    sentEmails<T extends EmailTemplate$sentEmailsArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$sentEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends EmailCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailCategoryDefaultArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */ 
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly content: FieldRef<"EmailTemplate", 'String'>
    readonly variables: FieldRef<"EmailTemplate", 'String[]'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly teamId: FieldRef<"EmailTemplate", 'String'>
    readonly categoryId: FieldRef<"EmailTemplate", 'String'>
    readonly html: FieldRef<"EmailTemplate", 'String'>
    readonly design: FieldRef<"EmailTemplate", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate.campaigns
   */
  export type EmailTemplate$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * EmailTemplate.sentEmails
   */
  export type EmailTemplate$sentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    cursor?: SentEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.UserStatus | null
    teamId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.UserStatus | null
    teamId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    status: number
    teamId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    teamId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    teamId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    teamId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    password: string
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    status: $Enums.UserStatus
    teamId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    teamId?: boolean
    team?: boolean | User$teamArgs<ExtArgs>
    invitesSent?: boolean | User$invitesSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    teamId?: boolean
    team?: boolean | User$teamArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    teamId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | User$teamArgs<ExtArgs>
    invitesSent?: boolean | User$invitesSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | User$teamArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs> | null
      invitesSent: Prisma.$TeamInvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      password: string
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
      status: $Enums.UserStatus
      teamId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends User$teamArgs<ExtArgs> = {}>(args?: Subset<T, User$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invitesSent<T extends User$invitesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$invitesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly teamId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.team
   */
  export type User$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * User.invitesSent
   */
  export type User$invitesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    where?: TeamInviteWhereInput
    orderBy?: TeamInviteOrderByWithRelationInput | TeamInviteOrderByWithRelationInput[]
    cursor?: TeamInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailTemplateId: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailTemplateId: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    emailTemplateId: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    emailTemplateId?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    emailTemplateId?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    emailTemplateId?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    logoUrl: string | null
    createdAt: Date
    updatedAt: Date
    emailTemplateId: string | null
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplateId?: boolean
    users?: boolean | Team$usersArgs<ExtArgs>
    invites?: boolean | Team$invitesArgs<ExtArgs>
    templates?: boolean | Team$templatesArgs<ExtArgs>
    lists?: boolean | Team$listsArgs<ExtArgs>
    automations?: boolean | Team$automationsArgs<ExtArgs>
    campaigns?: boolean | Team$campaignsArgs<ExtArgs>
    apiKeys?: boolean | Team$apiKeysArgs<ExtArgs>
    smtpConfigs?: boolean | Team$smtpConfigsArgs<ExtArgs>
    sentEmails?: boolean | Team$sentEmailsArgs<ExtArgs>
    customDomains?: boolean | Team$customDomainsArgs<ExtArgs>
    webhooks?: boolean | Team$webhooksArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplateId?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplateId?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Team$usersArgs<ExtArgs>
    invites?: boolean | Team$invitesArgs<ExtArgs>
    templates?: boolean | Team$templatesArgs<ExtArgs>
    lists?: boolean | Team$listsArgs<ExtArgs>
    automations?: boolean | Team$automationsArgs<ExtArgs>
    campaigns?: boolean | Team$campaignsArgs<ExtArgs>
    apiKeys?: boolean | Team$apiKeysArgs<ExtArgs>
    smtpConfigs?: boolean | Team$smtpConfigsArgs<ExtArgs>
    sentEmails?: boolean | Team$sentEmailsArgs<ExtArgs>
    customDomains?: boolean | Team$customDomainsArgs<ExtArgs>
    webhooks?: boolean | Team$webhooksArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      invites: Prisma.$TeamInvitePayload<ExtArgs>[]
      templates: Prisma.$EmailTemplatePayload<ExtArgs>[]
      lists: Prisma.$MailingListPayload<ExtArgs>[]
      automations: Prisma.$AutomationPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      smtpConfigs: Prisma.$SmtpConfigPayload<ExtArgs>[]
      sentEmails: Prisma.$SentEmailPayload<ExtArgs>[]
      customDomains: Prisma.$CustomDomainPayload<ExtArgs>[]
      webhooks: Prisma.$WebhookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logoUrl: string | null
      createdAt: Date
      updatedAt: Date
      emailTemplateId: string | null
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Team$usersArgs<ExtArgs> = {}>(args?: Subset<T, Team$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends Team$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Team$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "findMany"> | Null>
    templates<T extends Team$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Team$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    lists<T extends Team$listsArgs<ExtArgs> = {}>(args?: Subset<T, Team$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findMany"> | Null>
    automations<T extends Team$automationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$automationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany"> | Null>
    campaigns<T extends Team$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Team$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends Team$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Team$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    smtpConfigs<T extends Team$smtpConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Team$smtpConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findMany"> | Null>
    sentEmails<T extends Team$sentEmailsArgs<ExtArgs> = {}>(args?: Subset<T, Team$sentEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany"> | Null>
    customDomains<T extends Team$customDomainsArgs<ExtArgs> = {}>(args?: Subset<T, Team$customDomainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "findMany"> | Null>
    webhooks<T extends Team$webhooksArgs<ExtArgs> = {}>(args?: Subset<T, Team$webhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly logoUrl: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
    readonly emailTemplateId: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.users
   */
  export type Team$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Team.invites
   */
  export type Team$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    where?: TeamInviteWhereInput
    orderBy?: TeamInviteOrderByWithRelationInput | TeamInviteOrderByWithRelationInput[]
    cursor?: TeamInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[]
  }

  /**
   * Team.templates
   */
  export type Team$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    cursor?: EmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * Team.lists
   */
  export type Team$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    where?: MailingListWhereInput
    orderBy?: MailingListOrderByWithRelationInput | MailingListOrderByWithRelationInput[]
    cursor?: MailingListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailingListScalarFieldEnum | MailingListScalarFieldEnum[]
  }

  /**
   * Team.automations
   */
  export type Team$automationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    cursor?: AutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Team.campaigns
   */
  export type Team$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Team.apiKeys
   */
  export type Team$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Team.smtpConfigs
   */
  export type Team$smtpConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    where?: SmtpConfigWhereInput
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    cursor?: SmtpConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SmtpConfigScalarFieldEnum | SmtpConfigScalarFieldEnum[]
  }

  /**
   * Team.sentEmails
   */
  export type Team$sentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    cursor?: SentEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * Team.customDomains
   */
  export type Team$customDomainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    where?: CustomDomainWhereInput
    orderBy?: CustomDomainOrderByWithRelationInput | CustomDomainOrderByWithRelationInput[]
    cursor?: CustomDomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomDomainScalarFieldEnum | CustomDomainScalarFieldEnum[]
  }

  /**
   * Team.webhooks
   */
  export type Team$webhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    cursor?: WebhookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamInvite
   */

  export type AggregateTeamInvite = {
    _count: TeamInviteCountAggregateOutputType | null
    _min: TeamInviteMinAggregateOutputType | null
    _max: TeamInviteMaxAggregateOutputType | null
  }

  export type TeamInviteMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    inviterId: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    name: string | null
  }

  export type TeamInviteMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    inviterId: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    name: string | null
  }

  export type TeamInviteCountAggregateOutputType = {
    id: number
    teamId: number
    inviterId: number
    status: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    email: number
    name: number
    _all: number
  }


  export type TeamInviteMinAggregateInputType = {
    id?: true
    teamId?: true
    inviterId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
  }

  export type TeamInviteMaxAggregateInputType = {
    id?: true
    teamId?: true
    inviterId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
  }

  export type TeamInviteCountAggregateInputType = {
    id?: true
    teamId?: true
    inviterId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
    _all?: true
  }

  export type TeamInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamInvite to aggregate.
     */
    where?: TeamInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?: TeamInviteOrderByWithRelationInput | TeamInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamInvites
    **/
    _count?: true | TeamInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamInviteMaxAggregateInputType
  }

  export type GetTeamInviteAggregateType<T extends TeamInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamInvite[P]>
      : GetScalarType<T[P], AggregateTeamInvite[P]>
  }




  export type TeamInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInviteWhereInput
    orderBy?: TeamInviteOrderByWithAggregationInput | TeamInviteOrderByWithAggregationInput[]
    by: TeamInviteScalarFieldEnum[] | TeamInviteScalarFieldEnum
    having?: TeamInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamInviteCountAggregateInputType | true
    _min?: TeamInviteMinAggregateInputType
    _max?: TeamInviteMaxAggregateInputType
  }

  export type TeamInviteGroupByOutputType = {
    id: string
    teamId: string
    inviterId: string
    status: $Enums.InviteStatus
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    email: string
    name: string
    _count: TeamInviteCountAggregateOutputType | null
    _min: TeamInviteMinAggregateOutputType | null
    _max: TeamInviteMaxAggregateOutputType | null
  }

  type GetTeamInviteGroupByPayload<T extends TeamInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamInviteGroupByOutputType[P]>
            : GetScalarType<T[P], TeamInviteGroupByOutputType[P]>
        }
      >
    >


  export type TeamInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    inviterId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    name?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamInvite"]>

  export type TeamInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    inviterId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    name?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamInvite"]>

  export type TeamInviteSelectScalar = {
    id?: boolean
    teamId?: boolean
    inviterId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    name?: boolean
  }

  export type TeamInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamInvite"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      inviterId: string
      status: $Enums.InviteStatus
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      email: string
      name: string
    }, ExtArgs["result"]["teamInvite"]>
    composites: {}
  }

  type TeamInviteGetPayload<S extends boolean | null | undefined | TeamInviteDefaultArgs> = $Result.GetResult<Prisma.$TeamInvitePayload, S>

  type TeamInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamInviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamInviteCountAggregateInputType | true
    }

  export interface TeamInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamInvite'], meta: { name: 'TeamInvite' } }
    /**
     * Find zero or one TeamInvite that matches the filter.
     * @param {TeamInviteFindUniqueArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamInviteFindUniqueArgs>(args: SelectSubset<T, TeamInviteFindUniqueArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamInvite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamInviteFindUniqueOrThrowArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteFindFirstArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamInviteFindFirstArgs>(args?: SelectSubset<T, TeamInviteFindFirstArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteFindFirstOrThrowArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamInvites
     * const teamInvites = await prisma.teamInvite.findMany()
     * 
     * // Get first 10 TeamInvites
     * const teamInvites = await prisma.teamInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamInviteWithIdOnly = await prisma.teamInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamInviteFindManyArgs>(args?: SelectSubset<T, TeamInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamInvite.
     * @param {TeamInviteCreateArgs} args - Arguments to create a TeamInvite.
     * @example
     * // Create one TeamInvite
     * const TeamInvite = await prisma.teamInvite.create({
     *   data: {
     *     // ... data to create a TeamInvite
     *   }
     * })
     * 
     */
    create<T extends TeamInviteCreateArgs>(args: SelectSubset<T, TeamInviteCreateArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamInvites.
     * @param {TeamInviteCreateManyArgs} args - Arguments to create many TeamInvites.
     * @example
     * // Create many TeamInvites
     * const teamInvite = await prisma.teamInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamInviteCreateManyArgs>(args?: SelectSubset<T, TeamInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamInvites and returns the data saved in the database.
     * @param {TeamInviteCreateManyAndReturnArgs} args - Arguments to create many TeamInvites.
     * @example
     * // Create many TeamInvites
     * const teamInvite = await prisma.teamInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamInvites and only return the `id`
     * const teamInviteWithIdOnly = await prisma.teamInvite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeamInvite.
     * @param {TeamInviteDeleteArgs} args - Arguments to delete one TeamInvite.
     * @example
     * // Delete one TeamInvite
     * const TeamInvite = await prisma.teamInvite.delete({
     *   where: {
     *     // ... filter to delete one TeamInvite
     *   }
     * })
     * 
     */
    delete<T extends TeamInviteDeleteArgs>(args: SelectSubset<T, TeamInviteDeleteArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamInvite.
     * @param {TeamInviteUpdateArgs} args - Arguments to update one TeamInvite.
     * @example
     * // Update one TeamInvite
     * const teamInvite = await prisma.teamInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamInviteUpdateArgs>(args: SelectSubset<T, TeamInviteUpdateArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamInvites.
     * @param {TeamInviteDeleteManyArgs} args - Arguments to filter TeamInvites to delete.
     * @example
     * // Delete a few TeamInvites
     * const { count } = await prisma.teamInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamInviteDeleteManyArgs>(args?: SelectSubset<T, TeamInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamInvites
     * const teamInvite = await prisma.teamInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamInviteUpdateManyArgs>(args: SelectSubset<T, TeamInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamInvite.
     * @param {TeamInviteUpsertArgs} args - Arguments to update or create a TeamInvite.
     * @example
     * // Update or create a TeamInvite
     * const teamInvite = await prisma.teamInvite.upsert({
     *   create: {
     *     // ... data to create a TeamInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamInvite we want to update
     *   }
     * })
     */
    upsert<T extends TeamInviteUpsertArgs>(args: SelectSubset<T, TeamInviteUpsertArgs<ExtArgs>>): Prisma__TeamInviteClient<$Result.GetResult<Prisma.$TeamInvitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteCountArgs} args - Arguments to filter TeamInvites to count.
     * @example
     * // Count the number of TeamInvites
     * const count = await prisma.teamInvite.count({
     *   where: {
     *     // ... the filter for the TeamInvites we want to count
     *   }
     * })
    **/
    count<T extends TeamInviteCountArgs>(
      args?: Subset<T, TeamInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamInviteAggregateArgs>(args: Subset<T, TeamInviteAggregateArgs>): Prisma.PrismaPromise<GetTeamInviteAggregateType<T>>

    /**
     * Group by TeamInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamInviteGroupByArgs['orderBy'] }
        : { orderBy?: TeamInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamInvite model
   */
  readonly fields: TeamInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamInvite model
   */ 
  interface TeamInviteFieldRefs {
    readonly id: FieldRef<"TeamInvite", 'String'>
    readonly teamId: FieldRef<"TeamInvite", 'String'>
    readonly inviterId: FieldRef<"TeamInvite", 'String'>
    readonly status: FieldRef<"TeamInvite", 'InviteStatus'>
    readonly expiresAt: FieldRef<"TeamInvite", 'DateTime'>
    readonly createdAt: FieldRef<"TeamInvite", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamInvite", 'DateTime'>
    readonly email: FieldRef<"TeamInvite", 'String'>
    readonly name: FieldRef<"TeamInvite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeamInvite findUnique
   */
  export type TeamInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvite to fetch.
     */
    where: TeamInviteWhereUniqueInput
  }

  /**
   * TeamInvite findUniqueOrThrow
   */
  export type TeamInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvite to fetch.
     */
    where: TeamInviteWhereUniqueInput
  }

  /**
   * TeamInvite findFirst
   */
  export type TeamInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvite to fetch.
     */
    where?: TeamInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?: TeamInviteOrderByWithRelationInput | TeamInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamInvites.
     */
    cursor?: TeamInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamInvites.
     */
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[]
  }

  /**
   * TeamInvite findFirstOrThrow
   */
  export type TeamInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvite to fetch.
     */
    where?: TeamInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?: TeamInviteOrderByWithRelationInput | TeamInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamInvites.
     */
    cursor?: TeamInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamInvites.
     */
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[]
  }

  /**
   * TeamInvite findMany
   */
  export type TeamInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvites to fetch.
     */
    where?: TeamInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?: TeamInviteOrderByWithRelationInput | TeamInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamInvites.
     */
    cursor?: TeamInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvites.
     */
    skip?: number
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[]
  }

  /**
   * TeamInvite create
   */
  export type TeamInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamInvite.
     */
    data: XOR<TeamInviteCreateInput, TeamInviteUncheckedCreateInput>
  }

  /**
   * TeamInvite createMany
   */
  export type TeamInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamInvites.
     */
    data: TeamInviteCreateManyInput | TeamInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamInvite createManyAndReturn
   */
  export type TeamInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeamInvites.
     */
    data: TeamInviteCreateManyInput | TeamInviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamInvite update
   */
  export type TeamInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamInvite.
     */
    data: XOR<TeamInviteUpdateInput, TeamInviteUncheckedUpdateInput>
    /**
     * Choose, which TeamInvite to update.
     */
    where: TeamInviteWhereUniqueInput
  }

  /**
   * TeamInvite updateMany
   */
  export type TeamInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamInvites.
     */
    data: XOR<TeamInviteUpdateManyMutationInput, TeamInviteUncheckedUpdateManyInput>
    /**
     * Filter which TeamInvites to update
     */
    where?: TeamInviteWhereInput
  }

  /**
   * TeamInvite upsert
   */
  export type TeamInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamInvite to update in case it exists.
     */
    where: TeamInviteWhereUniqueInput
    /**
     * In case the TeamInvite found by the `where` argument doesn't exist, create a new TeamInvite with this data.
     */
    create: XOR<TeamInviteCreateInput, TeamInviteUncheckedCreateInput>
    /**
     * In case the TeamInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamInviteUpdateInput, TeamInviteUncheckedUpdateInput>
  }

  /**
   * TeamInvite delete
   */
  export type TeamInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
    /**
     * Filter which TeamInvite to delete.
     */
    where: TeamInviteWhereUniqueInput
  }

  /**
   * TeamInvite deleteMany
   */
  export type TeamInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamInvites to delete
     */
    where?: TeamInviteWhereInput
  }

  /**
   * TeamInvite without action
   */
  export type TeamInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    rateLimit: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    rateLimit: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    teamId: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    rateLimit: number | null
    isActive: boolean | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    teamId: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    rateLimit: number | null
    isActive: boolean | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    name: number
    key: number
    teamId: number
    lastUsedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    scopes: number
    rateLimit: number
    isActive: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    rateLimit?: true
  }

  export type ApiKeySumAggregateInputType = {
    rateLimit?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
    teamId?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    rateLimit?: true
    isActive?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
    teamId?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    rateLimit?: true
    isActive?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    teamId?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    scopes?: true
    rateLimit?: true
    isActive?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    name: string
    key: string
    teamId: string
    lastUsedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    scopes: string[]
    rateLimit: number
    isActive: boolean
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    teamId?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scopes?: boolean
    rateLimit?: boolean
    isActive?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    usageStats?: boolean | ApiKey$usageStatsArgs<ExtArgs>
    _count?: boolean | ApiKeyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    teamId?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scopes?: boolean
    rateLimit?: boolean
    isActive?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    name?: boolean
    key?: boolean
    teamId?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scopes?: boolean
    rateLimit?: boolean
    isActive?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    usageStats?: boolean | ApiKey$usageStatsArgs<ExtArgs>
    _count?: boolean | ApiKeyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      usageStats: Prisma.$ApiKeyUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      key: string
      teamId: string
      lastUsedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      scopes: string[]
      rateLimit: number
      isActive: boolean
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usageStats<T extends ApiKey$usageStatsArgs<ExtArgs> = {}>(args?: Subset<T, ApiKey$usageStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly teamId: FieldRef<"ApiKey", 'String'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly scopes: FieldRef<"ApiKey", 'String[]'>
    readonly rateLimit: FieldRef<"ApiKey", 'Int'>
    readonly isActive: FieldRef<"ApiKey", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey.usageStats
   */
  export type ApiKey$usageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    where?: ApiKeyUsageWhereInput
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    cursor?: ApiKeyUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model ApiKeyUsage
   */

  export type AggregateApiKeyUsage = {
    _count: ApiKeyUsageCountAggregateOutputType | null
    _min: ApiKeyUsageMinAggregateOutputType | null
    _max: ApiKeyUsageMaxAggregateOutputType | null
  }

  export type ApiKeyUsageMinAggregateOutputType = {
    id: string | null
    apiKeyId: string | null
    endpoint: string | null
    method: string | null
    timestamp: Date | null
    success: boolean | null
    error: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type ApiKeyUsageMaxAggregateOutputType = {
    id: string | null
    apiKeyId: string | null
    endpoint: string | null
    method: string | null
    timestamp: Date | null
    success: boolean | null
    error: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type ApiKeyUsageCountAggregateOutputType = {
    id: number
    apiKeyId: number
    endpoint: number
    method: number
    timestamp: number
    success: number
    error: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type ApiKeyUsageMinAggregateInputType = {
    id?: true
    apiKeyId?: true
    endpoint?: true
    method?: true
    timestamp?: true
    success?: true
    error?: true
    ipAddress?: true
    userAgent?: true
  }

  export type ApiKeyUsageMaxAggregateInputType = {
    id?: true
    apiKeyId?: true
    endpoint?: true
    method?: true
    timestamp?: true
    success?: true
    error?: true
    ipAddress?: true
    userAgent?: true
  }

  export type ApiKeyUsageCountAggregateInputType = {
    id?: true
    apiKeyId?: true
    endpoint?: true
    method?: true
    timestamp?: true
    success?: true
    error?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type ApiKeyUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyUsage to aggregate.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeyUsages
    **/
    _count?: true | ApiKeyUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyUsageMaxAggregateInputType
  }

  export type GetApiKeyUsageAggregateType<T extends ApiKeyUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKeyUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKeyUsage[P]>
      : GetScalarType<T[P], AggregateApiKeyUsage[P]>
  }




  export type ApiKeyUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyUsageWhereInput
    orderBy?: ApiKeyUsageOrderByWithAggregationInput | ApiKeyUsageOrderByWithAggregationInput[]
    by: ApiKeyUsageScalarFieldEnum[] | ApiKeyUsageScalarFieldEnum
    having?: ApiKeyUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyUsageCountAggregateInputType | true
    _min?: ApiKeyUsageMinAggregateInputType
    _max?: ApiKeyUsageMaxAggregateInputType
  }

  export type ApiKeyUsageGroupByOutputType = {
    id: string
    apiKeyId: string
    endpoint: string
    method: string
    timestamp: Date
    success: boolean
    error: string | null
    ipAddress: string | null
    userAgent: string | null
    _count: ApiKeyUsageCountAggregateOutputType | null
    _min: ApiKeyUsageMinAggregateOutputType | null
    _max: ApiKeyUsageMaxAggregateOutputType | null
  }

  type GetApiKeyUsageGroupByPayload<T extends ApiKeyUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyUsageGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyUsageGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeyUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiKeyId?: boolean
    endpoint?: boolean
    method?: boolean
    timestamp?: boolean
    success?: boolean
    error?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyUsage"]>

  export type ApiKeyUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiKeyId?: boolean
    endpoint?: boolean
    method?: boolean
    timestamp?: boolean
    success?: boolean
    error?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyUsage"]>

  export type ApiKeyUsageSelectScalar = {
    id?: boolean
    apiKeyId?: boolean
    endpoint?: boolean
    method?: boolean
    timestamp?: boolean
    success?: boolean
    error?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type ApiKeyUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }
  export type ApiKeyUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }

  export type $ApiKeyUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKeyUsage"
    objects: {
      apiKey: Prisma.$ApiKeyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apiKeyId: string
      endpoint: string
      method: string
      timestamp: Date
      success: boolean
      error: string | null
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["apiKeyUsage"]>
    composites: {}
  }

  type ApiKeyUsageGetPayload<S extends boolean | null | undefined | ApiKeyUsageDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyUsagePayload, S>

  type ApiKeyUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyUsageCountAggregateInputType | true
    }

  export interface ApiKeyUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKeyUsage'], meta: { name: 'ApiKeyUsage' } }
    /**
     * Find zero or one ApiKeyUsage that matches the filter.
     * @param {ApiKeyUsageFindUniqueArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyUsageFindUniqueArgs>(args: SelectSubset<T, ApiKeyUsageFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKeyUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyUsageFindUniqueOrThrowArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKeyUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageFindFirstArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyUsageFindFirstArgs>(args?: SelectSubset<T, ApiKeyUsageFindFirstArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKeyUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageFindFirstOrThrowArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeyUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeyUsages
     * const apiKeyUsages = await prisma.apiKeyUsage.findMany()
     * 
     * // Get first 10 ApiKeyUsages
     * const apiKeyUsages = await prisma.apiKeyUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyUsageWithIdOnly = await prisma.apiKeyUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyUsageFindManyArgs>(args?: SelectSubset<T, ApiKeyUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKeyUsage.
     * @param {ApiKeyUsageCreateArgs} args - Arguments to create a ApiKeyUsage.
     * @example
     * // Create one ApiKeyUsage
     * const ApiKeyUsage = await prisma.apiKeyUsage.create({
     *   data: {
     *     // ... data to create a ApiKeyUsage
     *   }
     * })
     * 
     */
    create<T extends ApiKeyUsageCreateArgs>(args: SelectSubset<T, ApiKeyUsageCreateArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeyUsages.
     * @param {ApiKeyUsageCreateManyArgs} args - Arguments to create many ApiKeyUsages.
     * @example
     * // Create many ApiKeyUsages
     * const apiKeyUsage = await prisma.apiKeyUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyUsageCreateManyArgs>(args?: SelectSubset<T, ApiKeyUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeyUsages and returns the data saved in the database.
     * @param {ApiKeyUsageCreateManyAndReturnArgs} args - Arguments to create many ApiKeyUsages.
     * @example
     * // Create many ApiKeyUsages
     * const apiKeyUsage = await prisma.apiKeyUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeyUsages and only return the `id`
     * const apiKeyUsageWithIdOnly = await prisma.apiKeyUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKeyUsage.
     * @param {ApiKeyUsageDeleteArgs} args - Arguments to delete one ApiKeyUsage.
     * @example
     * // Delete one ApiKeyUsage
     * const ApiKeyUsage = await prisma.apiKeyUsage.delete({
     *   where: {
     *     // ... filter to delete one ApiKeyUsage
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyUsageDeleteArgs>(args: SelectSubset<T, ApiKeyUsageDeleteArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKeyUsage.
     * @param {ApiKeyUsageUpdateArgs} args - Arguments to update one ApiKeyUsage.
     * @example
     * // Update one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUsageUpdateArgs>(args: SelectSubset<T, ApiKeyUsageUpdateArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeyUsages.
     * @param {ApiKeyUsageDeleteManyArgs} args - Arguments to filter ApiKeyUsages to delete.
     * @example
     * // Delete a few ApiKeyUsages
     * const { count } = await prisma.apiKeyUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyUsageDeleteManyArgs>(args?: SelectSubset<T, ApiKeyUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeyUsages
     * const apiKeyUsage = await prisma.apiKeyUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUsageUpdateManyArgs>(args: SelectSubset<T, ApiKeyUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKeyUsage.
     * @param {ApiKeyUsageUpsertArgs} args - Arguments to update or create a ApiKeyUsage.
     * @example
     * // Update or create a ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.upsert({
     *   create: {
     *     // ... data to create a ApiKeyUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKeyUsage we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUsageUpsertArgs>(args: SelectSubset<T, ApiKeyUsageUpsertArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeyUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageCountArgs} args - Arguments to filter ApiKeyUsages to count.
     * @example
     * // Count the number of ApiKeyUsages
     * const count = await prisma.apiKeyUsage.count({
     *   where: {
     *     // ... the filter for the ApiKeyUsages we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyUsageCountArgs>(
      args?: Subset<T, ApiKeyUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKeyUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyUsageAggregateArgs>(args: Subset<T, ApiKeyUsageAggregateArgs>): Prisma.PrismaPromise<GetApiKeyUsageAggregateType<T>>

    /**
     * Group by ApiKeyUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyUsageGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKeyUsage model
   */
  readonly fields: ApiKeyUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKeyUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiKey<T extends ApiKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiKeyDefaultArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKeyUsage model
   */ 
  interface ApiKeyUsageFieldRefs {
    readonly id: FieldRef<"ApiKeyUsage", 'String'>
    readonly apiKeyId: FieldRef<"ApiKeyUsage", 'String'>
    readonly endpoint: FieldRef<"ApiKeyUsage", 'String'>
    readonly method: FieldRef<"ApiKeyUsage", 'String'>
    readonly timestamp: FieldRef<"ApiKeyUsage", 'DateTime'>
    readonly success: FieldRef<"ApiKeyUsage", 'Boolean'>
    readonly error: FieldRef<"ApiKeyUsage", 'String'>
    readonly ipAddress: FieldRef<"ApiKeyUsage", 'String'>
    readonly userAgent: FieldRef<"ApiKeyUsage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiKeyUsage findUnique
   */
  export type ApiKeyUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage findUniqueOrThrow
   */
  export type ApiKeyUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage findFirst
   */
  export type ApiKeyUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyUsages.
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyUsages.
     */
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKeyUsage findFirstOrThrow
   */
  export type ApiKeyUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyUsages.
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyUsages.
     */
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKeyUsage findMany
   */
  export type ApiKeyUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsages to fetch.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeyUsages.
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKeyUsage create
   */
  export type ApiKeyUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKeyUsage.
     */
    data: XOR<ApiKeyUsageCreateInput, ApiKeyUsageUncheckedCreateInput>
  }

  /**
   * ApiKeyUsage createMany
   */
  export type ApiKeyUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeyUsages.
     */
    data: ApiKeyUsageCreateManyInput | ApiKeyUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKeyUsage createManyAndReturn
   */
  export type ApiKeyUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeyUsages.
     */
    data: ApiKeyUsageCreateManyInput | ApiKeyUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyUsage update
   */
  export type ApiKeyUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKeyUsage.
     */
    data: XOR<ApiKeyUsageUpdateInput, ApiKeyUsageUncheckedUpdateInput>
    /**
     * Choose, which ApiKeyUsage to update.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage updateMany
   */
  export type ApiKeyUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeyUsages.
     */
    data: XOR<ApiKeyUsageUpdateManyMutationInput, ApiKeyUsageUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyUsages to update
     */
    where?: ApiKeyUsageWhereInput
  }

  /**
   * ApiKeyUsage upsert
   */
  export type ApiKeyUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKeyUsage to update in case it exists.
     */
    where: ApiKeyUsageWhereUniqueInput
    /**
     * In case the ApiKeyUsage found by the `where` argument doesn't exist, create a new ApiKeyUsage with this data.
     */
    create: XOR<ApiKeyUsageCreateInput, ApiKeyUsageUncheckedCreateInput>
    /**
     * In case the ApiKeyUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUsageUpdateInput, ApiKeyUsageUncheckedUpdateInput>
  }

  /**
   * ApiKeyUsage delete
   */
  export type ApiKeyUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter which ApiKeyUsage to delete.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage deleteMany
   */
  export type ApiKeyUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyUsages to delete
     */
    where?: ApiKeyUsageWhereInput
  }

  /**
   * ApiKeyUsage without action
   */
  export type ApiKeyUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    templateId: string | null
    teamId: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    schedule: $Enums.CampaignSchedule | null
    listId: string | null
    recurringSchedule: $Enums.CampaignRecurringSchedule | null
    cronExpression: string | null
    smtpConfigId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    templateId: string | null
    teamId: string | null
    status: $Enums.CampaignStatus | null
    scheduledFor: Date | null
    schedule: $Enums.CampaignSchedule | null
    listId: string | null
    recurringSchedule: $Enums.CampaignRecurringSchedule | null
    cronExpression: string | null
    smtpConfigId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    templateId: number
    teamId: number
    status: number
    scheduledFor: number
    schedule: number
    listId: number
    recurringSchedule: number
    cronExpression: number
    smtpConfigId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    templateId?: true
    teamId?: true
    status?: true
    scheduledFor?: true
    schedule?: true
    listId?: true
    recurringSchedule?: true
    cronExpression?: true
    smtpConfigId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    templateId?: true
    teamId?: true
    status?: true
    scheduledFor?: true
    schedule?: true
    listId?: true
    recurringSchedule?: true
    cronExpression?: true
    smtpConfigId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    templateId?: true
    teamId?: true
    status?: true
    scheduledFor?: true
    schedule?: true
    listId?: true
    recurringSchedule?: true
    cronExpression?: true
    smtpConfigId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    templateId: string
    teamId: string
    status: $Enums.CampaignStatus
    scheduledFor: Date | null
    schedule: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule: $Enums.CampaignRecurringSchedule | null
    cronExpression: string | null
    smtpConfigId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    templateId?: boolean
    teamId?: boolean
    status?: boolean
    scheduledFor?: boolean
    schedule?: boolean
    listId?: boolean
    recurringSchedule?: boolean
    cronExpression?: boolean
    smtpConfigId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
    sentEmails?: boolean | Campaign$sentEmailsArgs<ExtArgs>
    analytics?: boolean | Campaign$analyticsArgs<ExtArgs>
    smtpConfig?: boolean | Campaign$smtpConfigArgs<ExtArgs>
    emailJobs?: boolean | Campaign$emailJobsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    templateId?: boolean
    teamId?: boolean
    status?: boolean
    scheduledFor?: boolean
    schedule?: boolean
    listId?: boolean
    recurringSchedule?: boolean
    cronExpression?: boolean
    smtpConfigId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
    smtpConfig?: boolean | Campaign$smtpConfigArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    templateId?: boolean
    teamId?: boolean
    status?: boolean
    scheduledFor?: boolean
    schedule?: boolean
    listId?: boolean
    recurringSchedule?: boolean
    cronExpression?: boolean
    smtpConfigId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
    sentEmails?: boolean | Campaign$sentEmailsArgs<ExtArgs>
    analytics?: boolean | Campaign$analyticsArgs<ExtArgs>
    smtpConfig?: boolean | Campaign$smtpConfigArgs<ExtArgs>
    emailJobs?: boolean | Campaign$emailJobsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
    smtpConfig?: boolean | Campaign$smtpConfigArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      template: Prisma.$EmailTemplatePayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      mailingList: Prisma.$MailingListPayload<ExtArgs>
      sentEmails: Prisma.$SentEmailPayload<ExtArgs>[]
      analytics: Prisma.$CampaignAnalyticsPayload<ExtArgs> | null
      smtpConfig: Prisma.$SmtpConfigPayload<ExtArgs> | null
      emailJobs: Prisma.$EmailJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      templateId: string
      teamId: string
      status: $Enums.CampaignStatus
      scheduledFor: Date | null
      schedule: $Enums.CampaignSchedule | null
      listId: string
      recurringSchedule: $Enums.CampaignRecurringSchedule | null
      cronExpression: string | null
      smtpConfigId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends EmailTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplateDefaultArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mailingList<T extends MailingListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MailingListDefaultArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sentEmails<T extends Campaign$sentEmailsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$sentEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends Campaign$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$analyticsArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    smtpConfig<T extends Campaign$smtpConfigArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$smtpConfigArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    emailJobs<T extends Campaign$emailJobsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$emailJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly templateId: FieldRef<"Campaign", 'String'>
    readonly teamId: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly scheduledFor: FieldRef<"Campaign", 'DateTime'>
    readonly schedule: FieldRef<"Campaign", 'CampaignSchedule'>
    readonly listId: FieldRef<"Campaign", 'String'>
    readonly recurringSchedule: FieldRef<"Campaign", 'CampaignRecurringSchedule'>
    readonly cronExpression: FieldRef<"Campaign", 'String'>
    readonly smtpConfigId: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.sentEmails
   */
  export type Campaign$sentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    cursor?: SentEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * Campaign.analytics
   */
  export type Campaign$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    where?: CampaignAnalyticsWhereInput
  }

  /**
   * Campaign.smtpConfig
   */
  export type Campaign$smtpConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    where?: SmtpConfigWhereInput
  }

  /**
   * Campaign.emailJobs
   */
  export type Campaign$emailJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    where?: EmailJobWhereInput
    orderBy?: EmailJobOrderByWithRelationInput | EmailJobOrderByWithRelationInput[]
    cursor?: EmailJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailJobScalarFieldEnum | EmailJobScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model MailingList
   */

  export type AggregateMailingList = {
    _count: MailingListCountAggregateOutputType | null
    _min: MailingListMinAggregateOutputType | null
    _max: MailingListMaxAggregateOutputType | null
  }

  export type MailingListMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailingListMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailingListCountAggregateOutputType = {
    id: number
    name: number
    description: number
    teamId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MailingListMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailingListMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailingListCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MailingListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailingList to aggregate.
     */
    where?: MailingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailingLists to fetch.
     */
    orderBy?: MailingListOrderByWithRelationInput | MailingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MailingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MailingLists
    **/
    _count?: true | MailingListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailingListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailingListMaxAggregateInputType
  }

  export type GetMailingListAggregateType<T extends MailingListAggregateArgs> = {
        [P in keyof T & keyof AggregateMailingList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMailingList[P]>
      : GetScalarType<T[P], AggregateMailingList[P]>
  }




  export type MailingListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailingListWhereInput
    orderBy?: MailingListOrderByWithAggregationInput | MailingListOrderByWithAggregationInput[]
    by: MailingListScalarFieldEnum[] | MailingListScalarFieldEnum
    having?: MailingListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailingListCountAggregateInputType | true
    _min?: MailingListMinAggregateInputType
    _max?: MailingListMaxAggregateInputType
  }

  export type MailingListGroupByOutputType = {
    id: string
    name: string
    description: string | null
    teamId: string
    createdAt: Date
    updatedAt: Date
    _count: MailingListCountAggregateOutputType | null
    _min: MailingListMinAggregateOutputType | null
    _max: MailingListMaxAggregateOutputType | null
  }

  type GetMailingListGroupByPayload<T extends MailingListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailingListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailingListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailingListGroupByOutputType[P]>
            : GetScalarType<T[P], MailingListGroupByOutputType[P]>
        }
      >
    >


  export type MailingListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    subscribers?: boolean | MailingList$subscribersArgs<ExtArgs>
    campaigns?: boolean | MailingList$campaignsArgs<ExtArgs>
    _count?: boolean | MailingListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mailingList"]>

  export type MailingListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mailingList"]>

  export type MailingListSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MailingListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    subscribers?: boolean | MailingList$subscribersArgs<ExtArgs>
    campaigns?: boolean | MailingList$campaignsArgs<ExtArgs>
    _count?: boolean | MailingListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MailingListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $MailingListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MailingList"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      subscribers: Prisma.$SubscriberPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      teamId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mailingList"]>
    composites: {}
  }

  type MailingListGetPayload<S extends boolean | null | undefined | MailingListDefaultArgs> = $Result.GetResult<Prisma.$MailingListPayload, S>

  type MailingListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MailingListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MailingListCountAggregateInputType | true
    }

  export interface MailingListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MailingList'], meta: { name: 'MailingList' } }
    /**
     * Find zero or one MailingList that matches the filter.
     * @param {MailingListFindUniqueArgs} args - Arguments to find a MailingList
     * @example
     * // Get one MailingList
     * const mailingList = await prisma.mailingList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MailingListFindUniqueArgs>(args: SelectSubset<T, MailingListFindUniqueArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MailingList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MailingListFindUniqueOrThrowArgs} args - Arguments to find a MailingList
     * @example
     * // Get one MailingList
     * const mailingList = await prisma.mailingList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MailingListFindUniqueOrThrowArgs>(args: SelectSubset<T, MailingListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MailingList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailingListFindFirstArgs} args - Arguments to find a MailingList
     * @example
     * // Get one MailingList
     * const mailingList = await prisma.mailingList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MailingListFindFirstArgs>(args?: SelectSubset<T, MailingListFindFirstArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MailingList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailingListFindFirstOrThrowArgs} args - Arguments to find a MailingList
     * @example
     * // Get one MailingList
     * const mailingList = await prisma.mailingList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MailingListFindFirstOrThrowArgs>(args?: SelectSubset<T, MailingListFindFirstOrThrowArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MailingLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailingListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MailingLists
     * const mailingLists = await prisma.mailingList.findMany()
     * 
     * // Get first 10 MailingLists
     * const mailingLists = await prisma.mailingList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailingListWithIdOnly = await prisma.mailingList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MailingListFindManyArgs>(args?: SelectSubset<T, MailingListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MailingList.
     * @param {MailingListCreateArgs} args - Arguments to create a MailingList.
     * @example
     * // Create one MailingList
     * const MailingList = await prisma.mailingList.create({
     *   data: {
     *     // ... data to create a MailingList
     *   }
     * })
     * 
     */
    create<T extends MailingListCreateArgs>(args: SelectSubset<T, MailingListCreateArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MailingLists.
     * @param {MailingListCreateManyArgs} args - Arguments to create many MailingLists.
     * @example
     * // Create many MailingLists
     * const mailingList = await prisma.mailingList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MailingListCreateManyArgs>(args?: SelectSubset<T, MailingListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MailingLists and returns the data saved in the database.
     * @param {MailingListCreateManyAndReturnArgs} args - Arguments to create many MailingLists.
     * @example
     * // Create many MailingLists
     * const mailingList = await prisma.mailingList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MailingLists and only return the `id`
     * const mailingListWithIdOnly = await prisma.mailingList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MailingListCreateManyAndReturnArgs>(args?: SelectSubset<T, MailingListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MailingList.
     * @param {MailingListDeleteArgs} args - Arguments to delete one MailingList.
     * @example
     * // Delete one MailingList
     * const MailingList = await prisma.mailingList.delete({
     *   where: {
     *     // ... filter to delete one MailingList
     *   }
     * })
     * 
     */
    delete<T extends MailingListDeleteArgs>(args: SelectSubset<T, MailingListDeleteArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MailingList.
     * @param {MailingListUpdateArgs} args - Arguments to update one MailingList.
     * @example
     * // Update one MailingList
     * const mailingList = await prisma.mailingList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MailingListUpdateArgs>(args: SelectSubset<T, MailingListUpdateArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MailingLists.
     * @param {MailingListDeleteManyArgs} args - Arguments to filter MailingLists to delete.
     * @example
     * // Delete a few MailingLists
     * const { count } = await prisma.mailingList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MailingListDeleteManyArgs>(args?: SelectSubset<T, MailingListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailingListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MailingLists
     * const mailingList = await prisma.mailingList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MailingListUpdateManyArgs>(args: SelectSubset<T, MailingListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MailingList.
     * @param {MailingListUpsertArgs} args - Arguments to update or create a MailingList.
     * @example
     * // Update or create a MailingList
     * const mailingList = await prisma.mailingList.upsert({
     *   create: {
     *     // ... data to create a MailingList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MailingList we want to update
     *   }
     * })
     */
    upsert<T extends MailingListUpsertArgs>(args: SelectSubset<T, MailingListUpsertArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MailingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailingListCountArgs} args - Arguments to filter MailingLists to count.
     * @example
     * // Count the number of MailingLists
     * const count = await prisma.mailingList.count({
     *   where: {
     *     // ... the filter for the MailingLists we want to count
     *   }
     * })
    **/
    count<T extends MailingListCountArgs>(
      args?: Subset<T, MailingListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailingListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MailingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailingListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailingListAggregateArgs>(args: Subset<T, MailingListAggregateArgs>): Prisma.PrismaPromise<GetMailingListAggregateType<T>>

    /**
     * Group by MailingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailingListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailingListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailingListGroupByArgs['orderBy'] }
        : { orderBy?: MailingListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailingListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailingListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MailingList model
   */
  readonly fields: MailingListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MailingList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MailingListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subscribers<T extends MailingList$subscribersArgs<ExtArgs> = {}>(args?: Subset<T, MailingList$subscribersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findMany"> | Null>
    campaigns<T extends MailingList$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, MailingList$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MailingList model
   */ 
  interface MailingListFieldRefs {
    readonly id: FieldRef<"MailingList", 'String'>
    readonly name: FieldRef<"MailingList", 'String'>
    readonly description: FieldRef<"MailingList", 'String'>
    readonly teamId: FieldRef<"MailingList", 'String'>
    readonly createdAt: FieldRef<"MailingList", 'DateTime'>
    readonly updatedAt: FieldRef<"MailingList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MailingList findUnique
   */
  export type MailingListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * Filter, which MailingList to fetch.
     */
    where: MailingListWhereUniqueInput
  }

  /**
   * MailingList findUniqueOrThrow
   */
  export type MailingListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * Filter, which MailingList to fetch.
     */
    where: MailingListWhereUniqueInput
  }

  /**
   * MailingList findFirst
   */
  export type MailingListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * Filter, which MailingList to fetch.
     */
    where?: MailingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailingLists to fetch.
     */
    orderBy?: MailingListOrderByWithRelationInput | MailingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailingLists.
     */
    cursor?: MailingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailingLists.
     */
    distinct?: MailingListScalarFieldEnum | MailingListScalarFieldEnum[]
  }

  /**
   * MailingList findFirstOrThrow
   */
  export type MailingListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * Filter, which MailingList to fetch.
     */
    where?: MailingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailingLists to fetch.
     */
    orderBy?: MailingListOrderByWithRelationInput | MailingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailingLists.
     */
    cursor?: MailingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailingLists.
     */
    distinct?: MailingListScalarFieldEnum | MailingListScalarFieldEnum[]
  }

  /**
   * MailingList findMany
   */
  export type MailingListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * Filter, which MailingLists to fetch.
     */
    where?: MailingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailingLists to fetch.
     */
    orderBy?: MailingListOrderByWithRelationInput | MailingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MailingLists.
     */
    cursor?: MailingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailingLists.
     */
    skip?: number
    distinct?: MailingListScalarFieldEnum | MailingListScalarFieldEnum[]
  }

  /**
   * MailingList create
   */
  export type MailingListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * The data needed to create a MailingList.
     */
    data: XOR<MailingListCreateInput, MailingListUncheckedCreateInput>
  }

  /**
   * MailingList createMany
   */
  export type MailingListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MailingLists.
     */
    data: MailingListCreateManyInput | MailingListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MailingList createManyAndReturn
   */
  export type MailingListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MailingLists.
     */
    data: MailingListCreateManyInput | MailingListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MailingList update
   */
  export type MailingListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * The data needed to update a MailingList.
     */
    data: XOR<MailingListUpdateInput, MailingListUncheckedUpdateInput>
    /**
     * Choose, which MailingList to update.
     */
    where: MailingListWhereUniqueInput
  }

  /**
   * MailingList updateMany
   */
  export type MailingListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MailingLists.
     */
    data: XOR<MailingListUpdateManyMutationInput, MailingListUncheckedUpdateManyInput>
    /**
     * Filter which MailingLists to update
     */
    where?: MailingListWhereInput
  }

  /**
   * MailingList upsert
   */
  export type MailingListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * The filter to search for the MailingList to update in case it exists.
     */
    where: MailingListWhereUniqueInput
    /**
     * In case the MailingList found by the `where` argument doesn't exist, create a new MailingList with this data.
     */
    create: XOR<MailingListCreateInput, MailingListUncheckedCreateInput>
    /**
     * In case the MailingList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MailingListUpdateInput, MailingListUncheckedUpdateInput>
  }

  /**
   * MailingList delete
   */
  export type MailingListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
    /**
     * Filter which MailingList to delete.
     */
    where: MailingListWhereUniqueInput
  }

  /**
   * MailingList deleteMany
   */
  export type MailingListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailingLists to delete
     */
    where?: MailingListWhereInput
  }

  /**
   * MailingList.subscribers
   */
  export type MailingList$subscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    where?: SubscriberWhereInput
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    cursor?: SubscriberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * MailingList.campaigns
   */
  export type MailingList$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * MailingList without action
   */
  export type MailingListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailingList
     */
    select?: MailingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailingListInclude<ExtArgs> | null
  }


  /**
   * Model Subscriber
   */

  export type AggregateSubscriber = {
    _count: SubscriberCountAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  export type SubscriberMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    company: string | null
    title: string | null
    address: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    source: string | null
    listId: string | null
    status: $Enums.SubscriberStatus | null
    unsubscribedAt: Date | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriberMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    company: string | null
    title: string | null
    address: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    source: string | null
    listId: string | null
    status: $Enums.SubscriberStatus | null
    unsubscribedAt: Date | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriberCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    phone: number
    company: number
    title: number
    address: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    metadata: number
    tags: number
    customFields: number
    source: number
    listId: number
    status: number
    unsubscribedAt: number
    lastActivityAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriberMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    company?: true
    title?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    source?: true
    listId?: true
    status?: true
    unsubscribedAt?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriberMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    company?: true
    title?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    source?: true
    listId?: true
    status?: true
    unsubscribedAt?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriberCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    company?: true
    title?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    metadata?: true
    tags?: true
    customFields?: true
    source?: true
    listId?: true
    status?: true
    unsubscribedAt?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriber to aggregate.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscribers
    **/
    _count?: true | SubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriberMaxAggregateInputType
  }

  export type GetSubscriberAggregateType<T extends SubscriberAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriber[P]>
      : GetScalarType<T[P], AggregateSubscriber[P]>
  }




  export type SubscriberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberWhereInput
    orderBy?: SubscriberOrderByWithAggregationInput | SubscriberOrderByWithAggregationInput[]
    by: SubscriberScalarFieldEnum[] | SubscriberScalarFieldEnum
    having?: SubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriberCountAggregateInputType | true
    _min?: SubscriberMinAggregateInputType
    _max?: SubscriberMaxAggregateInputType
  }

  export type SubscriberGroupByOutputType = {
    id: string
    email: string
    firstName: string | null
    lastName: string | null
    phone: string | null
    company: string | null
    title: string | null
    address: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    metadata: JsonValue | null
    tags: string[]
    customFields: JsonValue | null
    source: string | null
    listId: string
    status: $Enums.SubscriberStatus
    unsubscribedAt: Date | null
    lastActivityAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriberCountAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  type GetSubscriberGroupByPayload<T extends SubscriberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
        }
      >
    >


  export type SubscriberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    company?: boolean
    title?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    metadata?: boolean
    tags?: boolean
    customFields?: boolean
    source?: boolean
    listId?: boolean
    status?: boolean
    unsubscribedAt?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
    sentEmails?: boolean | Subscriber$sentEmailsArgs<ExtArgs>
    _count?: boolean | SubscriberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    company?: boolean
    title?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    metadata?: boolean
    tags?: boolean
    customFields?: boolean
    source?: boolean
    listId?: boolean
    status?: boolean
    unsubscribedAt?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    company?: boolean
    title?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    metadata?: boolean
    tags?: boolean
    customFields?: boolean
    source?: boolean
    listId?: boolean
    status?: boolean
    unsubscribedAt?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
    sentEmails?: boolean | Subscriber$sentEmailsArgs<ExtArgs>
    _count?: boolean | SubscriberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mailingList?: boolean | MailingListDefaultArgs<ExtArgs>
  }

  export type $SubscriberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriber"
    objects: {
      mailingList: Prisma.$MailingListPayload<ExtArgs>
      sentEmails: Prisma.$SentEmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string | null
      lastName: string | null
      phone: string | null
      company: string | null
      title: string | null
      address: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      metadata: Prisma.JsonValue | null
      tags: string[]
      customFields: Prisma.JsonValue | null
      source: string | null
      listId: string
      status: $Enums.SubscriberStatus
      unsubscribedAt: Date | null
      lastActivityAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriber"]>
    composites: {}
  }

  type SubscriberGetPayload<S extends boolean | null | undefined | SubscriberDefaultArgs> = $Result.GetResult<Prisma.$SubscriberPayload, S>

  type SubscriberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriberCountAggregateInputType | true
    }

  export interface SubscriberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriber'], meta: { name: 'Subscriber' } }
    /**
     * Find zero or one Subscriber that matches the filter.
     * @param {SubscriberFindUniqueArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriberFindUniqueArgs>(args: SelectSubset<T, SubscriberFindUniqueArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscriber that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriberFindUniqueOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriberFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriberFindFirstArgs>(args?: SelectSubset<T, SubscriberFindFirstArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscriber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriberFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribers
     * const subscribers = await prisma.subscriber.findMany()
     * 
     * // Get first 10 Subscribers
     * const subscribers = await prisma.subscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriberFindManyArgs>(args?: SelectSubset<T, SubscriberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscriber.
     * @param {SubscriberCreateArgs} args - Arguments to create a Subscriber.
     * @example
     * // Create one Subscriber
     * const Subscriber = await prisma.subscriber.create({
     *   data: {
     *     // ... data to create a Subscriber
     *   }
     * })
     * 
     */
    create<T extends SubscriberCreateArgs>(args: SelectSubset<T, SubscriberCreateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscribers.
     * @param {SubscriberCreateManyArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriberCreateManyArgs>(args?: SelectSubset<T, SubscriberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscribers and returns the data saved in the database.
     * @param {SubscriberCreateManyAndReturnArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscribers and only return the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriberCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscriber.
     * @param {SubscriberDeleteArgs} args - Arguments to delete one Subscriber.
     * @example
     * // Delete one Subscriber
     * const Subscriber = await prisma.subscriber.delete({
     *   where: {
     *     // ... filter to delete one Subscriber
     *   }
     * })
     * 
     */
    delete<T extends SubscriberDeleteArgs>(args: SelectSubset<T, SubscriberDeleteArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscriber.
     * @param {SubscriberUpdateArgs} args - Arguments to update one Subscriber.
     * @example
     * // Update one Subscriber
     * const subscriber = await prisma.subscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriberUpdateArgs>(args: SelectSubset<T, SubscriberUpdateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscribers.
     * @param {SubscriberDeleteManyArgs} args - Arguments to filter Subscribers to delete.
     * @example
     * // Delete a few Subscribers
     * const { count } = await prisma.subscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriberDeleteManyArgs>(args?: SelectSubset<T, SubscriberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribers
     * const subscriber = await prisma.subscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriberUpdateManyArgs>(args: SelectSubset<T, SubscriberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriber.
     * @param {SubscriberUpsertArgs} args - Arguments to update or create a Subscriber.
     * @example
     * // Update or create a Subscriber
     * const subscriber = await prisma.subscriber.upsert({
     *   create: {
     *     // ... data to create a Subscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriber we want to update
     *   }
     * })
     */
    upsert<T extends SubscriberUpsertArgs>(args: SelectSubset<T, SubscriberUpsertArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberCountArgs} args - Arguments to filter Subscribers to count.
     * @example
     * // Count the number of Subscribers
     * const count = await prisma.subscriber.count({
     *   where: {
     *     // ... the filter for the Subscribers we want to count
     *   }
     * })
    **/
    count<T extends SubscriberCountArgs>(
      args?: Subset<T, SubscriberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriberAggregateArgs>(args: Subset<T, SubscriberAggregateArgs>): Prisma.PrismaPromise<GetSubscriberAggregateType<T>>

    /**
     * Group by Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriberGroupByArgs['orderBy'] }
        : { orderBy?: SubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriber model
   */
  readonly fields: SubscriberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mailingList<T extends MailingListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MailingListDefaultArgs<ExtArgs>>): Prisma__MailingListClient<$Result.GetResult<Prisma.$MailingListPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sentEmails<T extends Subscriber$sentEmailsArgs<ExtArgs> = {}>(args?: Subset<T, Subscriber$sentEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscriber model
   */ 
  interface SubscriberFieldRefs {
    readonly id: FieldRef<"Subscriber", 'String'>
    readonly email: FieldRef<"Subscriber", 'String'>
    readonly firstName: FieldRef<"Subscriber", 'String'>
    readonly lastName: FieldRef<"Subscriber", 'String'>
    readonly phone: FieldRef<"Subscriber", 'String'>
    readonly company: FieldRef<"Subscriber", 'String'>
    readonly title: FieldRef<"Subscriber", 'String'>
    readonly address: FieldRef<"Subscriber", 'String'>
    readonly addressLine2: FieldRef<"Subscriber", 'String'>
    readonly city: FieldRef<"Subscriber", 'String'>
    readonly state: FieldRef<"Subscriber", 'String'>
    readonly postalCode: FieldRef<"Subscriber", 'String'>
    readonly country: FieldRef<"Subscriber", 'String'>
    readonly metadata: FieldRef<"Subscriber", 'Json'>
    readonly tags: FieldRef<"Subscriber", 'String[]'>
    readonly customFields: FieldRef<"Subscriber", 'Json'>
    readonly source: FieldRef<"Subscriber", 'String'>
    readonly listId: FieldRef<"Subscriber", 'String'>
    readonly status: FieldRef<"Subscriber", 'SubscriberStatus'>
    readonly unsubscribedAt: FieldRef<"Subscriber", 'DateTime'>
    readonly lastActivityAt: FieldRef<"Subscriber", 'DateTime'>
    readonly createdAt: FieldRef<"Subscriber", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscriber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscriber findUnique
   */
  export type SubscriberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findUniqueOrThrow
   */
  export type SubscriberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findFirst
   */
  export type SubscriberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findFirstOrThrow
   */
  export type SubscriberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findMany
   */
  export type SubscriberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscribers to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber create
   */
  export type SubscriberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscriber.
     */
    data: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
  }

  /**
   * Subscriber createMany
   */
  export type SubscriberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriber createManyAndReturn
   */
  export type SubscriberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriber update
   */
  export type SubscriberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscriber.
     */
    data: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
    /**
     * Choose, which Subscriber to update.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber updateMany
   */
  export type SubscriberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscribers.
     */
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyInput>
    /**
     * Filter which Subscribers to update
     */
    where?: SubscriberWhereInput
  }

  /**
   * Subscriber upsert
   */
  export type SubscriberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscriber to update in case it exists.
     */
    where: SubscriberWhereUniqueInput
    /**
     * In case the Subscriber found by the `where` argument doesn't exist, create a new Subscriber with this data.
     */
    create: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
    /**
     * In case the Subscriber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
  }

  /**
   * Subscriber delete
   */
  export type SubscriberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter which Subscriber to delete.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber deleteMany
   */
  export type SubscriberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscribers to delete
     */
    where?: SubscriberWhereInput
  }

  /**
   * Subscriber.sentEmails
   */
  export type Subscriber$sentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    cursor?: SentEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * Subscriber without action
   */
  export type SubscriberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
  }


  /**
   * Model SentEmail
   */

  export type AggregateSentEmail = {
    _count: SentEmailCountAggregateOutputType | null
    _min: SentEmailMinAggregateOutputType | null
    _max: SentEmailMaxAggregateOutputType | null
  }

  export type SentEmailMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    campaignId: string | null
    recipient: string | null
    subject: string | null
    content: string | null
    status: $Enums.EmailStatus | null
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    teamId: string | null
    error: string | null
    jobId: string | null
    subscriberId: string | null
  }

  export type SentEmailMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    campaignId: string | null
    recipient: string | null
    subject: string | null
    content: string | null
    status: $Enums.EmailStatus | null
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    teamId: string | null
    error: string | null
    jobId: string | null
    subscriberId: string | null
  }

  export type SentEmailCountAggregateOutputType = {
    id: number
    templateId: number
    campaignId: number
    recipient: number
    subject: number
    content: number
    status: number
    sentAt: number
    openedAt: number
    clickedAt: number
    teamId: number
    error: number
    metadata: number
    jobId: number
    subscriberId: number
    _all: number
  }


  export type SentEmailMinAggregateInputType = {
    id?: true
    templateId?: true
    campaignId?: true
    recipient?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
    teamId?: true
    error?: true
    jobId?: true
    subscriberId?: true
  }

  export type SentEmailMaxAggregateInputType = {
    id?: true
    templateId?: true
    campaignId?: true
    recipient?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
    teamId?: true
    error?: true
    jobId?: true
    subscriberId?: true
  }

  export type SentEmailCountAggregateInputType = {
    id?: true
    templateId?: true
    campaignId?: true
    recipient?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
    teamId?: true
    error?: true
    metadata?: true
    jobId?: true
    subscriberId?: true
    _all?: true
  }

  export type SentEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SentEmail to aggregate.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SentEmails
    **/
    _count?: true | SentEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SentEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SentEmailMaxAggregateInputType
  }

  export type GetSentEmailAggregateType<T extends SentEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateSentEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSentEmail[P]>
      : GetScalarType<T[P], AggregateSentEmail[P]>
  }




  export type SentEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithAggregationInput | SentEmailOrderByWithAggregationInput[]
    by: SentEmailScalarFieldEnum[] | SentEmailScalarFieldEnum
    having?: SentEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SentEmailCountAggregateInputType | true
    _min?: SentEmailMinAggregateInputType
    _max?: SentEmailMaxAggregateInputType
  }

  export type SentEmailGroupByOutputType = {
    id: string
    templateId: string | null
    campaignId: string | null
    recipient: string
    subject: string
    content: string | null
    status: $Enums.EmailStatus
    sentAt: Date
    openedAt: Date | null
    clickedAt: Date | null
    teamId: string
    error: string | null
    metadata: JsonValue | null
    jobId: string | null
    subscriberId: string | null
    _count: SentEmailCountAggregateOutputType | null
    _min: SentEmailMinAggregateOutputType | null
    _max: SentEmailMaxAggregateOutputType | null
  }

  type GetSentEmailGroupByPayload<T extends SentEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SentEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SentEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SentEmailGroupByOutputType[P]>
            : GetScalarType<T[P], SentEmailGroupByOutputType[P]>
        }
      >
    >


  export type SentEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    campaignId?: boolean
    recipient?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    teamId?: boolean
    error?: boolean
    metadata?: boolean
    jobId?: boolean
    subscriberId?: boolean
    template?: boolean | SentEmail$templateArgs<ExtArgs>
    campaign?: boolean | SentEmail$campaignArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    emailJob?: boolean | SentEmail$emailJobArgs<ExtArgs>
    subscriber?: boolean | SentEmail$subscriberArgs<ExtArgs>
    tracking?: boolean | SentEmail$trackingArgs<ExtArgs>
    _count?: boolean | SentEmailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sentEmail"]>

  export type SentEmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    campaignId?: boolean
    recipient?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    teamId?: boolean
    error?: boolean
    metadata?: boolean
    jobId?: boolean
    subscriberId?: boolean
    template?: boolean | SentEmail$templateArgs<ExtArgs>
    campaign?: boolean | SentEmail$campaignArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    emailJob?: boolean | SentEmail$emailJobArgs<ExtArgs>
    subscriber?: boolean | SentEmail$subscriberArgs<ExtArgs>
  }, ExtArgs["result"]["sentEmail"]>

  export type SentEmailSelectScalar = {
    id?: boolean
    templateId?: boolean
    campaignId?: boolean
    recipient?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    teamId?: boolean
    error?: boolean
    metadata?: boolean
    jobId?: boolean
    subscriberId?: boolean
  }

  export type SentEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | SentEmail$templateArgs<ExtArgs>
    campaign?: boolean | SentEmail$campaignArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    emailJob?: boolean | SentEmail$emailJobArgs<ExtArgs>
    subscriber?: boolean | SentEmail$subscriberArgs<ExtArgs>
    tracking?: boolean | SentEmail$trackingArgs<ExtArgs>
    _count?: boolean | SentEmailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SentEmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | SentEmail$templateArgs<ExtArgs>
    campaign?: boolean | SentEmail$campaignArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    emailJob?: boolean | SentEmail$emailJobArgs<ExtArgs>
    subscriber?: boolean | SentEmail$subscriberArgs<ExtArgs>
  }

  export type $SentEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SentEmail"
    objects: {
      template: Prisma.$EmailTemplatePayload<ExtArgs> | null
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs>
      emailJob: Prisma.$EmailJobPayload<ExtArgs> | null
      subscriber: Prisma.$SubscriberPayload<ExtArgs> | null
      tracking: Prisma.$EmailTrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      templateId: string | null
      campaignId: string | null
      recipient: string
      subject: string
      content: string | null
      status: $Enums.EmailStatus
      sentAt: Date
      openedAt: Date | null
      clickedAt: Date | null
      teamId: string
      error: string | null
      metadata: Prisma.JsonValue | null
      jobId: string | null
      subscriberId: string | null
    }, ExtArgs["result"]["sentEmail"]>
    composites: {}
  }

  type SentEmailGetPayload<S extends boolean | null | undefined | SentEmailDefaultArgs> = $Result.GetResult<Prisma.$SentEmailPayload, S>

  type SentEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SentEmailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SentEmailCountAggregateInputType | true
    }

  export interface SentEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SentEmail'], meta: { name: 'SentEmail' } }
    /**
     * Find zero or one SentEmail that matches the filter.
     * @param {SentEmailFindUniqueArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SentEmailFindUniqueArgs>(args: SelectSubset<T, SentEmailFindUniqueArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SentEmail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SentEmailFindUniqueOrThrowArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SentEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, SentEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SentEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindFirstArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SentEmailFindFirstArgs>(args?: SelectSubset<T, SentEmailFindFirstArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SentEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindFirstOrThrowArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SentEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, SentEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SentEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SentEmails
     * const sentEmails = await prisma.sentEmail.findMany()
     * 
     * // Get first 10 SentEmails
     * const sentEmails = await prisma.sentEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sentEmailWithIdOnly = await prisma.sentEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SentEmailFindManyArgs>(args?: SelectSubset<T, SentEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SentEmail.
     * @param {SentEmailCreateArgs} args - Arguments to create a SentEmail.
     * @example
     * // Create one SentEmail
     * const SentEmail = await prisma.sentEmail.create({
     *   data: {
     *     // ... data to create a SentEmail
     *   }
     * })
     * 
     */
    create<T extends SentEmailCreateArgs>(args: SelectSubset<T, SentEmailCreateArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SentEmails.
     * @param {SentEmailCreateManyArgs} args - Arguments to create many SentEmails.
     * @example
     * // Create many SentEmails
     * const sentEmail = await prisma.sentEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SentEmailCreateManyArgs>(args?: SelectSubset<T, SentEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SentEmails and returns the data saved in the database.
     * @param {SentEmailCreateManyAndReturnArgs} args - Arguments to create many SentEmails.
     * @example
     * // Create many SentEmails
     * const sentEmail = await prisma.sentEmail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SentEmails and only return the `id`
     * const sentEmailWithIdOnly = await prisma.sentEmail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SentEmailCreateManyAndReturnArgs>(args?: SelectSubset<T, SentEmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SentEmail.
     * @param {SentEmailDeleteArgs} args - Arguments to delete one SentEmail.
     * @example
     * // Delete one SentEmail
     * const SentEmail = await prisma.sentEmail.delete({
     *   where: {
     *     // ... filter to delete one SentEmail
     *   }
     * })
     * 
     */
    delete<T extends SentEmailDeleteArgs>(args: SelectSubset<T, SentEmailDeleteArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SentEmail.
     * @param {SentEmailUpdateArgs} args - Arguments to update one SentEmail.
     * @example
     * // Update one SentEmail
     * const sentEmail = await prisma.sentEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SentEmailUpdateArgs>(args: SelectSubset<T, SentEmailUpdateArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SentEmails.
     * @param {SentEmailDeleteManyArgs} args - Arguments to filter SentEmails to delete.
     * @example
     * // Delete a few SentEmails
     * const { count } = await prisma.sentEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SentEmailDeleteManyArgs>(args?: SelectSubset<T, SentEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SentEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SentEmails
     * const sentEmail = await prisma.sentEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SentEmailUpdateManyArgs>(args: SelectSubset<T, SentEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SentEmail.
     * @param {SentEmailUpsertArgs} args - Arguments to update or create a SentEmail.
     * @example
     * // Update or create a SentEmail
     * const sentEmail = await prisma.sentEmail.upsert({
     *   create: {
     *     // ... data to create a SentEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SentEmail we want to update
     *   }
     * })
     */
    upsert<T extends SentEmailUpsertArgs>(args: SelectSubset<T, SentEmailUpsertArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SentEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailCountArgs} args - Arguments to filter SentEmails to count.
     * @example
     * // Count the number of SentEmails
     * const count = await prisma.sentEmail.count({
     *   where: {
     *     // ... the filter for the SentEmails we want to count
     *   }
     * })
    **/
    count<T extends SentEmailCountArgs>(
      args?: Subset<T, SentEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SentEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SentEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SentEmailAggregateArgs>(args: Subset<T, SentEmailAggregateArgs>): Prisma.PrismaPromise<GetSentEmailAggregateType<T>>

    /**
     * Group by SentEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SentEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SentEmailGroupByArgs['orderBy'] }
        : { orderBy?: SentEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SentEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSentEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SentEmail model
   */
  readonly fields: SentEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SentEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SentEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends SentEmail$templateArgs<ExtArgs> = {}>(args?: Subset<T, SentEmail$templateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    campaign<T extends SentEmail$campaignArgs<ExtArgs> = {}>(args?: Subset<T, SentEmail$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    emailJob<T extends SentEmail$emailJobArgs<ExtArgs> = {}>(args?: Subset<T, SentEmail$emailJobArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscriber<T extends SentEmail$subscriberArgs<ExtArgs> = {}>(args?: Subset<T, SentEmail$subscriberArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tracking<T extends SentEmail$trackingArgs<ExtArgs> = {}>(args?: Subset<T, SentEmail$trackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SentEmail model
   */ 
  interface SentEmailFieldRefs {
    readonly id: FieldRef<"SentEmail", 'String'>
    readonly templateId: FieldRef<"SentEmail", 'String'>
    readonly campaignId: FieldRef<"SentEmail", 'String'>
    readonly recipient: FieldRef<"SentEmail", 'String'>
    readonly subject: FieldRef<"SentEmail", 'String'>
    readonly content: FieldRef<"SentEmail", 'String'>
    readonly status: FieldRef<"SentEmail", 'EmailStatus'>
    readonly sentAt: FieldRef<"SentEmail", 'DateTime'>
    readonly openedAt: FieldRef<"SentEmail", 'DateTime'>
    readonly clickedAt: FieldRef<"SentEmail", 'DateTime'>
    readonly teamId: FieldRef<"SentEmail", 'String'>
    readonly error: FieldRef<"SentEmail", 'String'>
    readonly metadata: FieldRef<"SentEmail", 'Json'>
    readonly jobId: FieldRef<"SentEmail", 'String'>
    readonly subscriberId: FieldRef<"SentEmail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SentEmail findUnique
   */
  export type SentEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail findUniqueOrThrow
   */
  export type SentEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail findFirst
   */
  export type SentEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SentEmails.
     */
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * SentEmail findFirstOrThrow
   */
  export type SentEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SentEmails.
     */
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * SentEmail findMany
   */
  export type SentEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmails to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * SentEmail create
   */
  export type SentEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a SentEmail.
     */
    data: XOR<SentEmailCreateInput, SentEmailUncheckedCreateInput>
  }

  /**
   * SentEmail createMany
   */
  export type SentEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SentEmails.
     */
    data: SentEmailCreateManyInput | SentEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SentEmail createManyAndReturn
   */
  export type SentEmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SentEmails.
     */
    data: SentEmailCreateManyInput | SentEmailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SentEmail update
   */
  export type SentEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a SentEmail.
     */
    data: XOR<SentEmailUpdateInput, SentEmailUncheckedUpdateInput>
    /**
     * Choose, which SentEmail to update.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail updateMany
   */
  export type SentEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SentEmails.
     */
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyInput>
    /**
     * Filter which SentEmails to update
     */
    where?: SentEmailWhereInput
  }

  /**
   * SentEmail upsert
   */
  export type SentEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the SentEmail to update in case it exists.
     */
    where: SentEmailWhereUniqueInput
    /**
     * In case the SentEmail found by the `where` argument doesn't exist, create a new SentEmail with this data.
     */
    create: XOR<SentEmailCreateInput, SentEmailUncheckedCreateInput>
    /**
     * In case the SentEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SentEmailUpdateInput, SentEmailUncheckedUpdateInput>
  }

  /**
   * SentEmail delete
   */
  export type SentEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter which SentEmail to delete.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail deleteMany
   */
  export type SentEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SentEmails to delete
     */
    where?: SentEmailWhereInput
  }

  /**
   * SentEmail.template
   */
  export type SentEmail$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * SentEmail.campaign
   */
  export type SentEmail$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * SentEmail.emailJob
   */
  export type SentEmail$emailJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    where?: EmailJobWhereInput
  }

  /**
   * SentEmail.subscriber
   */
  export type SentEmail$subscriberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    where?: SubscriberWhereInput
  }

  /**
   * SentEmail.tracking
   */
  export type SentEmail$trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    where?: EmailTrackingWhereInput
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    cursor?: EmailTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTrackingScalarFieldEnum | EmailTrackingScalarFieldEnum[]
  }

  /**
   * SentEmail without action
   */
  export type SentEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
  }


  /**
   * Model EmailTracking
   */

  export type AggregateEmailTracking = {
    _count: EmailTrackingCountAggregateOutputType | null
    _min: EmailTrackingMinAggregateOutputType | null
    _max: EmailTrackingMaxAggregateOutputType | null
  }

  export type EmailTrackingMinAggregateOutputType = {
    id: string | null
    sentEmailId: string | null
    type: $Enums.TrackingType | null
    createdAt: Date | null
  }

  export type EmailTrackingMaxAggregateOutputType = {
    id: string | null
    sentEmailId: string | null
    type: $Enums.TrackingType | null
    createdAt: Date | null
  }

  export type EmailTrackingCountAggregateOutputType = {
    id: number
    sentEmailId: number
    type: number
    data: number
    createdAt: number
    _all: number
  }


  export type EmailTrackingMinAggregateInputType = {
    id?: true
    sentEmailId?: true
    type?: true
    createdAt?: true
  }

  export type EmailTrackingMaxAggregateInputType = {
    id?: true
    sentEmailId?: true
    type?: true
    createdAt?: true
  }

  export type EmailTrackingCountAggregateInputType = {
    id?: true
    sentEmailId?: true
    type?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type EmailTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTracking to aggregate.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTrackings
    **/
    _count?: true | EmailTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTrackingMaxAggregateInputType
  }

  export type GetEmailTrackingAggregateType<T extends EmailTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTracking[P]>
      : GetScalarType<T[P], AggregateEmailTracking[P]>
  }




  export type EmailTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTrackingWhereInput
    orderBy?: EmailTrackingOrderByWithAggregationInput | EmailTrackingOrderByWithAggregationInput[]
    by: EmailTrackingScalarFieldEnum[] | EmailTrackingScalarFieldEnum
    having?: EmailTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTrackingCountAggregateInputType | true
    _min?: EmailTrackingMinAggregateInputType
    _max?: EmailTrackingMaxAggregateInputType
  }

  export type EmailTrackingGroupByOutputType = {
    id: string
    sentEmailId: string
    type: $Enums.TrackingType
    data: JsonValue | null
    createdAt: Date
    _count: EmailTrackingCountAggregateOutputType | null
    _min: EmailTrackingMinAggregateOutputType | null
    _max: EmailTrackingMaxAggregateOutputType | null
  }

  type GetEmailTrackingGroupByPayload<T extends EmailTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTrackingGroupByOutputType[P]>
        }
      >
    >


  export type EmailTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sentEmailId?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    sentEmail?: boolean | SentEmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTracking"]>

  export type EmailTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sentEmailId?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    sentEmail?: boolean | SentEmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTracking"]>

  export type EmailTrackingSelectScalar = {
    id?: boolean
    sentEmailId?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type EmailTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentEmail?: boolean | SentEmailDefaultArgs<ExtArgs>
  }
  export type EmailTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentEmail?: boolean | SentEmailDefaultArgs<ExtArgs>
  }

  export type $EmailTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTracking"
    objects: {
      sentEmail: Prisma.$SentEmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sentEmailId: string
      type: $Enums.TrackingType
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["emailTracking"]>
    composites: {}
  }

  type EmailTrackingGetPayload<S extends boolean | null | undefined | EmailTrackingDefaultArgs> = $Result.GetResult<Prisma.$EmailTrackingPayload, S>

  type EmailTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTrackingCountAggregateInputType | true
    }

  export interface EmailTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTracking'], meta: { name: 'EmailTracking' } }
    /**
     * Find zero or one EmailTracking that matches the filter.
     * @param {EmailTrackingFindUniqueArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTrackingFindUniqueArgs>(args: SelectSubset<T, EmailTrackingFindUniqueArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailTrackingFindUniqueOrThrowArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingFindFirstArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTrackingFindFirstArgs>(args?: SelectSubset<T, EmailTrackingFindFirstArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingFindFirstOrThrowArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTrackings
     * const emailTrackings = await prisma.emailTracking.findMany()
     * 
     * // Get first 10 EmailTrackings
     * const emailTrackings = await prisma.emailTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTrackingWithIdOnly = await prisma.emailTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTrackingFindManyArgs>(args?: SelectSubset<T, EmailTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailTracking.
     * @param {EmailTrackingCreateArgs} args - Arguments to create a EmailTracking.
     * @example
     * // Create one EmailTracking
     * const EmailTracking = await prisma.emailTracking.create({
     *   data: {
     *     // ... data to create a EmailTracking
     *   }
     * })
     * 
     */
    create<T extends EmailTrackingCreateArgs>(args: SelectSubset<T, EmailTrackingCreateArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailTrackings.
     * @param {EmailTrackingCreateManyArgs} args - Arguments to create many EmailTrackings.
     * @example
     * // Create many EmailTrackings
     * const emailTracking = await prisma.emailTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTrackingCreateManyArgs>(args?: SelectSubset<T, EmailTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTrackings and returns the data saved in the database.
     * @param {EmailTrackingCreateManyAndReturnArgs} args - Arguments to create many EmailTrackings.
     * @example
     * // Create many EmailTrackings
     * const emailTracking = await prisma.emailTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTrackings and only return the `id`
     * const emailTrackingWithIdOnly = await prisma.emailTracking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailTracking.
     * @param {EmailTrackingDeleteArgs} args - Arguments to delete one EmailTracking.
     * @example
     * // Delete one EmailTracking
     * const EmailTracking = await prisma.emailTracking.delete({
     *   where: {
     *     // ... filter to delete one EmailTracking
     *   }
     * })
     * 
     */
    delete<T extends EmailTrackingDeleteArgs>(args: SelectSubset<T, EmailTrackingDeleteArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailTracking.
     * @param {EmailTrackingUpdateArgs} args - Arguments to update one EmailTracking.
     * @example
     * // Update one EmailTracking
     * const emailTracking = await prisma.emailTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTrackingUpdateArgs>(args: SelectSubset<T, EmailTrackingUpdateArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailTrackings.
     * @param {EmailTrackingDeleteManyArgs} args - Arguments to filter EmailTrackings to delete.
     * @example
     * // Delete a few EmailTrackings
     * const { count } = await prisma.emailTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTrackingDeleteManyArgs>(args?: SelectSubset<T, EmailTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTrackings
     * const emailTracking = await prisma.emailTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTrackingUpdateManyArgs>(args: SelectSubset<T, EmailTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTracking.
     * @param {EmailTrackingUpsertArgs} args - Arguments to update or create a EmailTracking.
     * @example
     * // Update or create a EmailTracking
     * const emailTracking = await prisma.emailTracking.upsert({
     *   create: {
     *     // ... data to create a EmailTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTracking we want to update
     *   }
     * })
     */
    upsert<T extends EmailTrackingUpsertArgs>(args: SelectSubset<T, EmailTrackingUpsertArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingCountArgs} args - Arguments to filter EmailTrackings to count.
     * @example
     * // Count the number of EmailTrackings
     * const count = await prisma.emailTracking.count({
     *   where: {
     *     // ... the filter for the EmailTrackings we want to count
     *   }
     * })
    **/
    count<T extends EmailTrackingCountArgs>(
      args?: Subset<T, EmailTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTrackingAggregateArgs>(args: Subset<T, EmailTrackingAggregateArgs>): Prisma.PrismaPromise<GetEmailTrackingAggregateType<T>>

    /**
     * Group by EmailTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTrackingGroupByArgs['orderBy'] }
        : { orderBy?: EmailTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTracking model
   */
  readonly fields: EmailTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sentEmail<T extends SentEmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SentEmailDefaultArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTracking model
   */ 
  interface EmailTrackingFieldRefs {
    readonly id: FieldRef<"EmailTracking", 'String'>
    readonly sentEmailId: FieldRef<"EmailTracking", 'String'>
    readonly type: FieldRef<"EmailTracking", 'TrackingType'>
    readonly data: FieldRef<"EmailTracking", 'Json'>
    readonly createdAt: FieldRef<"EmailTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTracking findUnique
   */
  export type EmailTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where: EmailTrackingWhereUniqueInput
  }

  /**
   * EmailTracking findUniqueOrThrow
   */
  export type EmailTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where: EmailTrackingWhereUniqueInput
  }

  /**
   * EmailTracking findFirst
   */
  export type EmailTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTrackings.
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTrackings.
     */
    distinct?: EmailTrackingScalarFieldEnum | EmailTrackingScalarFieldEnum[]
  }

  /**
   * EmailTracking findFirstOrThrow
   */
  export type EmailTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTrackings.
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTrackings.
     */
    distinct?: EmailTrackingScalarFieldEnum | EmailTrackingScalarFieldEnum[]
  }

  /**
   * EmailTracking findMany
   */
  export type EmailTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTrackings to fetch.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTrackings.
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    distinct?: EmailTrackingScalarFieldEnum | EmailTrackingScalarFieldEnum[]
  }

  /**
   * EmailTracking create
   */
  export type EmailTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTracking.
     */
    data: XOR<EmailTrackingCreateInput, EmailTrackingUncheckedCreateInput>
  }

  /**
   * EmailTracking createMany
   */
  export type EmailTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTrackings.
     */
    data: EmailTrackingCreateManyInput | EmailTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTracking createManyAndReturn
   */
  export type EmailTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailTrackings.
     */
    data: EmailTrackingCreateManyInput | EmailTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTracking update
   */
  export type EmailTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTracking.
     */
    data: XOR<EmailTrackingUpdateInput, EmailTrackingUncheckedUpdateInput>
    /**
     * Choose, which EmailTracking to update.
     */
    where: EmailTrackingWhereUniqueInput
  }

  /**
   * EmailTracking updateMany
   */
  export type EmailTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTrackings.
     */
    data: XOR<EmailTrackingUpdateManyMutationInput, EmailTrackingUncheckedUpdateManyInput>
    /**
     * Filter which EmailTrackings to update
     */
    where?: EmailTrackingWhereInput
  }

  /**
   * EmailTracking upsert
   */
  export type EmailTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTracking to update in case it exists.
     */
    where: EmailTrackingWhereUniqueInput
    /**
     * In case the EmailTracking found by the `where` argument doesn't exist, create a new EmailTracking with this data.
     */
    create: XOR<EmailTrackingCreateInput, EmailTrackingUncheckedCreateInput>
    /**
     * In case the EmailTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTrackingUpdateInput, EmailTrackingUncheckedUpdateInput>
  }

  /**
   * EmailTracking delete
   */
  export type EmailTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter which EmailTracking to delete.
     */
    where: EmailTrackingWhereUniqueInput
  }

  /**
   * EmailTracking deleteMany
   */
  export type EmailTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTrackings to delete
     */
    where?: EmailTrackingWhereInput
  }

  /**
   * EmailTracking without action
   */
  export type EmailTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTrackingInclude<ExtArgs> | null
  }


  /**
   * Model EmailJob
   */

  export type AggregateEmailJob = {
    _count: EmailJobCountAggregateOutputType | null
    _avg: EmailJobAvgAggregateOutputType | null
    _sum: EmailJobSumAggregateOutputType | null
    _min: EmailJobMinAggregateOutputType | null
    _max: EmailJobMaxAggregateOutputType | null
  }

  export type EmailJobAvgAggregateOutputType = {
    totalEmails: number | null
    processedEmails: number | null
  }

  export type EmailJobSumAggregateOutputType = {
    totalEmails: number | null
    processedEmails: number | null
  }

  export type EmailJobMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    status: $Enums.JobStatus | null
    totalEmails: number | null
    processedEmails: number | null
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailJobMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    status: $Enums.JobStatus | null
    totalEmails: number | null
    processedEmails: number | null
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailJobCountAggregateOutputType = {
    id: number
    campaignId: number
    status: number
    totalEmails: number
    processedEmails: number
    startedAt: number
    completedAt: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailJobAvgAggregateInputType = {
    totalEmails?: true
    processedEmails?: true
  }

  export type EmailJobSumAggregateInputType = {
    totalEmails?: true
    processedEmails?: true
  }

  export type EmailJobMinAggregateInputType = {
    id?: true
    campaignId?: true
    status?: true
    totalEmails?: true
    processedEmails?: true
    startedAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailJobMaxAggregateInputType = {
    id?: true
    campaignId?: true
    status?: true
    totalEmails?: true
    processedEmails?: true
    startedAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailJobCountAggregateInputType = {
    id?: true
    campaignId?: true
    status?: true
    totalEmails?: true
    processedEmails?: true
    startedAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailJob to aggregate.
     */
    where?: EmailJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobs to fetch.
     */
    orderBy?: EmailJobOrderByWithRelationInput | EmailJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailJobs
    **/
    _count?: true | EmailJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailJobMaxAggregateInputType
  }

  export type GetEmailJobAggregateType<T extends EmailJobAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailJob[P]>
      : GetScalarType<T[P], AggregateEmailJob[P]>
  }




  export type EmailJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailJobWhereInput
    orderBy?: EmailJobOrderByWithAggregationInput | EmailJobOrderByWithAggregationInput[]
    by: EmailJobScalarFieldEnum[] | EmailJobScalarFieldEnum
    having?: EmailJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailJobCountAggregateInputType | true
    _avg?: EmailJobAvgAggregateInputType
    _sum?: EmailJobSumAggregateInputType
    _min?: EmailJobMinAggregateInputType
    _max?: EmailJobMaxAggregateInputType
  }

  export type EmailJobGroupByOutputType = {
    id: string
    campaignId: string | null
    status: $Enums.JobStatus
    totalEmails: number
    processedEmails: number
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailJobCountAggregateOutputType | null
    _avg: EmailJobAvgAggregateOutputType | null
    _sum: EmailJobSumAggregateOutputType | null
    _min: EmailJobMinAggregateOutputType | null
    _max: EmailJobMaxAggregateOutputType | null
  }

  type GetEmailJobGroupByPayload<T extends EmailJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailJobGroupByOutputType[P]>
            : GetScalarType<T[P], EmailJobGroupByOutputType[P]>
        }
      >
    >


  export type EmailJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    status?: boolean
    totalEmails?: boolean
    processedEmails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | EmailJob$campaignArgs<ExtArgs>
    sentEmails?: boolean | EmailJob$sentEmailsArgs<ExtArgs>
    logs?: boolean | EmailJob$logsArgs<ExtArgs>
    _count?: boolean | EmailJobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailJob"]>

  export type EmailJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    status?: boolean
    totalEmails?: boolean
    processedEmails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | EmailJob$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["emailJob"]>

  export type EmailJobSelectScalar = {
    id?: boolean
    campaignId?: boolean
    status?: boolean
    totalEmails?: boolean
    processedEmails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | EmailJob$campaignArgs<ExtArgs>
    sentEmails?: boolean | EmailJob$sentEmailsArgs<ExtArgs>
    logs?: boolean | EmailJob$logsArgs<ExtArgs>
    _count?: boolean | EmailJobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | EmailJob$campaignArgs<ExtArgs>
  }

  export type $EmailJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailJob"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
      sentEmails: Prisma.$SentEmailPayload<ExtArgs>[]
      logs: Prisma.$EmailJobLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string | null
      status: $Enums.JobStatus
      totalEmails: number
      processedEmails: number
      startedAt: Date | null
      completedAt: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailJob"]>
    composites: {}
  }

  type EmailJobGetPayload<S extends boolean | null | undefined | EmailJobDefaultArgs> = $Result.GetResult<Prisma.$EmailJobPayload, S>

  type EmailJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailJobCountAggregateInputType | true
    }

  export interface EmailJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailJob'], meta: { name: 'EmailJob' } }
    /**
     * Find zero or one EmailJob that matches the filter.
     * @param {EmailJobFindUniqueArgs} args - Arguments to find a EmailJob
     * @example
     * // Get one EmailJob
     * const emailJob = await prisma.emailJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailJobFindUniqueArgs>(args: SelectSubset<T, EmailJobFindUniqueArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailJobFindUniqueOrThrowArgs} args - Arguments to find a EmailJob
     * @example
     * // Get one EmailJob
     * const emailJob = await prisma.emailJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailJobFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobFindFirstArgs} args - Arguments to find a EmailJob
     * @example
     * // Get one EmailJob
     * const emailJob = await prisma.emailJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailJobFindFirstArgs>(args?: SelectSubset<T, EmailJobFindFirstArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobFindFirstOrThrowArgs} args - Arguments to find a EmailJob
     * @example
     * // Get one EmailJob
     * const emailJob = await prisma.emailJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailJobFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailJobs
     * const emailJobs = await prisma.emailJob.findMany()
     * 
     * // Get first 10 EmailJobs
     * const emailJobs = await prisma.emailJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailJobWithIdOnly = await prisma.emailJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailJobFindManyArgs>(args?: SelectSubset<T, EmailJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailJob.
     * @param {EmailJobCreateArgs} args - Arguments to create a EmailJob.
     * @example
     * // Create one EmailJob
     * const EmailJob = await prisma.emailJob.create({
     *   data: {
     *     // ... data to create a EmailJob
     *   }
     * })
     * 
     */
    create<T extends EmailJobCreateArgs>(args: SelectSubset<T, EmailJobCreateArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailJobs.
     * @param {EmailJobCreateManyArgs} args - Arguments to create many EmailJobs.
     * @example
     * // Create many EmailJobs
     * const emailJob = await prisma.emailJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailJobCreateManyArgs>(args?: SelectSubset<T, EmailJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailJobs and returns the data saved in the database.
     * @param {EmailJobCreateManyAndReturnArgs} args - Arguments to create many EmailJobs.
     * @example
     * // Create many EmailJobs
     * const emailJob = await prisma.emailJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailJobs and only return the `id`
     * const emailJobWithIdOnly = await prisma.emailJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailJobCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailJob.
     * @param {EmailJobDeleteArgs} args - Arguments to delete one EmailJob.
     * @example
     * // Delete one EmailJob
     * const EmailJob = await prisma.emailJob.delete({
     *   where: {
     *     // ... filter to delete one EmailJob
     *   }
     * })
     * 
     */
    delete<T extends EmailJobDeleteArgs>(args: SelectSubset<T, EmailJobDeleteArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailJob.
     * @param {EmailJobUpdateArgs} args - Arguments to update one EmailJob.
     * @example
     * // Update one EmailJob
     * const emailJob = await prisma.emailJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailJobUpdateArgs>(args: SelectSubset<T, EmailJobUpdateArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailJobs.
     * @param {EmailJobDeleteManyArgs} args - Arguments to filter EmailJobs to delete.
     * @example
     * // Delete a few EmailJobs
     * const { count } = await prisma.emailJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailJobDeleteManyArgs>(args?: SelectSubset<T, EmailJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailJobs
     * const emailJob = await prisma.emailJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailJobUpdateManyArgs>(args: SelectSubset<T, EmailJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailJob.
     * @param {EmailJobUpsertArgs} args - Arguments to update or create a EmailJob.
     * @example
     * // Update or create a EmailJob
     * const emailJob = await prisma.emailJob.upsert({
     *   create: {
     *     // ... data to create a EmailJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailJob we want to update
     *   }
     * })
     */
    upsert<T extends EmailJobUpsertArgs>(args: SelectSubset<T, EmailJobUpsertArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobCountArgs} args - Arguments to filter EmailJobs to count.
     * @example
     * // Count the number of EmailJobs
     * const count = await prisma.emailJob.count({
     *   where: {
     *     // ... the filter for the EmailJobs we want to count
     *   }
     * })
    **/
    count<T extends EmailJobCountArgs>(
      args?: Subset<T, EmailJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailJobAggregateArgs>(args: Subset<T, EmailJobAggregateArgs>): Prisma.PrismaPromise<GetEmailJobAggregateType<T>>

    /**
     * Group by EmailJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailJobGroupByArgs['orderBy'] }
        : { orderBy?: EmailJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailJob model
   */
  readonly fields: EmailJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends EmailJob$campaignArgs<ExtArgs> = {}>(args?: Subset<T, EmailJob$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sentEmails<T extends EmailJob$sentEmailsArgs<ExtArgs> = {}>(args?: Subset<T, EmailJob$sentEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends EmailJob$logsArgs<ExtArgs> = {}>(args?: Subset<T, EmailJob$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailJob model
   */ 
  interface EmailJobFieldRefs {
    readonly id: FieldRef<"EmailJob", 'String'>
    readonly campaignId: FieldRef<"EmailJob", 'String'>
    readonly status: FieldRef<"EmailJob", 'JobStatus'>
    readonly totalEmails: FieldRef<"EmailJob", 'Int'>
    readonly processedEmails: FieldRef<"EmailJob", 'Int'>
    readonly startedAt: FieldRef<"EmailJob", 'DateTime'>
    readonly completedAt: FieldRef<"EmailJob", 'DateTime'>
    readonly error: FieldRef<"EmailJob", 'String'>
    readonly createdAt: FieldRef<"EmailJob", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailJob findUnique
   */
  export type EmailJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * Filter, which EmailJob to fetch.
     */
    where: EmailJobWhereUniqueInput
  }

  /**
   * EmailJob findUniqueOrThrow
   */
  export type EmailJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * Filter, which EmailJob to fetch.
     */
    where: EmailJobWhereUniqueInput
  }

  /**
   * EmailJob findFirst
   */
  export type EmailJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * Filter, which EmailJob to fetch.
     */
    where?: EmailJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobs to fetch.
     */
    orderBy?: EmailJobOrderByWithRelationInput | EmailJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailJobs.
     */
    cursor?: EmailJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailJobs.
     */
    distinct?: EmailJobScalarFieldEnum | EmailJobScalarFieldEnum[]
  }

  /**
   * EmailJob findFirstOrThrow
   */
  export type EmailJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * Filter, which EmailJob to fetch.
     */
    where?: EmailJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobs to fetch.
     */
    orderBy?: EmailJobOrderByWithRelationInput | EmailJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailJobs.
     */
    cursor?: EmailJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailJobs.
     */
    distinct?: EmailJobScalarFieldEnum | EmailJobScalarFieldEnum[]
  }

  /**
   * EmailJob findMany
   */
  export type EmailJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * Filter, which EmailJobs to fetch.
     */
    where?: EmailJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobs to fetch.
     */
    orderBy?: EmailJobOrderByWithRelationInput | EmailJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailJobs.
     */
    cursor?: EmailJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobs.
     */
    skip?: number
    distinct?: EmailJobScalarFieldEnum | EmailJobScalarFieldEnum[]
  }

  /**
   * EmailJob create
   */
  export type EmailJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailJob.
     */
    data: XOR<EmailJobCreateInput, EmailJobUncheckedCreateInput>
  }

  /**
   * EmailJob createMany
   */
  export type EmailJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailJobs.
     */
    data: EmailJobCreateManyInput | EmailJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailJob createManyAndReturn
   */
  export type EmailJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailJobs.
     */
    data: EmailJobCreateManyInput | EmailJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailJob update
   */
  export type EmailJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailJob.
     */
    data: XOR<EmailJobUpdateInput, EmailJobUncheckedUpdateInput>
    /**
     * Choose, which EmailJob to update.
     */
    where: EmailJobWhereUniqueInput
  }

  /**
   * EmailJob updateMany
   */
  export type EmailJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailJobs.
     */
    data: XOR<EmailJobUpdateManyMutationInput, EmailJobUncheckedUpdateManyInput>
    /**
     * Filter which EmailJobs to update
     */
    where?: EmailJobWhereInput
  }

  /**
   * EmailJob upsert
   */
  export type EmailJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailJob to update in case it exists.
     */
    where: EmailJobWhereUniqueInput
    /**
     * In case the EmailJob found by the `where` argument doesn't exist, create a new EmailJob with this data.
     */
    create: XOR<EmailJobCreateInput, EmailJobUncheckedCreateInput>
    /**
     * In case the EmailJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailJobUpdateInput, EmailJobUncheckedUpdateInput>
  }

  /**
   * EmailJob delete
   */
  export type EmailJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
    /**
     * Filter which EmailJob to delete.
     */
    where: EmailJobWhereUniqueInput
  }

  /**
   * EmailJob deleteMany
   */
  export type EmailJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailJobs to delete
     */
    where?: EmailJobWhereInput
  }

  /**
   * EmailJob.campaign
   */
  export type EmailJob$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * EmailJob.sentEmails
   */
  export type EmailJob$sentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    cursor?: SentEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * EmailJob.logs
   */
  export type EmailJob$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    where?: EmailJobLogWhereInput
    orderBy?: EmailJobLogOrderByWithRelationInput | EmailJobLogOrderByWithRelationInput[]
    cursor?: EmailJobLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailJobLogScalarFieldEnum | EmailJobLogScalarFieldEnum[]
  }

  /**
   * EmailJob without action
   */
  export type EmailJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJob
     */
    select?: EmailJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobInclude<ExtArgs> | null
  }


  /**
   * Model EmailJobLog
   */

  export type AggregateEmailJobLog = {
    _count: EmailJobLogCountAggregateOutputType | null
    _min: EmailJobLogMinAggregateOutputType | null
    _max: EmailJobLogMaxAggregateOutputType | null
  }

  export type EmailJobLogMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    createdAt: Date | null
  }

  export type EmailJobLogMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    level: $Enums.LogLevel | null
    message: string | null
    createdAt: Date | null
  }

  export type EmailJobLogCountAggregateOutputType = {
    id: number
    jobId: number
    level: number
    message: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type EmailJobLogMinAggregateInputType = {
    id?: true
    jobId?: true
    level?: true
    message?: true
    createdAt?: true
  }

  export type EmailJobLogMaxAggregateInputType = {
    id?: true
    jobId?: true
    level?: true
    message?: true
    createdAt?: true
  }

  export type EmailJobLogCountAggregateInputType = {
    id?: true
    jobId?: true
    level?: true
    message?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type EmailJobLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailJobLog to aggregate.
     */
    where?: EmailJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobLogs to fetch.
     */
    orderBy?: EmailJobLogOrderByWithRelationInput | EmailJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailJobLogs
    **/
    _count?: true | EmailJobLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailJobLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailJobLogMaxAggregateInputType
  }

  export type GetEmailJobLogAggregateType<T extends EmailJobLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailJobLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailJobLog[P]>
      : GetScalarType<T[P], AggregateEmailJobLog[P]>
  }




  export type EmailJobLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailJobLogWhereInput
    orderBy?: EmailJobLogOrderByWithAggregationInput | EmailJobLogOrderByWithAggregationInput[]
    by: EmailJobLogScalarFieldEnum[] | EmailJobLogScalarFieldEnum
    having?: EmailJobLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailJobLogCountAggregateInputType | true
    _min?: EmailJobLogMinAggregateInputType
    _max?: EmailJobLogMaxAggregateInputType
  }

  export type EmailJobLogGroupByOutputType = {
    id: string
    jobId: string
    level: $Enums.LogLevel
    message: string
    metadata: JsonValue | null
    createdAt: Date
    _count: EmailJobLogCountAggregateOutputType | null
    _min: EmailJobLogMinAggregateOutputType | null
    _max: EmailJobLogMaxAggregateOutputType | null
  }

  type GetEmailJobLogGroupByPayload<T extends EmailJobLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailJobLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailJobLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailJobLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailJobLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailJobLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    createdAt?: boolean
    emailJob?: boolean | EmailJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailJobLog"]>

  export type EmailJobLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    createdAt?: boolean
    emailJob?: boolean | EmailJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailJobLog"]>

  export type EmailJobLogSelectScalar = {
    id?: boolean
    jobId?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type EmailJobLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailJob?: boolean | EmailJobDefaultArgs<ExtArgs>
  }
  export type EmailJobLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailJob?: boolean | EmailJobDefaultArgs<ExtArgs>
  }

  export type $EmailJobLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailJobLog"
    objects: {
      emailJob: Prisma.$EmailJobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      level: $Enums.LogLevel
      message: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["emailJobLog"]>
    composites: {}
  }

  type EmailJobLogGetPayload<S extends boolean | null | undefined | EmailJobLogDefaultArgs> = $Result.GetResult<Prisma.$EmailJobLogPayload, S>

  type EmailJobLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailJobLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailJobLogCountAggregateInputType | true
    }

  export interface EmailJobLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailJobLog'], meta: { name: 'EmailJobLog' } }
    /**
     * Find zero or one EmailJobLog that matches the filter.
     * @param {EmailJobLogFindUniqueArgs} args - Arguments to find a EmailJobLog
     * @example
     * // Get one EmailJobLog
     * const emailJobLog = await prisma.emailJobLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailJobLogFindUniqueArgs>(args: SelectSubset<T, EmailJobLogFindUniqueArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailJobLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailJobLogFindUniqueOrThrowArgs} args - Arguments to find a EmailJobLog
     * @example
     * // Get one EmailJobLog
     * const emailJobLog = await prisma.emailJobLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailJobLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailJobLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailJobLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobLogFindFirstArgs} args - Arguments to find a EmailJobLog
     * @example
     * // Get one EmailJobLog
     * const emailJobLog = await prisma.emailJobLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailJobLogFindFirstArgs>(args?: SelectSubset<T, EmailJobLogFindFirstArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailJobLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobLogFindFirstOrThrowArgs} args - Arguments to find a EmailJobLog
     * @example
     * // Get one EmailJobLog
     * const emailJobLog = await prisma.emailJobLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailJobLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailJobLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailJobLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailJobLogs
     * const emailJobLogs = await prisma.emailJobLog.findMany()
     * 
     * // Get first 10 EmailJobLogs
     * const emailJobLogs = await prisma.emailJobLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailJobLogWithIdOnly = await prisma.emailJobLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailJobLogFindManyArgs>(args?: SelectSubset<T, EmailJobLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailJobLog.
     * @param {EmailJobLogCreateArgs} args - Arguments to create a EmailJobLog.
     * @example
     * // Create one EmailJobLog
     * const EmailJobLog = await prisma.emailJobLog.create({
     *   data: {
     *     // ... data to create a EmailJobLog
     *   }
     * })
     * 
     */
    create<T extends EmailJobLogCreateArgs>(args: SelectSubset<T, EmailJobLogCreateArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailJobLogs.
     * @param {EmailJobLogCreateManyArgs} args - Arguments to create many EmailJobLogs.
     * @example
     * // Create many EmailJobLogs
     * const emailJobLog = await prisma.emailJobLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailJobLogCreateManyArgs>(args?: SelectSubset<T, EmailJobLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailJobLogs and returns the data saved in the database.
     * @param {EmailJobLogCreateManyAndReturnArgs} args - Arguments to create many EmailJobLogs.
     * @example
     * // Create many EmailJobLogs
     * const emailJobLog = await prisma.emailJobLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailJobLogs and only return the `id`
     * const emailJobLogWithIdOnly = await prisma.emailJobLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailJobLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailJobLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailJobLog.
     * @param {EmailJobLogDeleteArgs} args - Arguments to delete one EmailJobLog.
     * @example
     * // Delete one EmailJobLog
     * const EmailJobLog = await prisma.emailJobLog.delete({
     *   where: {
     *     // ... filter to delete one EmailJobLog
     *   }
     * })
     * 
     */
    delete<T extends EmailJobLogDeleteArgs>(args: SelectSubset<T, EmailJobLogDeleteArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailJobLog.
     * @param {EmailJobLogUpdateArgs} args - Arguments to update one EmailJobLog.
     * @example
     * // Update one EmailJobLog
     * const emailJobLog = await prisma.emailJobLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailJobLogUpdateArgs>(args: SelectSubset<T, EmailJobLogUpdateArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailJobLogs.
     * @param {EmailJobLogDeleteManyArgs} args - Arguments to filter EmailJobLogs to delete.
     * @example
     * // Delete a few EmailJobLogs
     * const { count } = await prisma.emailJobLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailJobLogDeleteManyArgs>(args?: SelectSubset<T, EmailJobLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailJobLogs
     * const emailJobLog = await prisma.emailJobLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailJobLogUpdateManyArgs>(args: SelectSubset<T, EmailJobLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailJobLog.
     * @param {EmailJobLogUpsertArgs} args - Arguments to update or create a EmailJobLog.
     * @example
     * // Update or create a EmailJobLog
     * const emailJobLog = await prisma.emailJobLog.upsert({
     *   create: {
     *     // ... data to create a EmailJobLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailJobLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailJobLogUpsertArgs>(args: SelectSubset<T, EmailJobLogUpsertArgs<ExtArgs>>): Prisma__EmailJobLogClient<$Result.GetResult<Prisma.$EmailJobLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobLogCountArgs} args - Arguments to filter EmailJobLogs to count.
     * @example
     * // Count the number of EmailJobLogs
     * const count = await prisma.emailJobLog.count({
     *   where: {
     *     // ... the filter for the EmailJobLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailJobLogCountArgs>(
      args?: Subset<T, EmailJobLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailJobLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailJobLogAggregateArgs>(args: Subset<T, EmailJobLogAggregateArgs>): Prisma.PrismaPromise<GetEmailJobLogAggregateType<T>>

    /**
     * Group by EmailJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailJobLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailJobLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailJobLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailJobLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailJobLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailJobLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailJobLog model
   */
  readonly fields: EmailJobLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailJobLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailJobLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailJob<T extends EmailJobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailJobDefaultArgs<ExtArgs>>): Prisma__EmailJobClient<$Result.GetResult<Prisma.$EmailJobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailJobLog model
   */ 
  interface EmailJobLogFieldRefs {
    readonly id: FieldRef<"EmailJobLog", 'String'>
    readonly jobId: FieldRef<"EmailJobLog", 'String'>
    readonly level: FieldRef<"EmailJobLog", 'LogLevel'>
    readonly message: FieldRef<"EmailJobLog", 'String'>
    readonly metadata: FieldRef<"EmailJobLog", 'Json'>
    readonly createdAt: FieldRef<"EmailJobLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailJobLog findUnique
   */
  export type EmailJobLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailJobLog to fetch.
     */
    where: EmailJobLogWhereUniqueInput
  }

  /**
   * EmailJobLog findUniqueOrThrow
   */
  export type EmailJobLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailJobLog to fetch.
     */
    where: EmailJobLogWhereUniqueInput
  }

  /**
   * EmailJobLog findFirst
   */
  export type EmailJobLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailJobLog to fetch.
     */
    where?: EmailJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobLogs to fetch.
     */
    orderBy?: EmailJobLogOrderByWithRelationInput | EmailJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailJobLogs.
     */
    cursor?: EmailJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailJobLogs.
     */
    distinct?: EmailJobLogScalarFieldEnum | EmailJobLogScalarFieldEnum[]
  }

  /**
   * EmailJobLog findFirstOrThrow
   */
  export type EmailJobLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailJobLog to fetch.
     */
    where?: EmailJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobLogs to fetch.
     */
    orderBy?: EmailJobLogOrderByWithRelationInput | EmailJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailJobLogs.
     */
    cursor?: EmailJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailJobLogs.
     */
    distinct?: EmailJobLogScalarFieldEnum | EmailJobLogScalarFieldEnum[]
  }

  /**
   * EmailJobLog findMany
   */
  export type EmailJobLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailJobLogs to fetch.
     */
    where?: EmailJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailJobLogs to fetch.
     */
    orderBy?: EmailJobLogOrderByWithRelationInput | EmailJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailJobLogs.
     */
    cursor?: EmailJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailJobLogs.
     */
    skip?: number
    distinct?: EmailJobLogScalarFieldEnum | EmailJobLogScalarFieldEnum[]
  }

  /**
   * EmailJobLog create
   */
  export type EmailJobLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailJobLog.
     */
    data: XOR<EmailJobLogCreateInput, EmailJobLogUncheckedCreateInput>
  }

  /**
   * EmailJobLog createMany
   */
  export type EmailJobLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailJobLogs.
     */
    data: EmailJobLogCreateManyInput | EmailJobLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailJobLog createManyAndReturn
   */
  export type EmailJobLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailJobLogs.
     */
    data: EmailJobLogCreateManyInput | EmailJobLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailJobLog update
   */
  export type EmailJobLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailJobLog.
     */
    data: XOR<EmailJobLogUpdateInput, EmailJobLogUncheckedUpdateInput>
    /**
     * Choose, which EmailJobLog to update.
     */
    where: EmailJobLogWhereUniqueInput
  }

  /**
   * EmailJobLog updateMany
   */
  export type EmailJobLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailJobLogs.
     */
    data: XOR<EmailJobLogUpdateManyMutationInput, EmailJobLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailJobLogs to update
     */
    where?: EmailJobLogWhereInput
  }

  /**
   * EmailJobLog upsert
   */
  export type EmailJobLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailJobLog to update in case it exists.
     */
    where: EmailJobLogWhereUniqueInput
    /**
     * In case the EmailJobLog found by the `where` argument doesn't exist, create a new EmailJobLog with this data.
     */
    create: XOR<EmailJobLogCreateInput, EmailJobLogUncheckedCreateInput>
    /**
     * In case the EmailJobLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailJobLogUpdateInput, EmailJobLogUncheckedUpdateInput>
  }

  /**
   * EmailJobLog delete
   */
  export type EmailJobLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
    /**
     * Filter which EmailJobLog to delete.
     */
    where: EmailJobLogWhereUniqueInput
  }

  /**
   * EmailJobLog deleteMany
   */
  export type EmailJobLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailJobLogs to delete
     */
    where?: EmailJobLogWhereInput
  }

  /**
   * EmailJobLog without action
   */
  export type EmailJobLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailJobLog
     */
    select?: EmailJobLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailJobLogInclude<ExtArgs> | null
  }


  /**
   * Model CampaignAnalytics
   */

  export type AggregateCampaignAnalytics = {
    _count: CampaignAnalyticsCountAggregateOutputType | null
    _avg: CampaignAnalyticsAvgAggregateOutputType | null
    _sum: CampaignAnalyticsSumAggregateOutputType | null
    _min: CampaignAnalyticsMinAggregateOutputType | null
    _max: CampaignAnalyticsMaxAggregateOutputType | null
  }

  export type CampaignAnalyticsAvgAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    bounceCount: number | null
    unsubscribeCount: number | null
  }

  export type CampaignAnalyticsSumAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    bounceCount: number | null
    unsubscribeCount: number | null
  }

  export type CampaignAnalyticsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    bounceCount: number | null
    unsubscribeCount: number | null
    lastUpdated: Date | null
  }

  export type CampaignAnalyticsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    bounceCount: number | null
    unsubscribeCount: number | null
    lastUpdated: Date | null
  }

  export type CampaignAnalyticsCountAggregateOutputType = {
    id: number
    campaignId: number
    sentCount: number
    openCount: number
    clickCount: number
    bounceCount: number
    unsubscribeCount: number
    lastUpdated: number
    _all: number
  }


  export type CampaignAnalyticsAvgAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
    bounceCount?: true
    unsubscribeCount?: true
  }

  export type CampaignAnalyticsSumAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
    bounceCount?: true
    unsubscribeCount?: true
  }

  export type CampaignAnalyticsMinAggregateInputType = {
    id?: true
    campaignId?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    bounceCount?: true
    unsubscribeCount?: true
    lastUpdated?: true
  }

  export type CampaignAnalyticsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    bounceCount?: true
    unsubscribeCount?: true
    lastUpdated?: true
  }

  export type CampaignAnalyticsCountAggregateInputType = {
    id?: true
    campaignId?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    bounceCount?: true
    unsubscribeCount?: true
    lastUpdated?: true
    _all?: true
  }

  export type CampaignAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAnalytics to aggregate.
     */
    where?: CampaignAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalytics to fetch.
     */
    orderBy?: CampaignAnalyticsOrderByWithRelationInput | CampaignAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignAnalytics
    **/
    _count?: true | CampaignAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignAnalyticsMaxAggregateInputType
  }

  export type GetCampaignAnalyticsAggregateType<T extends CampaignAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignAnalytics[P]>
      : GetScalarType<T[P], AggregateCampaignAnalytics[P]>
  }




  export type CampaignAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAnalyticsWhereInput
    orderBy?: CampaignAnalyticsOrderByWithAggregationInput | CampaignAnalyticsOrderByWithAggregationInput[]
    by: CampaignAnalyticsScalarFieldEnum[] | CampaignAnalyticsScalarFieldEnum
    having?: CampaignAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignAnalyticsCountAggregateInputType | true
    _avg?: CampaignAnalyticsAvgAggregateInputType
    _sum?: CampaignAnalyticsSumAggregateInputType
    _min?: CampaignAnalyticsMinAggregateInputType
    _max?: CampaignAnalyticsMaxAggregateInputType
  }

  export type CampaignAnalyticsGroupByOutputType = {
    id: string
    campaignId: string
    sentCount: number
    openCount: number
    clickCount: number
    bounceCount: number
    unsubscribeCount: number
    lastUpdated: Date
    _count: CampaignAnalyticsCountAggregateOutputType | null
    _avg: CampaignAnalyticsAvgAggregateOutputType | null
    _sum: CampaignAnalyticsSumAggregateOutputType | null
    _min: CampaignAnalyticsMinAggregateOutputType | null
    _max: CampaignAnalyticsMaxAggregateOutputType | null
  }

  type GetCampaignAnalyticsGroupByPayload<T extends CampaignAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type CampaignAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    bounceCount?: boolean
    unsubscribeCount?: boolean
    lastUpdated?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAnalytics"]>

  export type CampaignAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    bounceCount?: boolean
    unsubscribeCount?: boolean
    lastUpdated?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAnalytics"]>

  export type CampaignAnalyticsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    bounceCount?: boolean
    unsubscribeCount?: boolean
    lastUpdated?: boolean
  }

  export type CampaignAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignAnalytics"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      sentCount: number
      openCount: number
      clickCount: number
      bounceCount: number
      unsubscribeCount: number
      lastUpdated: Date
    }, ExtArgs["result"]["campaignAnalytics"]>
    composites: {}
  }

  type CampaignAnalyticsGetPayload<S extends boolean | null | undefined | CampaignAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$CampaignAnalyticsPayload, S>

  type CampaignAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignAnalyticsCountAggregateInputType | true
    }

  export interface CampaignAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignAnalytics'], meta: { name: 'CampaignAnalytics' } }
    /**
     * Find zero or one CampaignAnalytics that matches the filter.
     * @param {CampaignAnalyticsFindUniqueArgs} args - Arguments to find a CampaignAnalytics
     * @example
     * // Get one CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignAnalyticsFindUniqueArgs>(args: SelectSubset<T, CampaignAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a CampaignAnalytics
     * @example
     * // Get one CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalyticsFindFirstArgs} args - Arguments to find a CampaignAnalytics
     * @example
     * // Get one CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignAnalyticsFindFirstArgs>(args?: SelectSubset<T, CampaignAnalyticsFindFirstArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalyticsFindFirstOrThrowArgs} args - Arguments to find a CampaignAnalytics
     * @example
     * // Get one CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.findMany()
     * 
     * // Get first 10 CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignAnalyticsWithIdOnly = await prisma.campaignAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignAnalyticsFindManyArgs>(args?: SelectSubset<T, CampaignAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignAnalytics.
     * @param {CampaignAnalyticsCreateArgs} args - Arguments to create a CampaignAnalytics.
     * @example
     * // Create one CampaignAnalytics
     * const CampaignAnalytics = await prisma.campaignAnalytics.create({
     *   data: {
     *     // ... data to create a CampaignAnalytics
     *   }
     * })
     * 
     */
    create<T extends CampaignAnalyticsCreateArgs>(args: SelectSubset<T, CampaignAnalyticsCreateArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignAnalytics.
     * @param {CampaignAnalyticsCreateManyArgs} args - Arguments to create many CampaignAnalytics.
     * @example
     * // Create many CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignAnalyticsCreateManyArgs>(args?: SelectSubset<T, CampaignAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignAnalytics and returns the data saved in the database.
     * @param {CampaignAnalyticsCreateManyAndReturnArgs} args - Arguments to create many CampaignAnalytics.
     * @example
     * // Create many CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignAnalytics and only return the `id`
     * const campaignAnalyticsWithIdOnly = await prisma.campaignAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignAnalytics.
     * @param {CampaignAnalyticsDeleteArgs} args - Arguments to delete one CampaignAnalytics.
     * @example
     * // Delete one CampaignAnalytics
     * const CampaignAnalytics = await prisma.campaignAnalytics.delete({
     *   where: {
     *     // ... filter to delete one CampaignAnalytics
     *   }
     * })
     * 
     */
    delete<T extends CampaignAnalyticsDeleteArgs>(args: SelectSubset<T, CampaignAnalyticsDeleteArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignAnalytics.
     * @param {CampaignAnalyticsUpdateArgs} args - Arguments to update one CampaignAnalytics.
     * @example
     * // Update one CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignAnalyticsUpdateArgs>(args: SelectSubset<T, CampaignAnalyticsUpdateArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignAnalytics.
     * @param {CampaignAnalyticsDeleteManyArgs} args - Arguments to filter CampaignAnalytics to delete.
     * @example
     * // Delete a few CampaignAnalytics
     * const { count } = await prisma.campaignAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignAnalyticsDeleteManyArgs>(args?: SelectSubset<T, CampaignAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignAnalyticsUpdateManyArgs>(args: SelectSubset<T, CampaignAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignAnalytics.
     * @param {CampaignAnalyticsUpsertArgs} args - Arguments to update or create a CampaignAnalytics.
     * @example
     * // Update or create a CampaignAnalytics
     * const campaignAnalytics = await prisma.campaignAnalytics.upsert({
     *   create: {
     *     // ... data to create a CampaignAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends CampaignAnalyticsUpsertArgs>(args: SelectSubset<T, CampaignAnalyticsUpsertArgs<ExtArgs>>): Prisma__CampaignAnalyticsClient<$Result.GetResult<Prisma.$CampaignAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalyticsCountArgs} args - Arguments to filter CampaignAnalytics to count.
     * @example
     * // Count the number of CampaignAnalytics
     * const count = await prisma.campaignAnalytics.count({
     *   where: {
     *     // ... the filter for the CampaignAnalytics we want to count
     *   }
     * })
    **/
    count<T extends CampaignAnalyticsCountArgs>(
      args?: Subset<T, CampaignAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAnalyticsAggregateArgs>(args: Subset<T, CampaignAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetCampaignAnalyticsAggregateType<T>>

    /**
     * Group by CampaignAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: CampaignAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignAnalytics model
   */
  readonly fields: CampaignAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignAnalytics model
   */ 
  interface CampaignAnalyticsFieldRefs {
    readonly id: FieldRef<"CampaignAnalytics", 'String'>
    readonly campaignId: FieldRef<"CampaignAnalytics", 'String'>
    readonly sentCount: FieldRef<"CampaignAnalytics", 'Int'>
    readonly openCount: FieldRef<"CampaignAnalytics", 'Int'>
    readonly clickCount: FieldRef<"CampaignAnalytics", 'Int'>
    readonly bounceCount: FieldRef<"CampaignAnalytics", 'Int'>
    readonly unsubscribeCount: FieldRef<"CampaignAnalytics", 'Int'>
    readonly lastUpdated: FieldRef<"CampaignAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignAnalytics findUnique
   */
  export type CampaignAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalytics to fetch.
     */
    where: CampaignAnalyticsWhereUniqueInput
  }

  /**
   * CampaignAnalytics findUniqueOrThrow
   */
  export type CampaignAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalytics to fetch.
     */
    where: CampaignAnalyticsWhereUniqueInput
  }

  /**
   * CampaignAnalytics findFirst
   */
  export type CampaignAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalytics to fetch.
     */
    where?: CampaignAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalytics to fetch.
     */
    orderBy?: CampaignAnalyticsOrderByWithRelationInput | CampaignAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAnalytics.
     */
    cursor?: CampaignAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAnalytics.
     */
    distinct?: CampaignAnalyticsScalarFieldEnum | CampaignAnalyticsScalarFieldEnum[]
  }

  /**
   * CampaignAnalytics findFirstOrThrow
   */
  export type CampaignAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalytics to fetch.
     */
    where?: CampaignAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalytics to fetch.
     */
    orderBy?: CampaignAnalyticsOrderByWithRelationInput | CampaignAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAnalytics.
     */
    cursor?: CampaignAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAnalytics.
     */
    distinct?: CampaignAnalyticsScalarFieldEnum | CampaignAnalyticsScalarFieldEnum[]
  }

  /**
   * CampaignAnalytics findMany
   */
  export type CampaignAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalytics to fetch.
     */
    where?: CampaignAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalytics to fetch.
     */
    orderBy?: CampaignAnalyticsOrderByWithRelationInput | CampaignAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignAnalytics.
     */
    cursor?: CampaignAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalytics.
     */
    skip?: number
    distinct?: CampaignAnalyticsScalarFieldEnum | CampaignAnalyticsScalarFieldEnum[]
  }

  /**
   * CampaignAnalytics create
   */
  export type CampaignAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignAnalytics.
     */
    data: XOR<CampaignAnalyticsCreateInput, CampaignAnalyticsUncheckedCreateInput>
  }

  /**
   * CampaignAnalytics createMany
   */
  export type CampaignAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignAnalytics.
     */
    data: CampaignAnalyticsCreateManyInput | CampaignAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignAnalytics createManyAndReturn
   */
  export type CampaignAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignAnalytics.
     */
    data: CampaignAnalyticsCreateManyInput | CampaignAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignAnalytics update
   */
  export type CampaignAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignAnalytics.
     */
    data: XOR<CampaignAnalyticsUpdateInput, CampaignAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which CampaignAnalytics to update.
     */
    where: CampaignAnalyticsWhereUniqueInput
  }

  /**
   * CampaignAnalytics updateMany
   */
  export type CampaignAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignAnalytics.
     */
    data: XOR<CampaignAnalyticsUpdateManyMutationInput, CampaignAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignAnalytics to update
     */
    where?: CampaignAnalyticsWhereInput
  }

  /**
   * CampaignAnalytics upsert
   */
  export type CampaignAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignAnalytics to update in case it exists.
     */
    where: CampaignAnalyticsWhereUniqueInput
    /**
     * In case the CampaignAnalytics found by the `where` argument doesn't exist, create a new CampaignAnalytics with this data.
     */
    create: XOR<CampaignAnalyticsCreateInput, CampaignAnalyticsUncheckedCreateInput>
    /**
     * In case the CampaignAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignAnalyticsUpdateInput, CampaignAnalyticsUncheckedUpdateInput>
  }

  /**
   * CampaignAnalytics delete
   */
  export type CampaignAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which CampaignAnalytics to delete.
     */
    where: CampaignAnalyticsWhereUniqueInput
  }

  /**
   * CampaignAnalytics deleteMany
   */
  export type CampaignAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAnalytics to delete
     */
    where?: CampaignAnalyticsWhereInput
  }

  /**
   * CampaignAnalytics without action
   */
  export type CampaignAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalytics
     */
    select?: CampaignAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model EmailCategory
   */

  export type AggregateEmailCategory = {
    _count: EmailCategoryCountAggregateOutputType | null
    _min: EmailCategoryMinAggregateOutputType | null
    _max: EmailCategoryMaxAggregateOutputType | null
  }

  export type EmailCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCategory to aggregate.
     */
    where?: EmailCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCategories to fetch.
     */
    orderBy?: EmailCategoryOrderByWithRelationInput | EmailCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailCategories
    **/
    _count?: true | EmailCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailCategoryMaxAggregateInputType
  }

  export type GetEmailCategoryAggregateType<T extends EmailCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailCategory[P]>
      : GetScalarType<T[P], AggregateEmailCategory[P]>
  }




  export type EmailCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCategoryWhereInput
    orderBy?: EmailCategoryOrderByWithAggregationInput | EmailCategoryOrderByWithAggregationInput[]
    by: EmailCategoryScalarFieldEnum[] | EmailCategoryScalarFieldEnum
    having?: EmailCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCategoryCountAggregateInputType | true
    _min?: EmailCategoryMinAggregateInputType
    _max?: EmailCategoryMaxAggregateInputType
  }

  export type EmailCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailCategoryCountAggregateOutputType | null
    _min: EmailCategoryMinAggregateOutputType | null
    _max: EmailCategoryMaxAggregateOutputType | null
  }

  type GetEmailCategoryGroupByPayload<T extends EmailCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], EmailCategoryGroupByOutputType[P]>
        }
      >
    >


  export type EmailCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templates?: boolean | EmailCategory$templatesArgs<ExtArgs>
    _count?: boolean | EmailCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCategory"]>

  export type EmailCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailCategory"]>

  export type EmailCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templates?: boolean | EmailCategory$templatesArgs<ExtArgs>
    _count?: boolean | EmailCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailCategory"
    objects: {
      templates: Prisma.$EmailTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailCategory"]>
    composites: {}
  }

  type EmailCategoryGetPayload<S extends boolean | null | undefined | EmailCategoryDefaultArgs> = $Result.GetResult<Prisma.$EmailCategoryPayload, S>

  type EmailCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailCategoryCountAggregateInputType | true
    }

  export interface EmailCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailCategory'], meta: { name: 'EmailCategory' } }
    /**
     * Find zero or one EmailCategory that matches the filter.
     * @param {EmailCategoryFindUniqueArgs} args - Arguments to find a EmailCategory
     * @example
     * // Get one EmailCategory
     * const emailCategory = await prisma.emailCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailCategoryFindUniqueArgs>(args: SelectSubset<T, EmailCategoryFindUniqueArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailCategoryFindUniqueOrThrowArgs} args - Arguments to find a EmailCategory
     * @example
     * // Get one EmailCategory
     * const emailCategory = await prisma.emailCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCategoryFindFirstArgs} args - Arguments to find a EmailCategory
     * @example
     * // Get one EmailCategory
     * const emailCategory = await prisma.emailCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailCategoryFindFirstArgs>(args?: SelectSubset<T, EmailCategoryFindFirstArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCategoryFindFirstOrThrowArgs} args - Arguments to find a EmailCategory
     * @example
     * // Get one EmailCategory
     * const emailCategory = await prisma.emailCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailCategories
     * const emailCategories = await prisma.emailCategory.findMany()
     * 
     * // Get first 10 EmailCategories
     * const emailCategories = await prisma.emailCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailCategoryWithIdOnly = await prisma.emailCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailCategoryFindManyArgs>(args?: SelectSubset<T, EmailCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailCategory.
     * @param {EmailCategoryCreateArgs} args - Arguments to create a EmailCategory.
     * @example
     * // Create one EmailCategory
     * const EmailCategory = await prisma.emailCategory.create({
     *   data: {
     *     // ... data to create a EmailCategory
     *   }
     * })
     * 
     */
    create<T extends EmailCategoryCreateArgs>(args: SelectSubset<T, EmailCategoryCreateArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailCategories.
     * @param {EmailCategoryCreateManyArgs} args - Arguments to create many EmailCategories.
     * @example
     * // Create many EmailCategories
     * const emailCategory = await prisma.emailCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCategoryCreateManyArgs>(args?: SelectSubset<T, EmailCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailCategories and returns the data saved in the database.
     * @param {EmailCategoryCreateManyAndReturnArgs} args - Arguments to create many EmailCategories.
     * @example
     * // Create many EmailCategories
     * const emailCategory = await prisma.emailCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailCategories and only return the `id`
     * const emailCategoryWithIdOnly = await prisma.emailCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailCategory.
     * @param {EmailCategoryDeleteArgs} args - Arguments to delete one EmailCategory.
     * @example
     * // Delete one EmailCategory
     * const EmailCategory = await prisma.emailCategory.delete({
     *   where: {
     *     // ... filter to delete one EmailCategory
     *   }
     * })
     * 
     */
    delete<T extends EmailCategoryDeleteArgs>(args: SelectSubset<T, EmailCategoryDeleteArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailCategory.
     * @param {EmailCategoryUpdateArgs} args - Arguments to update one EmailCategory.
     * @example
     * // Update one EmailCategory
     * const emailCategory = await prisma.emailCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailCategoryUpdateArgs>(args: SelectSubset<T, EmailCategoryUpdateArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailCategories.
     * @param {EmailCategoryDeleteManyArgs} args - Arguments to filter EmailCategories to delete.
     * @example
     * // Delete a few EmailCategories
     * const { count } = await prisma.emailCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailCategoryDeleteManyArgs>(args?: SelectSubset<T, EmailCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailCategories
     * const emailCategory = await prisma.emailCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailCategoryUpdateManyArgs>(args: SelectSubset<T, EmailCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailCategory.
     * @param {EmailCategoryUpsertArgs} args - Arguments to update or create a EmailCategory.
     * @example
     * // Update or create a EmailCategory
     * const emailCategory = await prisma.emailCategory.upsert({
     *   create: {
     *     // ... data to create a EmailCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailCategory we want to update
     *   }
     * })
     */
    upsert<T extends EmailCategoryUpsertArgs>(args: SelectSubset<T, EmailCategoryUpsertArgs<ExtArgs>>): Prisma__EmailCategoryClient<$Result.GetResult<Prisma.$EmailCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCategoryCountArgs} args - Arguments to filter EmailCategories to count.
     * @example
     * // Count the number of EmailCategories
     * const count = await prisma.emailCategory.count({
     *   where: {
     *     // ... the filter for the EmailCategories we want to count
     *   }
     * })
    **/
    count<T extends EmailCategoryCountArgs>(
      args?: Subset<T, EmailCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailCategoryAggregateArgs>(args: Subset<T, EmailCategoryAggregateArgs>): Prisma.PrismaPromise<GetEmailCategoryAggregateType<T>>

    /**
     * Group by EmailCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailCategoryGroupByArgs['orderBy'] }
        : { orderBy?: EmailCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailCategory model
   */
  readonly fields: EmailCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    templates<T extends EmailCategory$templatesArgs<ExtArgs> = {}>(args?: Subset<T, EmailCategory$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailCategory model
   */ 
  interface EmailCategoryFieldRefs {
    readonly id: FieldRef<"EmailCategory", 'String'>
    readonly name: FieldRef<"EmailCategory", 'String'>
    readonly description: FieldRef<"EmailCategory", 'String'>
    readonly createdAt: FieldRef<"EmailCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailCategory findUnique
   */
  export type EmailCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EmailCategory to fetch.
     */
    where: EmailCategoryWhereUniqueInput
  }

  /**
   * EmailCategory findUniqueOrThrow
   */
  export type EmailCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EmailCategory to fetch.
     */
    where: EmailCategoryWhereUniqueInput
  }

  /**
   * EmailCategory findFirst
   */
  export type EmailCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EmailCategory to fetch.
     */
    where?: EmailCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCategories to fetch.
     */
    orderBy?: EmailCategoryOrderByWithRelationInput | EmailCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCategories.
     */
    cursor?: EmailCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCategories.
     */
    distinct?: EmailCategoryScalarFieldEnum | EmailCategoryScalarFieldEnum[]
  }

  /**
   * EmailCategory findFirstOrThrow
   */
  export type EmailCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EmailCategory to fetch.
     */
    where?: EmailCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCategories to fetch.
     */
    orderBy?: EmailCategoryOrderByWithRelationInput | EmailCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCategories.
     */
    cursor?: EmailCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCategories.
     */
    distinct?: EmailCategoryScalarFieldEnum | EmailCategoryScalarFieldEnum[]
  }

  /**
   * EmailCategory findMany
   */
  export type EmailCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EmailCategories to fetch.
     */
    where?: EmailCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCategories to fetch.
     */
    orderBy?: EmailCategoryOrderByWithRelationInput | EmailCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailCategories.
     */
    cursor?: EmailCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCategories.
     */
    skip?: number
    distinct?: EmailCategoryScalarFieldEnum | EmailCategoryScalarFieldEnum[]
  }

  /**
   * EmailCategory create
   */
  export type EmailCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailCategory.
     */
    data: XOR<EmailCategoryCreateInput, EmailCategoryUncheckedCreateInput>
  }

  /**
   * EmailCategory createMany
   */
  export type EmailCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailCategories.
     */
    data: EmailCategoryCreateManyInput | EmailCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailCategory createManyAndReturn
   */
  export type EmailCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailCategories.
     */
    data: EmailCategoryCreateManyInput | EmailCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailCategory update
   */
  export type EmailCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailCategory.
     */
    data: XOR<EmailCategoryUpdateInput, EmailCategoryUncheckedUpdateInput>
    /**
     * Choose, which EmailCategory to update.
     */
    where: EmailCategoryWhereUniqueInput
  }

  /**
   * EmailCategory updateMany
   */
  export type EmailCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailCategories.
     */
    data: XOR<EmailCategoryUpdateManyMutationInput, EmailCategoryUncheckedUpdateManyInput>
    /**
     * Filter which EmailCategories to update
     */
    where?: EmailCategoryWhereInput
  }

  /**
   * EmailCategory upsert
   */
  export type EmailCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailCategory to update in case it exists.
     */
    where: EmailCategoryWhereUniqueInput
    /**
     * In case the EmailCategory found by the `where` argument doesn't exist, create a new EmailCategory with this data.
     */
    create: XOR<EmailCategoryCreateInput, EmailCategoryUncheckedCreateInput>
    /**
     * In case the EmailCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailCategoryUpdateInput, EmailCategoryUncheckedUpdateInput>
  }

  /**
   * EmailCategory delete
   */
  export type EmailCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
    /**
     * Filter which EmailCategory to delete.
     */
    where: EmailCategoryWhereUniqueInput
  }

  /**
   * EmailCategory deleteMany
   */
  export type EmailCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCategories to delete
     */
    where?: EmailCategoryWhereInput
  }

  /**
   * EmailCategory.templates
   */
  export type EmailCategory$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    cursor?: EmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailCategory without action
   */
  export type EmailCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCategory
     */
    select?: EmailCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCategoryInclude<ExtArgs> | null
  }


  /**
   * Model SmtpConfig
   */

  export type AggregateSmtpConfig = {
    _count: SmtpConfigCountAggregateOutputType | null
    _min: SmtpConfigMinAggregateOutputType | null
    _max: SmtpConfigMaxAggregateOutputType | null
  }

  export type SmtpConfigMinAggregateOutputType = {
    id: string | null
    provider: string | null
    host: string | null
    port: string | null
    username: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
  }

  export type SmtpConfigMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    host: string | null
    port: string | null
    username: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
  }

  export type SmtpConfigCountAggregateOutputType = {
    id: number
    provider: number
    host: number
    port: number
    username: number
    password: number
    isActive: number
    createdAt: number
    updatedAt: number
    teamId: number
    _all: number
  }


  export type SmtpConfigMinAggregateInputType = {
    id?: true
    provider?: true
    host?: true
    port?: true
    username?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
  }

  export type SmtpConfigMaxAggregateInputType = {
    id?: true
    provider?: true
    host?: true
    port?: true
    username?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
  }

  export type SmtpConfigCountAggregateInputType = {
    id?: true
    provider?: true
    host?: true
    port?: true
    username?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    _all?: true
  }

  export type SmtpConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmtpConfig to aggregate.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmtpConfigs
    **/
    _count?: true | SmtpConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmtpConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmtpConfigMaxAggregateInputType
  }

  export type GetSmtpConfigAggregateType<T extends SmtpConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSmtpConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmtpConfig[P]>
      : GetScalarType<T[P], AggregateSmtpConfig[P]>
  }




  export type SmtpConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmtpConfigWhereInput
    orderBy?: SmtpConfigOrderByWithAggregationInput | SmtpConfigOrderByWithAggregationInput[]
    by: SmtpConfigScalarFieldEnum[] | SmtpConfigScalarFieldEnum
    having?: SmtpConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmtpConfigCountAggregateInputType | true
    _min?: SmtpConfigMinAggregateInputType
    _max?: SmtpConfigMaxAggregateInputType
  }

  export type SmtpConfigGroupByOutputType = {
    id: string
    provider: string
    host: string
    port: string
    username: string
    password: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    teamId: string
    _count: SmtpConfigCountAggregateOutputType | null
    _min: SmtpConfigMinAggregateOutputType | null
    _max: SmtpConfigMaxAggregateOutputType | null
  }

  type GetSmtpConfigGroupByPayload<T extends SmtpConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SmtpConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmtpConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmtpConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SmtpConfigGroupByOutputType[P]>
        }
      >
    >


  export type SmtpConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    host?: boolean
    port?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    campaigns?: boolean | SmtpConfig$campaignsArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    _count?: boolean | SmtpConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smtpConfig"]>

  export type SmtpConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    host?: boolean
    port?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smtpConfig"]>

  export type SmtpConfigSelectScalar = {
    id?: boolean
    provider?: boolean
    host?: boolean
    port?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
  }

  export type SmtpConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | SmtpConfig$campaignsArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    _count?: boolean | SmtpConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SmtpConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $SmtpConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SmtpConfig"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      host: string
      port: string
      username: string
      password: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      teamId: string
    }, ExtArgs["result"]["smtpConfig"]>
    composites: {}
  }

  type SmtpConfigGetPayload<S extends boolean | null | undefined | SmtpConfigDefaultArgs> = $Result.GetResult<Prisma.$SmtpConfigPayload, S>

  type SmtpConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SmtpConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SmtpConfigCountAggregateInputType | true
    }

  export interface SmtpConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SmtpConfig'], meta: { name: 'SmtpConfig' } }
    /**
     * Find zero or one SmtpConfig that matches the filter.
     * @param {SmtpConfigFindUniqueArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SmtpConfigFindUniqueArgs>(args: SelectSubset<T, SmtpConfigFindUniqueArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SmtpConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SmtpConfigFindUniqueOrThrowArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SmtpConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SmtpConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SmtpConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigFindFirstArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SmtpConfigFindFirstArgs>(args?: SelectSubset<T, SmtpConfigFindFirstArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SmtpConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigFindFirstOrThrowArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SmtpConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SmtpConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SmtpConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmtpConfigs
     * const smtpConfigs = await prisma.smtpConfig.findMany()
     * 
     * // Get first 10 SmtpConfigs
     * const smtpConfigs = await prisma.smtpConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smtpConfigWithIdOnly = await prisma.smtpConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SmtpConfigFindManyArgs>(args?: SelectSubset<T, SmtpConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SmtpConfig.
     * @param {SmtpConfigCreateArgs} args - Arguments to create a SmtpConfig.
     * @example
     * // Create one SmtpConfig
     * const SmtpConfig = await prisma.smtpConfig.create({
     *   data: {
     *     // ... data to create a SmtpConfig
     *   }
     * })
     * 
     */
    create<T extends SmtpConfigCreateArgs>(args: SelectSubset<T, SmtpConfigCreateArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SmtpConfigs.
     * @param {SmtpConfigCreateManyArgs} args - Arguments to create many SmtpConfigs.
     * @example
     * // Create many SmtpConfigs
     * const smtpConfig = await prisma.smtpConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SmtpConfigCreateManyArgs>(args?: SelectSubset<T, SmtpConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SmtpConfigs and returns the data saved in the database.
     * @param {SmtpConfigCreateManyAndReturnArgs} args - Arguments to create many SmtpConfigs.
     * @example
     * // Create many SmtpConfigs
     * const smtpConfig = await prisma.smtpConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SmtpConfigs and only return the `id`
     * const smtpConfigWithIdOnly = await prisma.smtpConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SmtpConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SmtpConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SmtpConfig.
     * @param {SmtpConfigDeleteArgs} args - Arguments to delete one SmtpConfig.
     * @example
     * // Delete one SmtpConfig
     * const SmtpConfig = await prisma.smtpConfig.delete({
     *   where: {
     *     // ... filter to delete one SmtpConfig
     *   }
     * })
     * 
     */
    delete<T extends SmtpConfigDeleteArgs>(args: SelectSubset<T, SmtpConfigDeleteArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SmtpConfig.
     * @param {SmtpConfigUpdateArgs} args - Arguments to update one SmtpConfig.
     * @example
     * // Update one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SmtpConfigUpdateArgs>(args: SelectSubset<T, SmtpConfigUpdateArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SmtpConfigs.
     * @param {SmtpConfigDeleteManyArgs} args - Arguments to filter SmtpConfigs to delete.
     * @example
     * // Delete a few SmtpConfigs
     * const { count } = await prisma.smtpConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SmtpConfigDeleteManyArgs>(args?: SelectSubset<T, SmtpConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmtpConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmtpConfigs
     * const smtpConfig = await prisma.smtpConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SmtpConfigUpdateManyArgs>(args: SelectSubset<T, SmtpConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SmtpConfig.
     * @param {SmtpConfigUpsertArgs} args - Arguments to update or create a SmtpConfig.
     * @example
     * // Update or create a SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.upsert({
     *   create: {
     *     // ... data to create a SmtpConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmtpConfig we want to update
     *   }
     * })
     */
    upsert<T extends SmtpConfigUpsertArgs>(args: SelectSubset<T, SmtpConfigUpsertArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SmtpConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigCountArgs} args - Arguments to filter SmtpConfigs to count.
     * @example
     * // Count the number of SmtpConfigs
     * const count = await prisma.smtpConfig.count({
     *   where: {
     *     // ... the filter for the SmtpConfigs we want to count
     *   }
     * })
    **/
    count<T extends SmtpConfigCountArgs>(
      args?: Subset<T, SmtpConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmtpConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmtpConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmtpConfigAggregateArgs>(args: Subset<T, SmtpConfigAggregateArgs>): Prisma.PrismaPromise<GetSmtpConfigAggregateType<T>>

    /**
     * Group by SmtpConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmtpConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmtpConfigGroupByArgs['orderBy'] }
        : { orderBy?: SmtpConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmtpConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmtpConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SmtpConfig model
   */
  readonly fields: SmtpConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SmtpConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SmtpConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends SmtpConfig$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, SmtpConfig$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SmtpConfig model
   */ 
  interface SmtpConfigFieldRefs {
    readonly id: FieldRef<"SmtpConfig", 'String'>
    readonly provider: FieldRef<"SmtpConfig", 'String'>
    readonly host: FieldRef<"SmtpConfig", 'String'>
    readonly port: FieldRef<"SmtpConfig", 'String'>
    readonly username: FieldRef<"SmtpConfig", 'String'>
    readonly password: FieldRef<"SmtpConfig", 'String'>
    readonly isActive: FieldRef<"SmtpConfig", 'Boolean'>
    readonly createdAt: FieldRef<"SmtpConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SmtpConfig", 'DateTime'>
    readonly teamId: FieldRef<"SmtpConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SmtpConfig findUnique
   */
  export type SmtpConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig findUniqueOrThrow
   */
  export type SmtpConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig findFirst
   */
  export type SmtpConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmtpConfigs.
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmtpConfigs.
     */
    distinct?: SmtpConfigScalarFieldEnum | SmtpConfigScalarFieldEnum[]
  }

  /**
   * SmtpConfig findFirstOrThrow
   */
  export type SmtpConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmtpConfigs.
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmtpConfigs.
     */
    distinct?: SmtpConfigScalarFieldEnum | SmtpConfigScalarFieldEnum[]
  }

  /**
   * SmtpConfig findMany
   */
  export type SmtpConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * Filter, which SmtpConfigs to fetch.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmtpConfigs.
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    distinct?: SmtpConfigScalarFieldEnum | SmtpConfigScalarFieldEnum[]
  }

  /**
   * SmtpConfig create
   */
  export type SmtpConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a SmtpConfig.
     */
    data: XOR<SmtpConfigCreateInput, SmtpConfigUncheckedCreateInput>
  }

  /**
   * SmtpConfig createMany
   */
  export type SmtpConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SmtpConfigs.
     */
    data: SmtpConfigCreateManyInput | SmtpConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmtpConfig createManyAndReturn
   */
  export type SmtpConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SmtpConfigs.
     */
    data: SmtpConfigCreateManyInput | SmtpConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SmtpConfig update
   */
  export type SmtpConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a SmtpConfig.
     */
    data: XOR<SmtpConfigUpdateInput, SmtpConfigUncheckedUpdateInput>
    /**
     * Choose, which SmtpConfig to update.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig updateMany
   */
  export type SmtpConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SmtpConfigs.
     */
    data: XOR<SmtpConfigUpdateManyMutationInput, SmtpConfigUncheckedUpdateManyInput>
    /**
     * Filter which SmtpConfigs to update
     */
    where?: SmtpConfigWhereInput
  }

  /**
   * SmtpConfig upsert
   */
  export type SmtpConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the SmtpConfig to update in case it exists.
     */
    where: SmtpConfigWhereUniqueInput
    /**
     * In case the SmtpConfig found by the `where` argument doesn't exist, create a new SmtpConfig with this data.
     */
    create: XOR<SmtpConfigCreateInput, SmtpConfigUncheckedCreateInput>
    /**
     * In case the SmtpConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmtpConfigUpdateInput, SmtpConfigUncheckedUpdateInput>
  }

  /**
   * SmtpConfig delete
   */
  export type SmtpConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
    /**
     * Filter which SmtpConfig to delete.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig deleteMany
   */
  export type SmtpConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmtpConfigs to delete
     */
    where?: SmtpConfigWhereInput
  }

  /**
   * SmtpConfig.campaigns
   */
  export type SmtpConfig$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * SmtpConfig without action
   */
  export type SmtpConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmtpConfigInclude<ExtArgs> | null
  }


  /**
   * Model Automation
   */

  export type AggregateAutomation = {
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  export type AutomationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    teamId: string | null
  }

  export type AutomationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    teamId: string | null
  }

  export type AutomationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    isActive: number
    teamId: number
    _all: number
  }


  export type AutomationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    teamId?: true
  }

  export type AutomationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    teamId?: true
  }

  export type AutomationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    teamId?: true
    _all?: true
  }

  export type AutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automation to aggregate.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationMaxAggregateInputType
  }

  export type GetAutomationAggregateType<T extends AutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomation[P]>
      : GetScalarType<T[P], AggregateAutomation[P]>
  }




  export type AutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithAggregationInput | AutomationOrderByWithAggregationInput[]
    by: AutomationScalarFieldEnum[] | AutomationScalarFieldEnum
    having?: AutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationCountAggregateInputType | true
    _min?: AutomationMinAggregateInputType
    _max?: AutomationMaxAggregateInputType
  }

  export type AutomationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    teamId: string
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  type GetAutomationGroupByPayload<T extends AutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationGroupByOutputType[P]>
        }
      >
    >


  export type AutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    nodes?: boolean | Automation$nodesArgs<ExtArgs>
    edges?: boolean | Automation$edgesArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    teamId?: boolean
  }

  export type AutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    nodes?: boolean | Automation$nodesArgs<ExtArgs>
    edges?: boolean | Automation$edgesArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $AutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automation"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      nodes: Prisma.$AutomationNodePayload<ExtArgs>[]
      edges: Prisma.$AutomationNodeEdgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      isActive: boolean
      teamId: string
    }, ExtArgs["result"]["automation"]>
    composites: {}
  }

  type AutomationGetPayload<S extends boolean | null | undefined | AutomationDefaultArgs> = $Result.GetResult<Prisma.$AutomationPayload, S>

  type AutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationCountAggregateInputType | true
    }

  export interface AutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automation'], meta: { name: 'Automation' } }
    /**
     * Find zero or one Automation that matches the filter.
     * @param {AutomationFindUniqueArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFindUniqueArgs>(args: SelectSubset<T, AutomationFindUniqueArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Automation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationFindUniqueOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Automation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFindFirstArgs>(args?: SelectSubset<T, AutomationFindFirstArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Automation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automation.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWithIdOnly = await prisma.automation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFindManyArgs>(args?: SelectSubset<T, AutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Automation.
     * @param {AutomationCreateArgs} args - Arguments to create a Automation.
     * @example
     * // Create one Automation
     * const Automation = await prisma.automation.create({
     *   data: {
     *     // ... data to create a Automation
     *   }
     * })
     * 
     */
    create<T extends AutomationCreateArgs>(args: SelectSubset<T, AutomationCreateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Automations.
     * @param {AutomationCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationCreateManyArgs>(args?: SelectSubset<T, AutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Automations and returns the data saved in the database.
     * @param {AutomationCreateManyAndReturnArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Automations and only return the `id`
     * const automationWithIdOnly = await prisma.automation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Automation.
     * @param {AutomationDeleteArgs} args - Arguments to delete one Automation.
     * @example
     * // Delete one Automation
     * const Automation = await prisma.automation.delete({
     *   where: {
     *     // ... filter to delete one Automation
     *   }
     * })
     * 
     */
    delete<T extends AutomationDeleteArgs>(args: SelectSubset<T, AutomationDeleteArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Automation.
     * @param {AutomationUpdateArgs} args - Arguments to update one Automation.
     * @example
     * // Update one Automation
     * const automation = await prisma.automation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUpdateArgs>(args: SelectSubset<T, AutomationUpdateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Automations.
     * @param {AutomationDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationDeleteManyArgs>(args?: SelectSubset<T, AutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUpdateManyArgs>(args: SelectSubset<T, AutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Automation.
     * @param {AutomationUpsertArgs} args - Arguments to update or create a Automation.
     * @example
     * // Update or create a Automation
     * const automation = await prisma.automation.upsert({
     *   create: {
     *     // ... data to create a Automation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automation we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUpsertArgs>(args: SelectSubset<T, AutomationUpsertArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automation.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationCountArgs>(
      args?: Subset<T, AutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationAggregateArgs>(args: Subset<T, AutomationAggregateArgs>): Prisma.PrismaPromise<GetAutomationAggregateType<T>>

    /**
     * Group by Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationGroupByArgs['orderBy'] }
        : { orderBy?: AutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automation model
   */
  readonly fields: AutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nodes<T extends Automation$nodesArgs<ExtArgs> = {}>(args?: Subset<T, Automation$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findMany"> | Null>
    edges<T extends Automation$edgesArgs<ExtArgs> = {}>(args?: Subset<T, Automation$edgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automation model
   */ 
  interface AutomationFieldRefs {
    readonly id: FieldRef<"Automation", 'String'>
    readonly name: FieldRef<"Automation", 'String'>
    readonly description: FieldRef<"Automation", 'String'>
    readonly createdAt: FieldRef<"Automation", 'DateTime'>
    readonly updatedAt: FieldRef<"Automation", 'DateTime'>
    readonly isActive: FieldRef<"Automation", 'Boolean'>
    readonly teamId: FieldRef<"Automation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Automation findUnique
   */
  export type AutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findUniqueOrThrow
   */
  export type AutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findFirst
   */
  export type AutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findFirstOrThrow
   */
  export type AutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findMany
   */
  export type AutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation create
   */
  export type AutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a Automation.
     */
    data: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
  }

  /**
   * Automation createMany
   */
  export type AutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automation createManyAndReturn
   */
  export type AutomationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Automation update
   */
  export type AutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a Automation.
     */
    data: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
    /**
     * Choose, which Automation to update.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation updateMany
   */
  export type AutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation upsert
   */
  export type AutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the Automation to update in case it exists.
     */
    where: AutomationWhereUniqueInput
    /**
     * In case the Automation found by the `where` argument doesn't exist, create a new Automation with this data.
     */
    create: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
    /**
     * In case the Automation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
  }

  /**
   * Automation delete
   */
  export type AutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter which Automation to delete.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation deleteMany
   */
  export type AutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation.nodes
   */
  export type Automation$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    where?: AutomationNodeWhereInput
    orderBy?: AutomationNodeOrderByWithRelationInput | AutomationNodeOrderByWithRelationInput[]
    cursor?: AutomationNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationNodeScalarFieldEnum | AutomationNodeScalarFieldEnum[]
  }

  /**
   * Automation.edges
   */
  export type Automation$edgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    where?: AutomationNodeEdgeWhereInput
    orderBy?: AutomationNodeEdgeOrderByWithRelationInput | AutomationNodeEdgeOrderByWithRelationInput[]
    cursor?: AutomationNodeEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationNodeEdgeScalarFieldEnum | AutomationNodeEdgeScalarFieldEnum[]
  }

  /**
   * Automation without action
   */
  export type AutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
  }


  /**
   * Model AutomationNode
   */

  export type AggregateAutomationNode = {
    _count: AutomationNodeCountAggregateOutputType | null
    _min: AutomationNodeMinAggregateOutputType | null
    _max: AutomationNodeMaxAggregateOutputType | null
  }

  export type AutomationNodeMinAggregateOutputType = {
    id: string | null
    automationId: string | null
    type: $Enums.NodeType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationNodeMaxAggregateOutputType = {
    id: string | null
    automationId: string | null
    type: $Enums.NodeType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationNodeCountAggregateOutputType = {
    id: number
    automationId: number
    type: number
    createdAt: number
    updatedAt: number
    data: number
    _all: number
  }


  export type AutomationNodeMinAggregateInputType = {
    id?: true
    automationId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationNodeMaxAggregateInputType = {
    id?: true
    automationId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationNodeCountAggregateInputType = {
    id?: true
    automationId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    data?: true
    _all?: true
  }

  export type AutomationNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationNode to aggregate.
     */
    where?: AutomationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodes to fetch.
     */
    orderBy?: AutomationNodeOrderByWithRelationInput | AutomationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationNodes
    **/
    _count?: true | AutomationNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationNodeMaxAggregateInputType
  }

  export type GetAutomationNodeAggregateType<T extends AutomationNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationNode[P]>
      : GetScalarType<T[P], AggregateAutomationNode[P]>
  }




  export type AutomationNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationNodeWhereInput
    orderBy?: AutomationNodeOrderByWithAggregationInput | AutomationNodeOrderByWithAggregationInput[]
    by: AutomationNodeScalarFieldEnum[] | AutomationNodeScalarFieldEnum
    having?: AutomationNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationNodeCountAggregateInputType | true
    _min?: AutomationNodeMinAggregateInputType
    _max?: AutomationNodeMaxAggregateInputType
  }

  export type AutomationNodeGroupByOutputType = {
    id: string
    automationId: string
    type: $Enums.NodeType
    createdAt: Date
    updatedAt: Date
    data: JsonValue | null
    _count: AutomationNodeCountAggregateOutputType | null
    _min: AutomationNodeMinAggregateOutputType | null
    _max: AutomationNodeMaxAggregateOutputType | null
  }

  type GetAutomationNodeGroupByPayload<T extends AutomationNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationNodeGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationNodeGroupByOutputType[P]>
        }
      >
    >


  export type AutomationNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    data?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    edgesFrom?: boolean | AutomationNode$edgesFromArgs<ExtArgs>
    edgesTo?: boolean | AutomationNode$edgesToArgs<ExtArgs>
    _count?: boolean | AutomationNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationNode"]>

  export type AutomationNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    data?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationNode"]>

  export type AutomationNodeSelectScalar = {
    id?: boolean
    automationId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    data?: boolean
  }

  export type AutomationNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    edgesFrom?: boolean | AutomationNode$edgesFromArgs<ExtArgs>
    edgesTo?: boolean | AutomationNode$edgesToArgs<ExtArgs>
    _count?: boolean | AutomationNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }

  export type $AutomationNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationNode"
    objects: {
      automation: Prisma.$AutomationPayload<ExtArgs>
      edgesFrom: Prisma.$AutomationNodeEdgePayload<ExtArgs>[]
      edgesTo: Prisma.$AutomationNodeEdgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      automationId: string
      type: $Enums.NodeType
      createdAt: Date
      updatedAt: Date
      data: Prisma.JsonValue | null
    }, ExtArgs["result"]["automationNode"]>
    composites: {}
  }

  type AutomationNodeGetPayload<S extends boolean | null | undefined | AutomationNodeDefaultArgs> = $Result.GetResult<Prisma.$AutomationNodePayload, S>

  type AutomationNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationNodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationNodeCountAggregateInputType | true
    }

  export interface AutomationNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationNode'], meta: { name: 'AutomationNode' } }
    /**
     * Find zero or one AutomationNode that matches the filter.
     * @param {AutomationNodeFindUniqueArgs} args - Arguments to find a AutomationNode
     * @example
     * // Get one AutomationNode
     * const automationNode = await prisma.automationNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationNodeFindUniqueArgs>(args: SelectSubset<T, AutomationNodeFindUniqueArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutomationNode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationNodeFindUniqueOrThrowArgs} args - Arguments to find a AutomationNode
     * @example
     * // Get one AutomationNode
     * const automationNode = await prisma.automationNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutomationNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeFindFirstArgs} args - Arguments to find a AutomationNode
     * @example
     * // Get one AutomationNode
     * const automationNode = await prisma.automationNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationNodeFindFirstArgs>(args?: SelectSubset<T, AutomationNodeFindFirstArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutomationNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeFindFirstOrThrowArgs} args - Arguments to find a AutomationNode
     * @example
     * // Get one AutomationNode
     * const automationNode = await prisma.automationNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutomationNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationNodes
     * const automationNodes = await prisma.automationNode.findMany()
     * 
     * // Get first 10 AutomationNodes
     * const automationNodes = await prisma.automationNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationNodeWithIdOnly = await prisma.automationNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationNodeFindManyArgs>(args?: SelectSubset<T, AutomationNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutomationNode.
     * @param {AutomationNodeCreateArgs} args - Arguments to create a AutomationNode.
     * @example
     * // Create one AutomationNode
     * const AutomationNode = await prisma.automationNode.create({
     *   data: {
     *     // ... data to create a AutomationNode
     *   }
     * })
     * 
     */
    create<T extends AutomationNodeCreateArgs>(args: SelectSubset<T, AutomationNodeCreateArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutomationNodes.
     * @param {AutomationNodeCreateManyArgs} args - Arguments to create many AutomationNodes.
     * @example
     * // Create many AutomationNodes
     * const automationNode = await prisma.automationNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationNodeCreateManyArgs>(args?: SelectSubset<T, AutomationNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationNodes and returns the data saved in the database.
     * @param {AutomationNodeCreateManyAndReturnArgs} args - Arguments to create many AutomationNodes.
     * @example
     * // Create many AutomationNodes
     * const automationNode = await prisma.automationNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationNodes and only return the `id`
     * const automationNodeWithIdOnly = await prisma.automationNode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutomationNode.
     * @param {AutomationNodeDeleteArgs} args - Arguments to delete one AutomationNode.
     * @example
     * // Delete one AutomationNode
     * const AutomationNode = await prisma.automationNode.delete({
     *   where: {
     *     // ... filter to delete one AutomationNode
     *   }
     * })
     * 
     */
    delete<T extends AutomationNodeDeleteArgs>(args: SelectSubset<T, AutomationNodeDeleteArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutomationNode.
     * @param {AutomationNodeUpdateArgs} args - Arguments to update one AutomationNode.
     * @example
     * // Update one AutomationNode
     * const automationNode = await prisma.automationNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationNodeUpdateArgs>(args: SelectSubset<T, AutomationNodeUpdateArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutomationNodes.
     * @param {AutomationNodeDeleteManyArgs} args - Arguments to filter AutomationNodes to delete.
     * @example
     * // Delete a few AutomationNodes
     * const { count } = await prisma.automationNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationNodeDeleteManyArgs>(args?: SelectSubset<T, AutomationNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationNodes
     * const automationNode = await prisma.automationNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationNodeUpdateManyArgs>(args: SelectSubset<T, AutomationNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationNode.
     * @param {AutomationNodeUpsertArgs} args - Arguments to update or create a AutomationNode.
     * @example
     * // Update or create a AutomationNode
     * const automationNode = await prisma.automationNode.upsert({
     *   create: {
     *     // ... data to create a AutomationNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationNode we want to update
     *   }
     * })
     */
    upsert<T extends AutomationNodeUpsertArgs>(args: SelectSubset<T, AutomationNodeUpsertArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutomationNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeCountArgs} args - Arguments to filter AutomationNodes to count.
     * @example
     * // Count the number of AutomationNodes
     * const count = await prisma.automationNode.count({
     *   where: {
     *     // ... the filter for the AutomationNodes we want to count
     *   }
     * })
    **/
    count<T extends AutomationNodeCountArgs>(
      args?: Subset<T, AutomationNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationNodeAggregateArgs>(args: Subset<T, AutomationNodeAggregateArgs>): Prisma.PrismaPromise<GetAutomationNodeAggregateType<T>>

    /**
     * Group by AutomationNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationNodeGroupByArgs['orderBy'] }
        : { orderBy?: AutomationNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationNode model
   */
  readonly fields: AutomationNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    edgesFrom<T extends AutomationNode$edgesFromArgs<ExtArgs> = {}>(args?: Subset<T, AutomationNode$edgesFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findMany"> | Null>
    edgesTo<T extends AutomationNode$edgesToArgs<ExtArgs> = {}>(args?: Subset<T, AutomationNode$edgesToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationNode model
   */ 
  interface AutomationNodeFieldRefs {
    readonly id: FieldRef<"AutomationNode", 'String'>
    readonly automationId: FieldRef<"AutomationNode", 'String'>
    readonly type: FieldRef<"AutomationNode", 'NodeType'>
    readonly createdAt: FieldRef<"AutomationNode", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationNode", 'DateTime'>
    readonly data: FieldRef<"AutomationNode", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AutomationNode findUnique
   */
  export type AutomationNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNode to fetch.
     */
    where: AutomationNodeWhereUniqueInput
  }

  /**
   * AutomationNode findUniqueOrThrow
   */
  export type AutomationNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNode to fetch.
     */
    where: AutomationNodeWhereUniqueInput
  }

  /**
   * AutomationNode findFirst
   */
  export type AutomationNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNode to fetch.
     */
    where?: AutomationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodes to fetch.
     */
    orderBy?: AutomationNodeOrderByWithRelationInput | AutomationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationNodes.
     */
    cursor?: AutomationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationNodes.
     */
    distinct?: AutomationNodeScalarFieldEnum | AutomationNodeScalarFieldEnum[]
  }

  /**
   * AutomationNode findFirstOrThrow
   */
  export type AutomationNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNode to fetch.
     */
    where?: AutomationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodes to fetch.
     */
    orderBy?: AutomationNodeOrderByWithRelationInput | AutomationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationNodes.
     */
    cursor?: AutomationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationNodes.
     */
    distinct?: AutomationNodeScalarFieldEnum | AutomationNodeScalarFieldEnum[]
  }

  /**
   * AutomationNode findMany
   */
  export type AutomationNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNodes to fetch.
     */
    where?: AutomationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodes to fetch.
     */
    orderBy?: AutomationNodeOrderByWithRelationInput | AutomationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationNodes.
     */
    cursor?: AutomationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodes.
     */
    skip?: number
    distinct?: AutomationNodeScalarFieldEnum | AutomationNodeScalarFieldEnum[]
  }

  /**
   * AutomationNode create
   */
  export type AutomationNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationNode.
     */
    data: XOR<AutomationNodeCreateInput, AutomationNodeUncheckedCreateInput>
  }

  /**
   * AutomationNode createMany
   */
  export type AutomationNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationNodes.
     */
    data: AutomationNodeCreateManyInput | AutomationNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationNode createManyAndReturn
   */
  export type AutomationNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutomationNodes.
     */
    data: AutomationNodeCreateManyInput | AutomationNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationNode update
   */
  export type AutomationNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationNode.
     */
    data: XOR<AutomationNodeUpdateInput, AutomationNodeUncheckedUpdateInput>
    /**
     * Choose, which AutomationNode to update.
     */
    where: AutomationNodeWhereUniqueInput
  }

  /**
   * AutomationNode updateMany
   */
  export type AutomationNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationNodes.
     */
    data: XOR<AutomationNodeUpdateManyMutationInput, AutomationNodeUncheckedUpdateManyInput>
    /**
     * Filter which AutomationNodes to update
     */
    where?: AutomationNodeWhereInput
  }

  /**
   * AutomationNode upsert
   */
  export type AutomationNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationNode to update in case it exists.
     */
    where: AutomationNodeWhereUniqueInput
    /**
     * In case the AutomationNode found by the `where` argument doesn't exist, create a new AutomationNode with this data.
     */
    create: XOR<AutomationNodeCreateInput, AutomationNodeUncheckedCreateInput>
    /**
     * In case the AutomationNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationNodeUpdateInput, AutomationNodeUncheckedUpdateInput>
  }

  /**
   * AutomationNode delete
   */
  export type AutomationNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
    /**
     * Filter which AutomationNode to delete.
     */
    where: AutomationNodeWhereUniqueInput
  }

  /**
   * AutomationNode deleteMany
   */
  export type AutomationNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationNodes to delete
     */
    where?: AutomationNodeWhereInput
  }

  /**
   * AutomationNode.edgesFrom
   */
  export type AutomationNode$edgesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    where?: AutomationNodeEdgeWhereInput
    orderBy?: AutomationNodeEdgeOrderByWithRelationInput | AutomationNodeEdgeOrderByWithRelationInput[]
    cursor?: AutomationNodeEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationNodeEdgeScalarFieldEnum | AutomationNodeEdgeScalarFieldEnum[]
  }

  /**
   * AutomationNode.edgesTo
   */
  export type AutomationNode$edgesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    where?: AutomationNodeEdgeWhereInput
    orderBy?: AutomationNodeEdgeOrderByWithRelationInput | AutomationNodeEdgeOrderByWithRelationInput[]
    cursor?: AutomationNodeEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationNodeEdgeScalarFieldEnum | AutomationNodeEdgeScalarFieldEnum[]
  }

  /**
   * AutomationNode without action
   */
  export type AutomationNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNode
     */
    select?: AutomationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeInclude<ExtArgs> | null
  }


  /**
   * Model AutomationNodeEdge
   */

  export type AggregateAutomationNodeEdge = {
    _count: AutomationNodeEdgeCountAggregateOutputType | null
    _min: AutomationNodeEdgeMinAggregateOutputType | null
    _max: AutomationNodeEdgeMaxAggregateOutputType | null
  }

  export type AutomationNodeEdgeMinAggregateOutputType = {
    id: string | null
    automationId: string | null
    sourceId: string | null
    targetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    label: string | null
    animated: boolean | null
  }

  export type AutomationNodeEdgeMaxAggregateOutputType = {
    id: string | null
    automationId: string | null
    sourceId: string | null
    targetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    label: string | null
    animated: boolean | null
  }

  export type AutomationNodeEdgeCountAggregateOutputType = {
    id: number
    automationId: number
    sourceId: number
    targetId: number
    createdAt: number
    updatedAt: number
    label: number
    animated: number
    _all: number
  }


  export type AutomationNodeEdgeMinAggregateInputType = {
    id?: true
    automationId?: true
    sourceId?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    label?: true
    animated?: true
  }

  export type AutomationNodeEdgeMaxAggregateInputType = {
    id?: true
    automationId?: true
    sourceId?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    label?: true
    animated?: true
  }

  export type AutomationNodeEdgeCountAggregateInputType = {
    id?: true
    automationId?: true
    sourceId?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    label?: true
    animated?: true
    _all?: true
  }

  export type AutomationNodeEdgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationNodeEdge to aggregate.
     */
    where?: AutomationNodeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodeEdges to fetch.
     */
    orderBy?: AutomationNodeEdgeOrderByWithRelationInput | AutomationNodeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationNodeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodeEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationNodeEdges
    **/
    _count?: true | AutomationNodeEdgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationNodeEdgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationNodeEdgeMaxAggregateInputType
  }

  export type GetAutomationNodeEdgeAggregateType<T extends AutomationNodeEdgeAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationNodeEdge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationNodeEdge[P]>
      : GetScalarType<T[P], AggregateAutomationNodeEdge[P]>
  }




  export type AutomationNodeEdgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationNodeEdgeWhereInput
    orderBy?: AutomationNodeEdgeOrderByWithAggregationInput | AutomationNodeEdgeOrderByWithAggregationInput[]
    by: AutomationNodeEdgeScalarFieldEnum[] | AutomationNodeEdgeScalarFieldEnum
    having?: AutomationNodeEdgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationNodeEdgeCountAggregateInputType | true
    _min?: AutomationNodeEdgeMinAggregateInputType
    _max?: AutomationNodeEdgeMaxAggregateInputType
  }

  export type AutomationNodeEdgeGroupByOutputType = {
    id: string
    automationId: string
    sourceId: string
    targetId: string
    createdAt: Date
    updatedAt: Date
    label: string | null
    animated: boolean
    _count: AutomationNodeEdgeCountAggregateOutputType | null
    _min: AutomationNodeEdgeMinAggregateOutputType | null
    _max: AutomationNodeEdgeMaxAggregateOutputType | null
  }

  type GetAutomationNodeEdgeGroupByPayload<T extends AutomationNodeEdgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationNodeEdgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationNodeEdgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationNodeEdgeGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationNodeEdgeGroupByOutputType[P]>
        }
      >
    >


  export type AutomationNodeEdgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    sourceId?: boolean
    targetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    label?: boolean
    animated?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    source?: boolean | AutomationNodeDefaultArgs<ExtArgs>
    target?: boolean | AutomationNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationNodeEdge"]>

  export type AutomationNodeEdgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    sourceId?: boolean
    targetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    label?: boolean
    animated?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    source?: boolean | AutomationNodeDefaultArgs<ExtArgs>
    target?: boolean | AutomationNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationNodeEdge"]>

  export type AutomationNodeEdgeSelectScalar = {
    id?: boolean
    automationId?: boolean
    sourceId?: boolean
    targetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    label?: boolean
    animated?: boolean
  }

  export type AutomationNodeEdgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    source?: boolean | AutomationNodeDefaultArgs<ExtArgs>
    target?: boolean | AutomationNodeDefaultArgs<ExtArgs>
  }
  export type AutomationNodeEdgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    source?: boolean | AutomationNodeDefaultArgs<ExtArgs>
    target?: boolean | AutomationNodeDefaultArgs<ExtArgs>
  }

  export type $AutomationNodeEdgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationNodeEdge"
    objects: {
      automation: Prisma.$AutomationPayload<ExtArgs>
      source: Prisma.$AutomationNodePayload<ExtArgs>
      target: Prisma.$AutomationNodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      automationId: string
      sourceId: string
      targetId: string
      createdAt: Date
      updatedAt: Date
      label: string | null
      animated: boolean
    }, ExtArgs["result"]["automationNodeEdge"]>
    composites: {}
  }

  type AutomationNodeEdgeGetPayload<S extends boolean | null | undefined | AutomationNodeEdgeDefaultArgs> = $Result.GetResult<Prisma.$AutomationNodeEdgePayload, S>

  type AutomationNodeEdgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationNodeEdgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationNodeEdgeCountAggregateInputType | true
    }

  export interface AutomationNodeEdgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationNodeEdge'], meta: { name: 'AutomationNodeEdge' } }
    /**
     * Find zero or one AutomationNodeEdge that matches the filter.
     * @param {AutomationNodeEdgeFindUniqueArgs} args - Arguments to find a AutomationNodeEdge
     * @example
     * // Get one AutomationNodeEdge
     * const automationNodeEdge = await prisma.automationNodeEdge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationNodeEdgeFindUniqueArgs>(args: SelectSubset<T, AutomationNodeEdgeFindUniqueArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutomationNodeEdge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationNodeEdgeFindUniqueOrThrowArgs} args - Arguments to find a AutomationNodeEdge
     * @example
     * // Get one AutomationNodeEdge
     * const automationNodeEdge = await prisma.automationNodeEdge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationNodeEdgeFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationNodeEdgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutomationNodeEdge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeEdgeFindFirstArgs} args - Arguments to find a AutomationNodeEdge
     * @example
     * // Get one AutomationNodeEdge
     * const automationNodeEdge = await prisma.automationNodeEdge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationNodeEdgeFindFirstArgs>(args?: SelectSubset<T, AutomationNodeEdgeFindFirstArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutomationNodeEdge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeEdgeFindFirstOrThrowArgs} args - Arguments to find a AutomationNodeEdge
     * @example
     * // Get one AutomationNodeEdge
     * const automationNodeEdge = await prisma.automationNodeEdge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationNodeEdgeFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationNodeEdgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutomationNodeEdges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeEdgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationNodeEdges
     * const automationNodeEdges = await prisma.automationNodeEdge.findMany()
     * 
     * // Get first 10 AutomationNodeEdges
     * const automationNodeEdges = await prisma.automationNodeEdge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationNodeEdgeWithIdOnly = await prisma.automationNodeEdge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationNodeEdgeFindManyArgs>(args?: SelectSubset<T, AutomationNodeEdgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutomationNodeEdge.
     * @param {AutomationNodeEdgeCreateArgs} args - Arguments to create a AutomationNodeEdge.
     * @example
     * // Create one AutomationNodeEdge
     * const AutomationNodeEdge = await prisma.automationNodeEdge.create({
     *   data: {
     *     // ... data to create a AutomationNodeEdge
     *   }
     * })
     * 
     */
    create<T extends AutomationNodeEdgeCreateArgs>(args: SelectSubset<T, AutomationNodeEdgeCreateArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutomationNodeEdges.
     * @param {AutomationNodeEdgeCreateManyArgs} args - Arguments to create many AutomationNodeEdges.
     * @example
     * // Create many AutomationNodeEdges
     * const automationNodeEdge = await prisma.automationNodeEdge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationNodeEdgeCreateManyArgs>(args?: SelectSubset<T, AutomationNodeEdgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationNodeEdges and returns the data saved in the database.
     * @param {AutomationNodeEdgeCreateManyAndReturnArgs} args - Arguments to create many AutomationNodeEdges.
     * @example
     * // Create many AutomationNodeEdges
     * const automationNodeEdge = await prisma.automationNodeEdge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationNodeEdges and only return the `id`
     * const automationNodeEdgeWithIdOnly = await prisma.automationNodeEdge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationNodeEdgeCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationNodeEdgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutomationNodeEdge.
     * @param {AutomationNodeEdgeDeleteArgs} args - Arguments to delete one AutomationNodeEdge.
     * @example
     * // Delete one AutomationNodeEdge
     * const AutomationNodeEdge = await prisma.automationNodeEdge.delete({
     *   where: {
     *     // ... filter to delete one AutomationNodeEdge
     *   }
     * })
     * 
     */
    delete<T extends AutomationNodeEdgeDeleteArgs>(args: SelectSubset<T, AutomationNodeEdgeDeleteArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutomationNodeEdge.
     * @param {AutomationNodeEdgeUpdateArgs} args - Arguments to update one AutomationNodeEdge.
     * @example
     * // Update one AutomationNodeEdge
     * const automationNodeEdge = await prisma.automationNodeEdge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationNodeEdgeUpdateArgs>(args: SelectSubset<T, AutomationNodeEdgeUpdateArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutomationNodeEdges.
     * @param {AutomationNodeEdgeDeleteManyArgs} args - Arguments to filter AutomationNodeEdges to delete.
     * @example
     * // Delete a few AutomationNodeEdges
     * const { count } = await prisma.automationNodeEdge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationNodeEdgeDeleteManyArgs>(args?: SelectSubset<T, AutomationNodeEdgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationNodeEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeEdgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationNodeEdges
     * const automationNodeEdge = await prisma.automationNodeEdge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationNodeEdgeUpdateManyArgs>(args: SelectSubset<T, AutomationNodeEdgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationNodeEdge.
     * @param {AutomationNodeEdgeUpsertArgs} args - Arguments to update or create a AutomationNodeEdge.
     * @example
     * // Update or create a AutomationNodeEdge
     * const automationNodeEdge = await prisma.automationNodeEdge.upsert({
     *   create: {
     *     // ... data to create a AutomationNodeEdge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationNodeEdge we want to update
     *   }
     * })
     */
    upsert<T extends AutomationNodeEdgeUpsertArgs>(args: SelectSubset<T, AutomationNodeEdgeUpsertArgs<ExtArgs>>): Prisma__AutomationNodeEdgeClient<$Result.GetResult<Prisma.$AutomationNodeEdgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutomationNodeEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeEdgeCountArgs} args - Arguments to filter AutomationNodeEdges to count.
     * @example
     * // Count the number of AutomationNodeEdges
     * const count = await prisma.automationNodeEdge.count({
     *   where: {
     *     // ... the filter for the AutomationNodeEdges we want to count
     *   }
     * })
    **/
    count<T extends AutomationNodeEdgeCountArgs>(
      args?: Subset<T, AutomationNodeEdgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationNodeEdgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationNodeEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeEdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationNodeEdgeAggregateArgs>(args: Subset<T, AutomationNodeEdgeAggregateArgs>): Prisma.PrismaPromise<GetAutomationNodeEdgeAggregateType<T>>

    /**
     * Group by AutomationNodeEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationNodeEdgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationNodeEdgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationNodeEdgeGroupByArgs['orderBy'] }
        : { orderBy?: AutomationNodeEdgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationNodeEdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationNodeEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationNodeEdge model
   */
  readonly fields: AutomationNodeEdgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationNodeEdge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationNodeEdgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    source<T extends AutomationNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationNodeDefaultArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    target<T extends AutomationNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationNodeDefaultArgs<ExtArgs>>): Prisma__AutomationNodeClient<$Result.GetResult<Prisma.$AutomationNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationNodeEdge model
   */ 
  interface AutomationNodeEdgeFieldRefs {
    readonly id: FieldRef<"AutomationNodeEdge", 'String'>
    readonly automationId: FieldRef<"AutomationNodeEdge", 'String'>
    readonly sourceId: FieldRef<"AutomationNodeEdge", 'String'>
    readonly targetId: FieldRef<"AutomationNodeEdge", 'String'>
    readonly createdAt: FieldRef<"AutomationNodeEdge", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationNodeEdge", 'DateTime'>
    readonly label: FieldRef<"AutomationNodeEdge", 'String'>
    readonly animated: FieldRef<"AutomationNodeEdge", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AutomationNodeEdge findUnique
   */
  export type AutomationNodeEdgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNodeEdge to fetch.
     */
    where: AutomationNodeEdgeWhereUniqueInput
  }

  /**
   * AutomationNodeEdge findUniqueOrThrow
   */
  export type AutomationNodeEdgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNodeEdge to fetch.
     */
    where: AutomationNodeEdgeWhereUniqueInput
  }

  /**
   * AutomationNodeEdge findFirst
   */
  export type AutomationNodeEdgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNodeEdge to fetch.
     */
    where?: AutomationNodeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodeEdges to fetch.
     */
    orderBy?: AutomationNodeEdgeOrderByWithRelationInput | AutomationNodeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationNodeEdges.
     */
    cursor?: AutomationNodeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodeEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationNodeEdges.
     */
    distinct?: AutomationNodeEdgeScalarFieldEnum | AutomationNodeEdgeScalarFieldEnum[]
  }

  /**
   * AutomationNodeEdge findFirstOrThrow
   */
  export type AutomationNodeEdgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNodeEdge to fetch.
     */
    where?: AutomationNodeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodeEdges to fetch.
     */
    orderBy?: AutomationNodeEdgeOrderByWithRelationInput | AutomationNodeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationNodeEdges.
     */
    cursor?: AutomationNodeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodeEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationNodeEdges.
     */
    distinct?: AutomationNodeEdgeScalarFieldEnum | AutomationNodeEdgeScalarFieldEnum[]
  }

  /**
   * AutomationNodeEdge findMany
   */
  export type AutomationNodeEdgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which AutomationNodeEdges to fetch.
     */
    where?: AutomationNodeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationNodeEdges to fetch.
     */
    orderBy?: AutomationNodeEdgeOrderByWithRelationInput | AutomationNodeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationNodeEdges.
     */
    cursor?: AutomationNodeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationNodeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationNodeEdges.
     */
    skip?: number
    distinct?: AutomationNodeEdgeScalarFieldEnum | AutomationNodeEdgeScalarFieldEnum[]
  }

  /**
   * AutomationNodeEdge create
   */
  export type AutomationNodeEdgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationNodeEdge.
     */
    data: XOR<AutomationNodeEdgeCreateInput, AutomationNodeEdgeUncheckedCreateInput>
  }

  /**
   * AutomationNodeEdge createMany
   */
  export type AutomationNodeEdgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationNodeEdges.
     */
    data: AutomationNodeEdgeCreateManyInput | AutomationNodeEdgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationNodeEdge createManyAndReturn
   */
  export type AutomationNodeEdgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutomationNodeEdges.
     */
    data: AutomationNodeEdgeCreateManyInput | AutomationNodeEdgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationNodeEdge update
   */
  export type AutomationNodeEdgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationNodeEdge.
     */
    data: XOR<AutomationNodeEdgeUpdateInput, AutomationNodeEdgeUncheckedUpdateInput>
    /**
     * Choose, which AutomationNodeEdge to update.
     */
    where: AutomationNodeEdgeWhereUniqueInput
  }

  /**
   * AutomationNodeEdge updateMany
   */
  export type AutomationNodeEdgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationNodeEdges.
     */
    data: XOR<AutomationNodeEdgeUpdateManyMutationInput, AutomationNodeEdgeUncheckedUpdateManyInput>
    /**
     * Filter which AutomationNodeEdges to update
     */
    where?: AutomationNodeEdgeWhereInput
  }

  /**
   * AutomationNodeEdge upsert
   */
  export type AutomationNodeEdgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationNodeEdge to update in case it exists.
     */
    where: AutomationNodeEdgeWhereUniqueInput
    /**
     * In case the AutomationNodeEdge found by the `where` argument doesn't exist, create a new AutomationNodeEdge with this data.
     */
    create: XOR<AutomationNodeEdgeCreateInput, AutomationNodeEdgeUncheckedCreateInput>
    /**
     * In case the AutomationNodeEdge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationNodeEdgeUpdateInput, AutomationNodeEdgeUncheckedUpdateInput>
  }

  /**
   * AutomationNodeEdge delete
   */
  export type AutomationNodeEdgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
    /**
     * Filter which AutomationNodeEdge to delete.
     */
    where: AutomationNodeEdgeWhereUniqueInput
  }

  /**
   * AutomationNodeEdge deleteMany
   */
  export type AutomationNodeEdgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationNodeEdges to delete
     */
    where?: AutomationNodeEdgeWhereInput
  }

  /**
   * AutomationNodeEdge without action
   */
  export type AutomationNodeEdgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationNodeEdge
     */
    select?: AutomationNodeEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationNodeEdgeInclude<ExtArgs> | null
  }


  /**
   * Model CustomDomain
   */

  export type AggregateCustomDomain = {
    _count: CustomDomainCountAggregateOutputType | null
    _min: CustomDomainMinAggregateOutputType | null
    _max: CustomDomainMaxAggregateOutputType | null
  }

  export type CustomDomainMinAggregateOutputType = {
    id: string | null
    domain: string | null
    sslStatus: string | null
    sslCertificate: string | null
    sslPrivateKey: string | null
    sslExpiresAt: Date | null
    verificationToken: string | null
    dnsChallenge: string | null
    dnsChallengeToken: string | null
    isVerified: boolean | null
    isActive: boolean | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomDomainMaxAggregateOutputType = {
    id: string | null
    domain: string | null
    sslStatus: string | null
    sslCertificate: string | null
    sslPrivateKey: string | null
    sslExpiresAt: Date | null
    verificationToken: string | null
    dnsChallenge: string | null
    dnsChallengeToken: string | null
    isVerified: boolean | null
    isActive: boolean | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomDomainCountAggregateOutputType = {
    id: number
    domain: number
    sslStatus: number
    sslCertificate: number
    sslPrivateKey: number
    sslExpiresAt: number
    verificationToken: number
    dnsChallenge: number
    dnsChallengeToken: number
    isVerified: number
    isActive: number
    teamId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomDomainMinAggregateInputType = {
    id?: true
    domain?: true
    sslStatus?: true
    sslCertificate?: true
    sslPrivateKey?: true
    sslExpiresAt?: true
    verificationToken?: true
    dnsChallenge?: true
    dnsChallengeToken?: true
    isVerified?: true
    isActive?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomDomainMaxAggregateInputType = {
    id?: true
    domain?: true
    sslStatus?: true
    sslCertificate?: true
    sslPrivateKey?: true
    sslExpiresAt?: true
    verificationToken?: true
    dnsChallenge?: true
    dnsChallengeToken?: true
    isVerified?: true
    isActive?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomDomainCountAggregateInputType = {
    id?: true
    domain?: true
    sslStatus?: true
    sslCertificate?: true
    sslPrivateKey?: true
    sslExpiresAt?: true
    verificationToken?: true
    dnsChallenge?: true
    dnsChallengeToken?: true
    isVerified?: true
    isActive?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomDomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomDomain to aggregate.
     */
    where?: CustomDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomDomains to fetch.
     */
    orderBy?: CustomDomainOrderByWithRelationInput | CustomDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomDomains
    **/
    _count?: true | CustomDomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomDomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomDomainMaxAggregateInputType
  }

  export type GetCustomDomainAggregateType<T extends CustomDomainAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomDomain[P]>
      : GetScalarType<T[P], AggregateCustomDomain[P]>
  }




  export type CustomDomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomDomainWhereInput
    orderBy?: CustomDomainOrderByWithAggregationInput | CustomDomainOrderByWithAggregationInput[]
    by: CustomDomainScalarFieldEnum[] | CustomDomainScalarFieldEnum
    having?: CustomDomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomDomainCountAggregateInputType | true
    _min?: CustomDomainMinAggregateInputType
    _max?: CustomDomainMaxAggregateInputType
  }

  export type CustomDomainGroupByOutputType = {
    id: string
    domain: string
    sslStatus: string
    sslCertificate: string | null
    sslPrivateKey: string | null
    sslExpiresAt: Date | null
    verificationToken: string
    dnsChallenge: string | null
    dnsChallengeToken: string | null
    isVerified: boolean
    isActive: boolean
    teamId: string
    createdAt: Date
    updatedAt: Date
    _count: CustomDomainCountAggregateOutputType | null
    _min: CustomDomainMinAggregateOutputType | null
    _max: CustomDomainMaxAggregateOutputType | null
  }

  type GetCustomDomainGroupByPayload<T extends CustomDomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomDomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomDomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomDomainGroupByOutputType[P]>
            : GetScalarType<T[P], CustomDomainGroupByOutputType[P]>
        }
      >
    >


  export type CustomDomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    sslStatus?: boolean
    sslCertificate?: boolean
    sslPrivateKey?: boolean
    sslExpiresAt?: boolean
    verificationToken?: boolean
    dnsChallenge?: boolean
    dnsChallengeToken?: boolean
    isVerified?: boolean
    isActive?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customDomain"]>

  export type CustomDomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    sslStatus?: boolean
    sslCertificate?: boolean
    sslPrivateKey?: boolean
    sslExpiresAt?: boolean
    verificationToken?: boolean
    dnsChallenge?: boolean
    dnsChallengeToken?: boolean
    isVerified?: boolean
    isActive?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customDomain"]>

  export type CustomDomainSelectScalar = {
    id?: boolean
    domain?: boolean
    sslStatus?: boolean
    sslCertificate?: boolean
    sslPrivateKey?: boolean
    sslExpiresAt?: boolean
    verificationToken?: boolean
    dnsChallenge?: boolean
    dnsChallengeToken?: boolean
    isVerified?: boolean
    isActive?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomDomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type CustomDomainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $CustomDomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomDomain"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domain: string
      sslStatus: string
      sslCertificate: string | null
      sslPrivateKey: string | null
      sslExpiresAt: Date | null
      verificationToken: string
      dnsChallenge: string | null
      dnsChallengeToken: string | null
      isVerified: boolean
      isActive: boolean
      teamId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customDomain"]>
    composites: {}
  }

  type CustomDomainGetPayload<S extends boolean | null | undefined | CustomDomainDefaultArgs> = $Result.GetResult<Prisma.$CustomDomainPayload, S>

  type CustomDomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomDomainFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomDomainCountAggregateInputType | true
    }

  export interface CustomDomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomDomain'], meta: { name: 'CustomDomain' } }
    /**
     * Find zero or one CustomDomain that matches the filter.
     * @param {CustomDomainFindUniqueArgs} args - Arguments to find a CustomDomain
     * @example
     * // Get one CustomDomain
     * const customDomain = await prisma.customDomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomDomainFindUniqueArgs>(args: SelectSubset<T, CustomDomainFindUniqueArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomDomain that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomDomainFindUniqueOrThrowArgs} args - Arguments to find a CustomDomain
     * @example
     * // Get one CustomDomain
     * const customDomain = await prisma.customDomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomDomainFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomDomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomDomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomDomainFindFirstArgs} args - Arguments to find a CustomDomain
     * @example
     * // Get one CustomDomain
     * const customDomain = await prisma.customDomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomDomainFindFirstArgs>(args?: SelectSubset<T, CustomDomainFindFirstArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomDomain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomDomainFindFirstOrThrowArgs} args - Arguments to find a CustomDomain
     * @example
     * // Get one CustomDomain
     * const customDomain = await prisma.customDomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomDomainFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomDomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomDomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomDomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomDomains
     * const customDomains = await prisma.customDomain.findMany()
     * 
     * // Get first 10 CustomDomains
     * const customDomains = await prisma.customDomain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customDomainWithIdOnly = await prisma.customDomain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomDomainFindManyArgs>(args?: SelectSubset<T, CustomDomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomDomain.
     * @param {CustomDomainCreateArgs} args - Arguments to create a CustomDomain.
     * @example
     * // Create one CustomDomain
     * const CustomDomain = await prisma.customDomain.create({
     *   data: {
     *     // ... data to create a CustomDomain
     *   }
     * })
     * 
     */
    create<T extends CustomDomainCreateArgs>(args: SelectSubset<T, CustomDomainCreateArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomDomains.
     * @param {CustomDomainCreateManyArgs} args - Arguments to create many CustomDomains.
     * @example
     * // Create many CustomDomains
     * const customDomain = await prisma.customDomain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomDomainCreateManyArgs>(args?: SelectSubset<T, CustomDomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomDomains and returns the data saved in the database.
     * @param {CustomDomainCreateManyAndReturnArgs} args - Arguments to create many CustomDomains.
     * @example
     * // Create many CustomDomains
     * const customDomain = await prisma.customDomain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomDomains and only return the `id`
     * const customDomainWithIdOnly = await prisma.customDomain.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomDomainCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomDomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomDomain.
     * @param {CustomDomainDeleteArgs} args - Arguments to delete one CustomDomain.
     * @example
     * // Delete one CustomDomain
     * const CustomDomain = await prisma.customDomain.delete({
     *   where: {
     *     // ... filter to delete one CustomDomain
     *   }
     * })
     * 
     */
    delete<T extends CustomDomainDeleteArgs>(args: SelectSubset<T, CustomDomainDeleteArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomDomain.
     * @param {CustomDomainUpdateArgs} args - Arguments to update one CustomDomain.
     * @example
     * // Update one CustomDomain
     * const customDomain = await prisma.customDomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomDomainUpdateArgs>(args: SelectSubset<T, CustomDomainUpdateArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomDomains.
     * @param {CustomDomainDeleteManyArgs} args - Arguments to filter CustomDomains to delete.
     * @example
     * // Delete a few CustomDomains
     * const { count } = await prisma.customDomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomDomainDeleteManyArgs>(args?: SelectSubset<T, CustomDomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomDomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomDomains
     * const customDomain = await prisma.customDomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomDomainUpdateManyArgs>(args: SelectSubset<T, CustomDomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomDomain.
     * @param {CustomDomainUpsertArgs} args - Arguments to update or create a CustomDomain.
     * @example
     * // Update or create a CustomDomain
     * const customDomain = await prisma.customDomain.upsert({
     *   create: {
     *     // ... data to create a CustomDomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomDomain we want to update
     *   }
     * })
     */
    upsert<T extends CustomDomainUpsertArgs>(args: SelectSubset<T, CustomDomainUpsertArgs<ExtArgs>>): Prisma__CustomDomainClient<$Result.GetResult<Prisma.$CustomDomainPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomDomainCountArgs} args - Arguments to filter CustomDomains to count.
     * @example
     * // Count the number of CustomDomains
     * const count = await prisma.customDomain.count({
     *   where: {
     *     // ... the filter for the CustomDomains we want to count
     *   }
     * })
    **/
    count<T extends CustomDomainCountArgs>(
      args?: Subset<T, CustomDomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomDomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomDomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomDomainAggregateArgs>(args: Subset<T, CustomDomainAggregateArgs>): Prisma.PrismaPromise<GetCustomDomainAggregateType<T>>

    /**
     * Group by CustomDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomDomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomDomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomDomainGroupByArgs['orderBy'] }
        : { orderBy?: CustomDomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomDomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomDomain model
   */
  readonly fields: CustomDomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomDomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomDomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomDomain model
   */ 
  interface CustomDomainFieldRefs {
    readonly id: FieldRef<"CustomDomain", 'String'>
    readonly domain: FieldRef<"CustomDomain", 'String'>
    readonly sslStatus: FieldRef<"CustomDomain", 'String'>
    readonly sslCertificate: FieldRef<"CustomDomain", 'String'>
    readonly sslPrivateKey: FieldRef<"CustomDomain", 'String'>
    readonly sslExpiresAt: FieldRef<"CustomDomain", 'DateTime'>
    readonly verificationToken: FieldRef<"CustomDomain", 'String'>
    readonly dnsChallenge: FieldRef<"CustomDomain", 'String'>
    readonly dnsChallengeToken: FieldRef<"CustomDomain", 'String'>
    readonly isVerified: FieldRef<"CustomDomain", 'Boolean'>
    readonly isActive: FieldRef<"CustomDomain", 'Boolean'>
    readonly teamId: FieldRef<"CustomDomain", 'String'>
    readonly createdAt: FieldRef<"CustomDomain", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomDomain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomDomain findUnique
   */
  export type CustomDomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * Filter, which CustomDomain to fetch.
     */
    where: CustomDomainWhereUniqueInput
  }

  /**
   * CustomDomain findUniqueOrThrow
   */
  export type CustomDomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * Filter, which CustomDomain to fetch.
     */
    where: CustomDomainWhereUniqueInput
  }

  /**
   * CustomDomain findFirst
   */
  export type CustomDomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * Filter, which CustomDomain to fetch.
     */
    where?: CustomDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomDomains to fetch.
     */
    orderBy?: CustomDomainOrderByWithRelationInput | CustomDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomDomains.
     */
    cursor?: CustomDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomDomains.
     */
    distinct?: CustomDomainScalarFieldEnum | CustomDomainScalarFieldEnum[]
  }

  /**
   * CustomDomain findFirstOrThrow
   */
  export type CustomDomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * Filter, which CustomDomain to fetch.
     */
    where?: CustomDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomDomains to fetch.
     */
    orderBy?: CustomDomainOrderByWithRelationInput | CustomDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomDomains.
     */
    cursor?: CustomDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomDomains.
     */
    distinct?: CustomDomainScalarFieldEnum | CustomDomainScalarFieldEnum[]
  }

  /**
   * CustomDomain findMany
   */
  export type CustomDomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * Filter, which CustomDomains to fetch.
     */
    where?: CustomDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomDomains to fetch.
     */
    orderBy?: CustomDomainOrderByWithRelationInput | CustomDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomDomains.
     */
    cursor?: CustomDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomDomains.
     */
    skip?: number
    distinct?: CustomDomainScalarFieldEnum | CustomDomainScalarFieldEnum[]
  }

  /**
   * CustomDomain create
   */
  export type CustomDomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomDomain.
     */
    data: XOR<CustomDomainCreateInput, CustomDomainUncheckedCreateInput>
  }

  /**
   * CustomDomain createMany
   */
  export type CustomDomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomDomains.
     */
    data: CustomDomainCreateManyInput | CustomDomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomDomain createManyAndReturn
   */
  export type CustomDomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomDomains.
     */
    data: CustomDomainCreateManyInput | CustomDomainCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomDomain update
   */
  export type CustomDomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomDomain.
     */
    data: XOR<CustomDomainUpdateInput, CustomDomainUncheckedUpdateInput>
    /**
     * Choose, which CustomDomain to update.
     */
    where: CustomDomainWhereUniqueInput
  }

  /**
   * CustomDomain updateMany
   */
  export type CustomDomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomDomains.
     */
    data: XOR<CustomDomainUpdateManyMutationInput, CustomDomainUncheckedUpdateManyInput>
    /**
     * Filter which CustomDomains to update
     */
    where?: CustomDomainWhereInput
  }

  /**
   * CustomDomain upsert
   */
  export type CustomDomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomDomain to update in case it exists.
     */
    where: CustomDomainWhereUniqueInput
    /**
     * In case the CustomDomain found by the `where` argument doesn't exist, create a new CustomDomain with this data.
     */
    create: XOR<CustomDomainCreateInput, CustomDomainUncheckedCreateInput>
    /**
     * In case the CustomDomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomDomainUpdateInput, CustomDomainUncheckedUpdateInput>
  }

  /**
   * CustomDomain delete
   */
  export type CustomDomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
    /**
     * Filter which CustomDomain to delete.
     */
    where: CustomDomainWhereUniqueInput
  }

  /**
   * CustomDomain deleteMany
   */
  export type CustomDomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomDomains to delete
     */
    where?: CustomDomainWhereInput
  }

  /**
   * CustomDomain without action
   */
  export type CustomDomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomDomain
     */
    select?: CustomDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomDomainInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    lastStatus: number | null
    retryCount: number | null
  }

  export type WebhookSumAggregateOutputType = {
    lastStatus: number | null
    retryCount: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    lastStatus: number | null
    lastAttempt: Date | null
    retryCount: number | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    lastStatus: number | null
    lastAttempt: Date | null
    retryCount: number | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    name: number
    url: number
    secret: number
    isActive: number
    createdAt: number
    updatedAt: number
    teamId: number
    lastStatus: number
    lastAttempt: number
    retryCount: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    lastStatus?: true
    retryCount?: true
  }

  export type WebhookSumAggregateInputType = {
    lastStatus?: true
    retryCount?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    lastStatus?: true
    lastAttempt?: true
    retryCount?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    lastStatus?: true
    lastAttempt?: true
    retryCount?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    lastStatus?: true
    lastAttempt?: true
    retryCount?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    name: string
    url: string
    secret: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    teamId: string
    lastStatus: number | null
    lastAttempt: Date | null
    retryCount: number
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    lastStatus?: boolean
    lastAttempt?: boolean
    retryCount?: boolean
    events?: boolean | Webhook$eventsArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    lastStatus?: boolean
    lastAttempt?: boolean
    retryCount?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    lastStatus?: boolean
    lastAttempt?: boolean
    retryCount?: boolean
  }

  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | Webhook$eventsArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      events: Prisma.$WebhookEventPayload<ExtArgs>[]
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      secret: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      teamId: string
      lastStatus: number | null
      lastAttempt: Date | null
      retryCount: number
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends Webhook$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany"> | Null>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */ 
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly name: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
    readonly teamId: FieldRef<"Webhook", 'String'>
    readonly lastStatus: FieldRef<"Webhook", 'Int'>
    readonly lastAttempt: FieldRef<"Webhook", 'DateTime'>
    readonly retryCount: FieldRef<"Webhook", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook.events
   */
  export type Webhook$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    cursor?: WebhookEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    eventType: $Enums.WebhookEventType | null
    webhookId: string | null
    createdAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    eventType: $Enums.WebhookEventType | null
    webhookId: string | null
    createdAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    eventType: number
    webhookId: number
    createdAt: number
    _all: number
  }


  export type WebhookEventMinAggregateInputType = {
    id?: true
    eventType?: true
    webhookId?: true
    createdAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    webhookId?: true
    createdAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    eventType?: true
    webhookId?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    eventType: $Enums.WebhookEventType
    webhookId: string
    createdAt: Date
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    webhookId?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    webhookId?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    webhookId?: boolean
    createdAt?: boolean
  }

  export type WebhookEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: $Enums.WebhookEventType
      webhookId: string
      createdAt: Date
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */ 
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly eventType: FieldRef<"WebhookEvent", 'WebhookEventType'>
    readonly webhookId: FieldRef<"WebhookEvent", 'String'>
    readonly createdAt: FieldRef<"WebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    status: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    status: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    webhookId: string | null
    eventType: $Enums.WebhookEventType | null
    status: number | null
    response: string | null
    error: string | null
    createdAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    webhookId: string | null
    eventType: $Enums.WebhookEventType | null
    status: number | null
    response: string | null
    error: string | null
    createdAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    webhookId: number
    eventType: number
    payload: number
    status: number
    response: number
    error: number
    createdAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    status?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    status?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    webhookId?: true
    eventType?: true
    status?: true
    response?: true
    error?: true
    createdAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    webhookId?: true
    eventType?: true
    status?: true
    response?: true
    error?: true
    createdAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    webhookId?: true
    eventType?: true
    payload?: true
    status?: true
    response?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    webhookId: string
    eventType: $Enums.WebhookEventType
    payload: JsonValue
    status: number
    response: string | null
    error: string | null
    createdAt: Date
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    response?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    response?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    webhookId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    response?: boolean
    error?: boolean
    createdAt?: boolean
  }


  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      webhookId: string
      eventType: $Enums.WebhookEventType
      payload: Prisma.JsonValue
      status: number
      response: string | null
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */ 
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'String'>
    readonly eventType: FieldRef<"WebhookDelivery", 'WebhookEventType'>
    readonly payload: FieldRef<"WebhookDelivery", 'Json'>
    readonly status: FieldRef<"WebhookDelivery", 'Int'>
    readonly response: FieldRef<"WebhookDelivery", 'String'>
    readonly error: FieldRef<"WebhookDelivery", 'String'>
    readonly createdAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    content: 'content',
    variables: 'variables',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teamId: 'teamId',
    categoryId: 'categoryId',
    html: 'html',
    design: 'design'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    teamId: 'teamId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailTemplateId: 'emailTemplateId'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamInviteScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    inviterId: 'inviterId',
    status: 'status',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    name: 'name'
  };

  export type TeamInviteScalarFieldEnum = (typeof TeamInviteScalarFieldEnum)[keyof typeof TeamInviteScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    teamId: 'teamId',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    scopes: 'scopes',
    rateLimit: 'rateLimit',
    isActive: 'isActive'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const ApiKeyUsageScalarFieldEnum: {
    id: 'id',
    apiKeyId: 'apiKeyId',
    endpoint: 'endpoint',
    method: 'method',
    timestamp: 'timestamp',
    success: 'success',
    error: 'error',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type ApiKeyUsageScalarFieldEnum = (typeof ApiKeyUsageScalarFieldEnum)[keyof typeof ApiKeyUsageScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    templateId: 'templateId',
    teamId: 'teamId',
    status: 'status',
    scheduledFor: 'scheduledFor',
    schedule: 'schedule',
    listId: 'listId',
    recurringSchedule: 'recurringSchedule',
    cronExpression: 'cronExpression',
    smtpConfigId: 'smtpConfigId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const MailingListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    teamId: 'teamId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MailingListScalarFieldEnum = (typeof MailingListScalarFieldEnum)[keyof typeof MailingListScalarFieldEnum]


  export const SubscriberScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    company: 'company',
    title: 'title',
    address: 'address',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    metadata: 'metadata',
    tags: 'tags',
    customFields: 'customFields',
    source: 'source',
    listId: 'listId',
    status: 'status',
    unsubscribedAt: 'unsubscribedAt',
    lastActivityAt: 'lastActivityAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriberScalarFieldEnum = (typeof SubscriberScalarFieldEnum)[keyof typeof SubscriberScalarFieldEnum]


  export const SentEmailScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    campaignId: 'campaignId',
    recipient: 'recipient',
    subject: 'subject',
    content: 'content',
    status: 'status',
    sentAt: 'sentAt',
    openedAt: 'openedAt',
    clickedAt: 'clickedAt',
    teamId: 'teamId',
    error: 'error',
    metadata: 'metadata',
    jobId: 'jobId',
    subscriberId: 'subscriberId'
  };

  export type SentEmailScalarFieldEnum = (typeof SentEmailScalarFieldEnum)[keyof typeof SentEmailScalarFieldEnum]


  export const EmailTrackingScalarFieldEnum: {
    id: 'id',
    sentEmailId: 'sentEmailId',
    type: 'type',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type EmailTrackingScalarFieldEnum = (typeof EmailTrackingScalarFieldEnum)[keyof typeof EmailTrackingScalarFieldEnum]


  export const EmailJobScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    status: 'status',
    totalEmails: 'totalEmails',
    processedEmails: 'processedEmails',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailJobScalarFieldEnum = (typeof EmailJobScalarFieldEnum)[keyof typeof EmailJobScalarFieldEnum]


  export const EmailJobLogScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    level: 'level',
    message: 'message',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type EmailJobLogScalarFieldEnum = (typeof EmailJobLogScalarFieldEnum)[keyof typeof EmailJobLogScalarFieldEnum]


  export const CampaignAnalyticsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    sentCount: 'sentCount',
    openCount: 'openCount',
    clickCount: 'clickCount',
    bounceCount: 'bounceCount',
    unsubscribeCount: 'unsubscribeCount',
    lastUpdated: 'lastUpdated'
  };

  export type CampaignAnalyticsScalarFieldEnum = (typeof CampaignAnalyticsScalarFieldEnum)[keyof typeof CampaignAnalyticsScalarFieldEnum]


  export const EmailCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailCategoryScalarFieldEnum = (typeof EmailCategoryScalarFieldEnum)[keyof typeof EmailCategoryScalarFieldEnum]


  export const SmtpConfigScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    host: 'host',
    port: 'port',
    username: 'username',
    password: 'password',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teamId: 'teamId'
  };

  export type SmtpConfigScalarFieldEnum = (typeof SmtpConfigScalarFieldEnum)[keyof typeof SmtpConfigScalarFieldEnum]


  export const AutomationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive',
    teamId: 'teamId'
  };

  export type AutomationScalarFieldEnum = (typeof AutomationScalarFieldEnum)[keyof typeof AutomationScalarFieldEnum]


  export const AutomationNodeScalarFieldEnum: {
    id: 'id',
    automationId: 'automationId',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    data: 'data'
  };

  export type AutomationNodeScalarFieldEnum = (typeof AutomationNodeScalarFieldEnum)[keyof typeof AutomationNodeScalarFieldEnum]


  export const AutomationNodeEdgeScalarFieldEnum: {
    id: 'id',
    automationId: 'automationId',
    sourceId: 'sourceId',
    targetId: 'targetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    label: 'label',
    animated: 'animated'
  };

  export type AutomationNodeEdgeScalarFieldEnum = (typeof AutomationNodeEdgeScalarFieldEnum)[keyof typeof AutomationNodeEdgeScalarFieldEnum]


  export const CustomDomainScalarFieldEnum: {
    id: 'id',
    domain: 'domain',
    sslStatus: 'sslStatus',
    sslCertificate: 'sslCertificate',
    sslPrivateKey: 'sslPrivateKey',
    sslExpiresAt: 'sslExpiresAt',
    verificationToken: 'verificationToken',
    dnsChallenge: 'dnsChallenge',
    dnsChallengeToken: 'dnsChallengeToken',
    isVerified: 'isVerified',
    isActive: 'isActive',
    teamId: 'teamId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomDomainScalarFieldEnum = (typeof CustomDomainScalarFieldEnum)[keyof typeof CustomDomainScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    secret: 'secret',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teamId: 'teamId',
    lastStatus: 'lastStatus',
    lastAttempt: 'lastAttempt',
    retryCount: 'retryCount'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    webhookId: 'webhookId',
    createdAt: 'createdAt'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    eventType: 'eventType',
    payload: 'payload',
    status: 'status',
    response: 'response',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus'>
    


  /**
   * Reference to a field of type 'InviteStatus[]'
   */
  export type ListEnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'CampaignSchedule'
   */
  export type EnumCampaignScheduleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignSchedule'>
    


  /**
   * Reference to a field of type 'CampaignSchedule[]'
   */
  export type ListEnumCampaignScheduleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignSchedule[]'>
    


  /**
   * Reference to a field of type 'CampaignRecurringSchedule'
   */
  export type EnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignRecurringSchedule'>
    


  /**
   * Reference to a field of type 'CampaignRecurringSchedule[]'
   */
  export type ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignRecurringSchedule[]'>
    


  /**
   * Reference to a field of type 'SubscriberStatus'
   */
  export type EnumSubscriberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriberStatus'>
    


  /**
   * Reference to a field of type 'SubscriberStatus[]'
   */
  export type ListEnumSubscriberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriberStatus[]'>
    


  /**
   * Reference to a field of type 'EmailStatus'
   */
  export type EnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus'>
    


  /**
   * Reference to a field of type 'EmailStatus[]'
   */
  export type ListEnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus[]'>
    


  /**
   * Reference to a field of type 'TrackingType'
   */
  export type EnumTrackingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackingType'>
    


  /**
   * Reference to a field of type 'TrackingType[]'
   */
  export type ListEnumTrackingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackingType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'LogLevel'
   */
  export type EnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel'>
    


  /**
   * Reference to a field of type 'LogLevel[]'
   */
  export type ListEnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel[]'>
    


  /**
   * Reference to a field of type 'NodeType'
   */
  export type EnumNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeType'>
    


  /**
   * Reference to a field of type 'NodeType[]'
   */
  export type ListEnumNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeType[]'>
    


  /**
   * Reference to a field of type 'WebhookEventType'
   */
  export type EnumWebhookEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEventType'>
    


  /**
   * Reference to a field of type 'WebhookEventType[]'
   */
  export type ListEnumWebhookEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEventType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    content?: StringNullableFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    teamId?: StringFilter<"EmailTemplate"> | string
    categoryId?: StringFilter<"EmailTemplate"> | string
    html?: StringNullableFilter<"EmailTemplate"> | string | null
    design?: JsonNullableFilter<"EmailTemplate">
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    campaigns?: CampaignListRelationFilter
    sentEmails?: SentEmailListRelationFilter
    category?: XOR<EmailCategoryScalarRelationFilter, EmailCategoryWhereInput>
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrderInput | SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    html?: SortOrderInput | SortOrder
    design?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
    sentEmails?: SentEmailOrderByRelationAggregateInput
    category?: EmailCategoryOrderByWithRelationInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    content?: StringNullableFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    teamId?: StringFilter<"EmailTemplate"> | string
    categoryId?: StringFilter<"EmailTemplate"> | string
    html?: StringNullableFilter<"EmailTemplate"> | string | null
    design?: JsonNullableFilter<"EmailTemplate">
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    campaigns?: CampaignListRelationFilter
    sentEmails?: SentEmailListRelationFilter
    category?: XOR<EmailCategoryScalarRelationFilter, EmailCategoryWhereInput>
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrderInput | SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    html?: SortOrderInput | SortOrder
    design?: SortOrderInput | SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    content?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    teamId?: StringWithAggregatesFilter<"EmailTemplate"> | string
    categoryId?: StringWithAggregatesFilter<"EmailTemplate"> | string
    html?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    design?: JsonNullableWithAggregatesFilter<"EmailTemplate">
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    teamId?: StringNullableFilter<"User"> | string | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    invitesSent?: TeamInviteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    teamId?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    invitesSent?: TeamInviteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    teamId?: StringNullableFilter<"User"> | string | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    invitesSent?: TeamInviteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    teamId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    teamId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    emailTemplateId?: StringNullableFilter<"Team"> | string | null
    users?: UserListRelationFilter
    invites?: TeamInviteListRelationFilter
    templates?: EmailTemplateListRelationFilter
    lists?: MailingListListRelationFilter
    automations?: AutomationListRelationFilter
    campaigns?: CampaignListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    smtpConfigs?: SmtpConfigListRelationFilter
    sentEmails?: SentEmailListRelationFilter
    customDomains?: CustomDomainListRelationFilter
    webhooks?: WebhookListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    invites?: TeamInviteOrderByRelationAggregateInput
    templates?: EmailTemplateOrderByRelationAggregateInput
    lists?: MailingListOrderByRelationAggregateInput
    automations?: AutomationOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    smtpConfigs?: SmtpConfigOrderByRelationAggregateInput
    sentEmails?: SentEmailOrderByRelationAggregateInput
    customDomains?: CustomDomainOrderByRelationAggregateInput
    webhooks?: WebhookOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    emailTemplateId?: StringNullableFilter<"Team"> | string | null
    users?: UserListRelationFilter
    invites?: TeamInviteListRelationFilter
    templates?: EmailTemplateListRelationFilter
    lists?: MailingListListRelationFilter
    automations?: AutomationListRelationFilter
    campaigns?: CampaignListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    smtpConfigs?: SmtpConfigListRelationFilter
    sentEmails?: SentEmailListRelationFilter
    customDomains?: CustomDomainListRelationFilter
    webhooks?: WebhookListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    emailTemplateId?: StringNullableWithAggregatesFilter<"Team"> | string | null
  }

  export type TeamInviteWhereInput = {
    AND?: TeamInviteWhereInput | TeamInviteWhereInput[]
    OR?: TeamInviteWhereInput[]
    NOT?: TeamInviteWhereInput | TeamInviteWhereInput[]
    id?: StringFilter<"TeamInvite"> | string
    teamId?: StringFilter<"TeamInvite"> | string
    inviterId?: StringFilter<"TeamInvite"> | string
    status?: EnumInviteStatusFilter<"TeamInvite"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"TeamInvite"> | Date | string
    createdAt?: DateTimeFilter<"TeamInvite"> | Date | string
    updatedAt?: DateTimeFilter<"TeamInvite"> | Date | string
    email?: StringFilter<"TeamInvite"> | string
    name?: StringFilter<"TeamInvite"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamInviteOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    inviterId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    team?: TeamOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
  }

  export type TeamInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamInviteWhereInput | TeamInviteWhereInput[]
    OR?: TeamInviteWhereInput[]
    NOT?: TeamInviteWhereInput | TeamInviteWhereInput[]
    teamId?: StringFilter<"TeamInvite"> | string
    inviterId?: StringFilter<"TeamInvite"> | string
    status?: EnumInviteStatusFilter<"TeamInvite"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"TeamInvite"> | Date | string
    createdAt?: DateTimeFilter<"TeamInvite"> | Date | string
    updatedAt?: DateTimeFilter<"TeamInvite"> | Date | string
    email?: StringFilter<"TeamInvite"> | string
    name?: StringFilter<"TeamInvite"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TeamInviteOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    inviterId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    _count?: TeamInviteCountOrderByAggregateInput
    _max?: TeamInviteMaxOrderByAggregateInput
    _min?: TeamInviteMinOrderByAggregateInput
  }

  export type TeamInviteScalarWhereWithAggregatesInput = {
    AND?: TeamInviteScalarWhereWithAggregatesInput | TeamInviteScalarWhereWithAggregatesInput[]
    OR?: TeamInviteScalarWhereWithAggregatesInput[]
    NOT?: TeamInviteScalarWhereWithAggregatesInput | TeamInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamInvite"> | string
    teamId?: StringWithAggregatesFilter<"TeamInvite"> | string
    inviterId?: StringWithAggregatesFilter<"TeamInvite"> | string
    status?: EnumInviteStatusWithAggregatesFilter<"TeamInvite"> | $Enums.InviteStatus
    expiresAt?: DateTimeWithAggregatesFilter<"TeamInvite"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TeamInvite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamInvite"> | Date | string
    email?: StringWithAggregatesFilter<"TeamInvite"> | string
    name?: StringWithAggregatesFilter<"TeamInvite"> | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    teamId?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    scopes?: StringNullableListFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    isActive?: BoolFilter<"ApiKey"> | boolean
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    usageStats?: ApiKeyUsageListRelationFilter
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    teamId?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
    team?: TeamOrderByWithRelationInput
    usageStats?: ApiKeyUsageOrderByRelationAggregateInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    name?: StringFilter<"ApiKey"> | string
    teamId?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    scopes?: StringNullableListFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    isActive?: BoolFilter<"ApiKey"> | boolean
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    usageStats?: ApiKeyUsageListRelationFilter
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    teamId?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    teamId?: StringWithAggregatesFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    scopes?: StringNullableListFilter<"ApiKey">
    rateLimit?: IntWithAggregatesFilter<"ApiKey"> | number
    isActive?: BoolWithAggregatesFilter<"ApiKey"> | boolean
  }

  export type ApiKeyUsageWhereInput = {
    AND?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    OR?: ApiKeyUsageWhereInput[]
    NOT?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    id?: StringFilter<"ApiKeyUsage"> | string
    apiKeyId?: StringFilter<"ApiKeyUsage"> | string
    endpoint?: StringFilter<"ApiKeyUsage"> | string
    method?: StringFilter<"ApiKeyUsage"> | string
    timestamp?: DateTimeFilter<"ApiKeyUsage"> | Date | string
    success?: BoolFilter<"ApiKeyUsage"> | boolean
    error?: StringNullableFilter<"ApiKeyUsage"> | string | null
    ipAddress?: StringNullableFilter<"ApiKeyUsage"> | string | null
    userAgent?: StringNullableFilter<"ApiKeyUsage"> | string | null
    apiKey?: XOR<ApiKeyScalarRelationFilter, ApiKeyWhereInput>
  }

  export type ApiKeyUsageOrderByWithRelationInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    timestamp?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    apiKey?: ApiKeyOrderByWithRelationInput
  }

  export type ApiKeyUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    OR?: ApiKeyUsageWhereInput[]
    NOT?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    apiKeyId?: StringFilter<"ApiKeyUsage"> | string
    endpoint?: StringFilter<"ApiKeyUsage"> | string
    method?: StringFilter<"ApiKeyUsage"> | string
    timestamp?: DateTimeFilter<"ApiKeyUsage"> | Date | string
    success?: BoolFilter<"ApiKeyUsage"> | boolean
    error?: StringNullableFilter<"ApiKeyUsage"> | string | null
    ipAddress?: StringNullableFilter<"ApiKeyUsage"> | string | null
    userAgent?: StringNullableFilter<"ApiKeyUsage"> | string | null
    apiKey?: XOR<ApiKeyScalarRelationFilter, ApiKeyWhereInput>
  }, "id">

  export type ApiKeyUsageOrderByWithAggregationInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    timestamp?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: ApiKeyUsageCountOrderByAggregateInput
    _max?: ApiKeyUsageMaxOrderByAggregateInput
    _min?: ApiKeyUsageMinOrderByAggregateInput
  }

  export type ApiKeyUsageScalarWhereWithAggregatesInput = {
    AND?: ApiKeyUsageScalarWhereWithAggregatesInput | ApiKeyUsageScalarWhereWithAggregatesInput[]
    OR?: ApiKeyUsageScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyUsageScalarWhereWithAggregatesInput | ApiKeyUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKeyUsage"> | string
    apiKeyId?: StringWithAggregatesFilter<"ApiKeyUsage"> | string
    endpoint?: StringWithAggregatesFilter<"ApiKeyUsage"> | string
    method?: StringWithAggregatesFilter<"ApiKeyUsage"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ApiKeyUsage"> | Date | string
    success?: BoolWithAggregatesFilter<"ApiKeyUsage"> | boolean
    error?: StringNullableWithAggregatesFilter<"ApiKeyUsage"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ApiKeyUsage"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ApiKeyUsage"> | string | null
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    templateId?: StringFilter<"Campaign"> | string
    teamId?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    schedule?: EnumCampaignScheduleNullableFilter<"Campaign"> | $Enums.CampaignSchedule | null
    listId?: StringFilter<"Campaign"> | string
    recurringSchedule?: EnumCampaignRecurringScheduleNullableFilter<"Campaign"> | $Enums.CampaignRecurringSchedule | null
    cronExpression?: StringNullableFilter<"Campaign"> | string | null
    smtpConfigId?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    template?: XOR<EmailTemplateScalarRelationFilter, EmailTemplateWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    mailingList?: XOR<MailingListScalarRelationFilter, MailingListWhereInput>
    sentEmails?: SentEmailListRelationFilter
    analytics?: XOR<CampaignAnalyticsNullableScalarRelationFilter, CampaignAnalyticsWhereInput> | null
    smtpConfig?: XOR<SmtpConfigNullableScalarRelationFilter, SmtpConfigWhereInput> | null
    emailJobs?: EmailJobListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    templateId?: SortOrder
    teamId?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    listId?: SortOrder
    recurringSchedule?: SortOrderInput | SortOrder
    cronExpression?: SortOrderInput | SortOrder
    smtpConfigId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    template?: EmailTemplateOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    mailingList?: MailingListOrderByWithRelationInput
    sentEmails?: SentEmailOrderByRelationAggregateInput
    analytics?: CampaignAnalyticsOrderByWithRelationInput
    smtpConfig?: SmtpConfigOrderByWithRelationInput
    emailJobs?: EmailJobOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    templateId?: StringFilter<"Campaign"> | string
    teamId?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    schedule?: EnumCampaignScheduleNullableFilter<"Campaign"> | $Enums.CampaignSchedule | null
    listId?: StringFilter<"Campaign"> | string
    recurringSchedule?: EnumCampaignRecurringScheduleNullableFilter<"Campaign"> | $Enums.CampaignRecurringSchedule | null
    cronExpression?: StringNullableFilter<"Campaign"> | string | null
    smtpConfigId?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    template?: XOR<EmailTemplateScalarRelationFilter, EmailTemplateWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    mailingList?: XOR<MailingListScalarRelationFilter, MailingListWhereInput>
    sentEmails?: SentEmailListRelationFilter
    analytics?: XOR<CampaignAnalyticsNullableScalarRelationFilter, CampaignAnalyticsWhereInput> | null
    smtpConfig?: XOR<SmtpConfigNullableScalarRelationFilter, SmtpConfigWhereInput> | null
    emailJobs?: EmailJobListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    templateId?: SortOrder
    teamId?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    listId?: SortOrder
    recurringSchedule?: SortOrderInput | SortOrder
    cronExpression?: SortOrderInput | SortOrder
    smtpConfigId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    templateId?: StringWithAggregatesFilter<"Campaign"> | string
    teamId?: StringWithAggregatesFilter<"Campaign"> | string
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    schedule?: EnumCampaignScheduleNullableWithAggregatesFilter<"Campaign"> | $Enums.CampaignSchedule | null
    listId?: StringWithAggregatesFilter<"Campaign"> | string
    recurringSchedule?: EnumCampaignRecurringScheduleNullableWithAggregatesFilter<"Campaign"> | $Enums.CampaignRecurringSchedule | null
    cronExpression?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    smtpConfigId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type MailingListWhereInput = {
    AND?: MailingListWhereInput | MailingListWhereInput[]
    OR?: MailingListWhereInput[]
    NOT?: MailingListWhereInput | MailingListWhereInput[]
    id?: StringFilter<"MailingList"> | string
    name?: StringFilter<"MailingList"> | string
    description?: StringNullableFilter<"MailingList"> | string | null
    teamId?: StringFilter<"MailingList"> | string
    createdAt?: DateTimeFilter<"MailingList"> | Date | string
    updatedAt?: DateTimeFilter<"MailingList"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    subscribers?: SubscriberListRelationFilter
    campaigns?: CampaignListRelationFilter
  }

  export type MailingListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    subscribers?: SubscriberOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type MailingListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MailingListWhereInput | MailingListWhereInput[]
    OR?: MailingListWhereInput[]
    NOT?: MailingListWhereInput | MailingListWhereInput[]
    name?: StringFilter<"MailingList"> | string
    description?: StringNullableFilter<"MailingList"> | string | null
    teamId?: StringFilter<"MailingList"> | string
    createdAt?: DateTimeFilter<"MailingList"> | Date | string
    updatedAt?: DateTimeFilter<"MailingList"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    subscribers?: SubscriberListRelationFilter
    campaigns?: CampaignListRelationFilter
  }, "id">

  export type MailingListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MailingListCountOrderByAggregateInput
    _max?: MailingListMaxOrderByAggregateInput
    _min?: MailingListMinOrderByAggregateInput
  }

  export type MailingListScalarWhereWithAggregatesInput = {
    AND?: MailingListScalarWhereWithAggregatesInput | MailingListScalarWhereWithAggregatesInput[]
    OR?: MailingListScalarWhereWithAggregatesInput[]
    NOT?: MailingListScalarWhereWithAggregatesInput | MailingListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MailingList"> | string
    name?: StringWithAggregatesFilter<"MailingList"> | string
    description?: StringNullableWithAggregatesFilter<"MailingList"> | string | null
    teamId?: StringWithAggregatesFilter<"MailingList"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MailingList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MailingList"> | Date | string
  }

  export type SubscriberWhereInput = {
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    id?: StringFilter<"Subscriber"> | string
    email?: StringFilter<"Subscriber"> | string
    firstName?: StringNullableFilter<"Subscriber"> | string | null
    lastName?: StringNullableFilter<"Subscriber"> | string | null
    phone?: StringNullableFilter<"Subscriber"> | string | null
    company?: StringNullableFilter<"Subscriber"> | string | null
    title?: StringNullableFilter<"Subscriber"> | string | null
    address?: StringNullableFilter<"Subscriber"> | string | null
    addressLine2?: StringNullableFilter<"Subscriber"> | string | null
    city?: StringNullableFilter<"Subscriber"> | string | null
    state?: StringNullableFilter<"Subscriber"> | string | null
    postalCode?: StringNullableFilter<"Subscriber"> | string | null
    country?: StringNullableFilter<"Subscriber"> | string | null
    metadata?: JsonNullableFilter<"Subscriber">
    tags?: StringNullableListFilter<"Subscriber">
    customFields?: JsonNullableFilter<"Subscriber">
    source?: StringNullableFilter<"Subscriber"> | string | null
    listId?: StringFilter<"Subscriber"> | string
    status?: EnumSubscriberStatusFilter<"Subscriber"> | $Enums.SubscriberStatus
    unsubscribedAt?: DateTimeNullableFilter<"Subscriber"> | Date | string | null
    lastActivityAt?: DateTimeNullableFilter<"Subscriber"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriber"> | Date | string
    mailingList?: XOR<MailingListScalarRelationFilter, MailingListWhereInput>
    sentEmails?: SentEmailListRelationFilter
  }

  export type SubscriberOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    tags?: SortOrder
    customFields?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    listId?: SortOrder
    status?: SortOrder
    unsubscribedAt?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mailingList?: MailingListOrderByWithRelationInput
    sentEmails?: SentEmailOrderByRelationAggregateInput
  }

  export type SubscriberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email_listId?: SubscriberEmailListIdCompoundUniqueInput
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    email?: StringFilter<"Subscriber"> | string
    firstName?: StringNullableFilter<"Subscriber"> | string | null
    lastName?: StringNullableFilter<"Subscriber"> | string | null
    phone?: StringNullableFilter<"Subscriber"> | string | null
    company?: StringNullableFilter<"Subscriber"> | string | null
    title?: StringNullableFilter<"Subscriber"> | string | null
    address?: StringNullableFilter<"Subscriber"> | string | null
    addressLine2?: StringNullableFilter<"Subscriber"> | string | null
    city?: StringNullableFilter<"Subscriber"> | string | null
    state?: StringNullableFilter<"Subscriber"> | string | null
    postalCode?: StringNullableFilter<"Subscriber"> | string | null
    country?: StringNullableFilter<"Subscriber"> | string | null
    metadata?: JsonNullableFilter<"Subscriber">
    tags?: StringNullableListFilter<"Subscriber">
    customFields?: JsonNullableFilter<"Subscriber">
    source?: StringNullableFilter<"Subscriber"> | string | null
    listId?: StringFilter<"Subscriber"> | string
    status?: EnumSubscriberStatusFilter<"Subscriber"> | $Enums.SubscriberStatus
    unsubscribedAt?: DateTimeNullableFilter<"Subscriber"> | Date | string | null
    lastActivityAt?: DateTimeNullableFilter<"Subscriber"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriber"> | Date | string
    mailingList?: XOR<MailingListScalarRelationFilter, MailingListWhereInput>
    sentEmails?: SentEmailListRelationFilter
  }, "id" | "email_listId">

  export type SubscriberOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    tags?: SortOrder
    customFields?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    listId?: SortOrder
    status?: SortOrder
    unsubscribedAt?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriberCountOrderByAggregateInput
    _max?: SubscriberMaxOrderByAggregateInput
    _min?: SubscriberMinOrderByAggregateInput
  }

  export type SubscriberScalarWhereWithAggregatesInput = {
    AND?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    OR?: SubscriberScalarWhereWithAggregatesInput[]
    NOT?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscriber"> | string
    email?: StringWithAggregatesFilter<"Subscriber"> | string
    firstName?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    company?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    title?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    address?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    city?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    state?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    country?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Subscriber">
    tags?: StringNullableListFilter<"Subscriber">
    customFields?: JsonNullableWithAggregatesFilter<"Subscriber">
    source?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    listId?: StringWithAggregatesFilter<"Subscriber"> | string
    status?: EnumSubscriberStatusWithAggregatesFilter<"Subscriber"> | $Enums.SubscriberStatus
    unsubscribedAt?: DateTimeNullableWithAggregatesFilter<"Subscriber"> | Date | string | null
    lastActivityAt?: DateTimeNullableWithAggregatesFilter<"Subscriber"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscriber"> | Date | string
  }

  export type SentEmailWhereInput = {
    AND?: SentEmailWhereInput | SentEmailWhereInput[]
    OR?: SentEmailWhereInput[]
    NOT?: SentEmailWhereInput | SentEmailWhereInput[]
    id?: StringFilter<"SentEmail"> | string
    templateId?: StringNullableFilter<"SentEmail"> | string | null
    campaignId?: StringNullableFilter<"SentEmail"> | string | null
    recipient?: StringFilter<"SentEmail"> | string
    subject?: StringFilter<"SentEmail"> | string
    content?: StringNullableFilter<"SentEmail"> | string | null
    status?: EnumEmailStatusFilter<"SentEmail"> | $Enums.EmailStatus
    sentAt?: DateTimeFilter<"SentEmail"> | Date | string
    openedAt?: DateTimeNullableFilter<"SentEmail"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"SentEmail"> | Date | string | null
    teamId?: StringFilter<"SentEmail"> | string
    error?: StringNullableFilter<"SentEmail"> | string | null
    metadata?: JsonNullableFilter<"SentEmail">
    jobId?: StringNullableFilter<"SentEmail"> | string | null
    subscriberId?: StringNullableFilter<"SentEmail"> | string | null
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    emailJob?: XOR<EmailJobNullableScalarRelationFilter, EmailJobWhereInput> | null
    subscriber?: XOR<SubscriberNullableScalarRelationFilter, SubscriberWhereInput> | null
    tracking?: EmailTrackingListRelationFilter
  }

  export type SentEmailOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    teamId?: SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    template?: EmailTemplateOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    emailJob?: EmailJobOrderByWithRelationInput
    subscriber?: SubscriberOrderByWithRelationInput
    tracking?: EmailTrackingOrderByRelationAggregateInput
  }

  export type SentEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SentEmailWhereInput | SentEmailWhereInput[]
    OR?: SentEmailWhereInput[]
    NOT?: SentEmailWhereInput | SentEmailWhereInput[]
    templateId?: StringNullableFilter<"SentEmail"> | string | null
    campaignId?: StringNullableFilter<"SentEmail"> | string | null
    recipient?: StringFilter<"SentEmail"> | string
    subject?: StringFilter<"SentEmail"> | string
    content?: StringNullableFilter<"SentEmail"> | string | null
    status?: EnumEmailStatusFilter<"SentEmail"> | $Enums.EmailStatus
    sentAt?: DateTimeFilter<"SentEmail"> | Date | string
    openedAt?: DateTimeNullableFilter<"SentEmail"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"SentEmail"> | Date | string | null
    teamId?: StringFilter<"SentEmail"> | string
    error?: StringNullableFilter<"SentEmail"> | string | null
    metadata?: JsonNullableFilter<"SentEmail">
    jobId?: StringNullableFilter<"SentEmail"> | string | null
    subscriberId?: StringNullableFilter<"SentEmail"> | string | null
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    emailJob?: XOR<EmailJobNullableScalarRelationFilter, EmailJobWhereInput> | null
    subscriber?: XOR<SubscriberNullableScalarRelationFilter, SubscriberWhereInput> | null
    tracking?: EmailTrackingListRelationFilter
  }, "id">

  export type SentEmailOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    teamId?: SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    _count?: SentEmailCountOrderByAggregateInput
    _max?: SentEmailMaxOrderByAggregateInput
    _min?: SentEmailMinOrderByAggregateInput
  }

  export type SentEmailScalarWhereWithAggregatesInput = {
    AND?: SentEmailScalarWhereWithAggregatesInput | SentEmailScalarWhereWithAggregatesInput[]
    OR?: SentEmailScalarWhereWithAggregatesInput[]
    NOT?: SentEmailScalarWhereWithAggregatesInput | SentEmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SentEmail"> | string
    templateId?: StringNullableWithAggregatesFilter<"SentEmail"> | string | null
    campaignId?: StringNullableWithAggregatesFilter<"SentEmail"> | string | null
    recipient?: StringWithAggregatesFilter<"SentEmail"> | string
    subject?: StringWithAggregatesFilter<"SentEmail"> | string
    content?: StringNullableWithAggregatesFilter<"SentEmail"> | string | null
    status?: EnumEmailStatusWithAggregatesFilter<"SentEmail"> | $Enums.EmailStatus
    sentAt?: DateTimeWithAggregatesFilter<"SentEmail"> | Date | string
    openedAt?: DateTimeNullableWithAggregatesFilter<"SentEmail"> | Date | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"SentEmail"> | Date | string | null
    teamId?: StringWithAggregatesFilter<"SentEmail"> | string
    error?: StringNullableWithAggregatesFilter<"SentEmail"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SentEmail">
    jobId?: StringNullableWithAggregatesFilter<"SentEmail"> | string | null
    subscriberId?: StringNullableWithAggregatesFilter<"SentEmail"> | string | null
  }

  export type EmailTrackingWhereInput = {
    AND?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    OR?: EmailTrackingWhereInput[]
    NOT?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    id?: StringFilter<"EmailTracking"> | string
    sentEmailId?: StringFilter<"EmailTracking"> | string
    type?: EnumTrackingTypeFilter<"EmailTracking"> | $Enums.TrackingType
    data?: JsonNullableFilter<"EmailTracking">
    createdAt?: DateTimeFilter<"EmailTracking"> | Date | string
    sentEmail?: XOR<SentEmailScalarRelationFilter, SentEmailWhereInput>
  }

  export type EmailTrackingOrderByWithRelationInput = {
    id?: SortOrder
    sentEmailId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sentEmail?: SentEmailOrderByWithRelationInput
  }

  export type EmailTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    OR?: EmailTrackingWhereInput[]
    NOT?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    sentEmailId?: StringFilter<"EmailTracking"> | string
    type?: EnumTrackingTypeFilter<"EmailTracking"> | $Enums.TrackingType
    data?: JsonNullableFilter<"EmailTracking">
    createdAt?: DateTimeFilter<"EmailTracking"> | Date | string
    sentEmail?: XOR<SentEmailScalarRelationFilter, SentEmailWhereInput>
  }, "id">

  export type EmailTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    sentEmailId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailTrackingCountOrderByAggregateInput
    _max?: EmailTrackingMaxOrderByAggregateInput
    _min?: EmailTrackingMinOrderByAggregateInput
  }

  export type EmailTrackingScalarWhereWithAggregatesInput = {
    AND?: EmailTrackingScalarWhereWithAggregatesInput | EmailTrackingScalarWhereWithAggregatesInput[]
    OR?: EmailTrackingScalarWhereWithAggregatesInput[]
    NOT?: EmailTrackingScalarWhereWithAggregatesInput | EmailTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTracking"> | string
    sentEmailId?: StringWithAggregatesFilter<"EmailTracking"> | string
    type?: EnumTrackingTypeWithAggregatesFilter<"EmailTracking"> | $Enums.TrackingType
    data?: JsonNullableWithAggregatesFilter<"EmailTracking">
    createdAt?: DateTimeWithAggregatesFilter<"EmailTracking"> | Date | string
  }

  export type EmailJobWhereInput = {
    AND?: EmailJobWhereInput | EmailJobWhereInput[]
    OR?: EmailJobWhereInput[]
    NOT?: EmailJobWhereInput | EmailJobWhereInput[]
    id?: StringFilter<"EmailJob"> | string
    campaignId?: StringNullableFilter<"EmailJob"> | string | null
    status?: EnumJobStatusFilter<"EmailJob"> | $Enums.JobStatus
    totalEmails?: IntFilter<"EmailJob"> | number
    processedEmails?: IntFilter<"EmailJob"> | number
    startedAt?: DateTimeNullableFilter<"EmailJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"EmailJob"> | Date | string | null
    error?: StringNullableFilter<"EmailJob"> | string | null
    createdAt?: DateTimeFilter<"EmailJob"> | Date | string
    updatedAt?: DateTimeFilter<"EmailJob"> | Date | string
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    sentEmails?: SentEmailListRelationFilter
    logs?: EmailJobLogListRelationFilter
  }

  export type EmailJobOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    status?: SortOrder
    totalEmails?: SortOrder
    processedEmails?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    sentEmails?: SentEmailOrderByRelationAggregateInput
    logs?: EmailJobLogOrderByRelationAggregateInput
  }

  export type EmailJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailJobWhereInput | EmailJobWhereInput[]
    OR?: EmailJobWhereInput[]
    NOT?: EmailJobWhereInput | EmailJobWhereInput[]
    campaignId?: StringNullableFilter<"EmailJob"> | string | null
    status?: EnumJobStatusFilter<"EmailJob"> | $Enums.JobStatus
    totalEmails?: IntFilter<"EmailJob"> | number
    processedEmails?: IntFilter<"EmailJob"> | number
    startedAt?: DateTimeNullableFilter<"EmailJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"EmailJob"> | Date | string | null
    error?: StringNullableFilter<"EmailJob"> | string | null
    createdAt?: DateTimeFilter<"EmailJob"> | Date | string
    updatedAt?: DateTimeFilter<"EmailJob"> | Date | string
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    sentEmails?: SentEmailListRelationFilter
    logs?: EmailJobLogListRelationFilter
  }, "id">

  export type EmailJobOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    status?: SortOrder
    totalEmails?: SortOrder
    processedEmails?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailJobCountOrderByAggregateInput
    _avg?: EmailJobAvgOrderByAggregateInput
    _max?: EmailJobMaxOrderByAggregateInput
    _min?: EmailJobMinOrderByAggregateInput
    _sum?: EmailJobSumOrderByAggregateInput
  }

  export type EmailJobScalarWhereWithAggregatesInput = {
    AND?: EmailJobScalarWhereWithAggregatesInput | EmailJobScalarWhereWithAggregatesInput[]
    OR?: EmailJobScalarWhereWithAggregatesInput[]
    NOT?: EmailJobScalarWhereWithAggregatesInput | EmailJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailJob"> | string
    campaignId?: StringNullableWithAggregatesFilter<"EmailJob"> | string | null
    status?: EnumJobStatusWithAggregatesFilter<"EmailJob"> | $Enums.JobStatus
    totalEmails?: IntWithAggregatesFilter<"EmailJob"> | number
    processedEmails?: IntWithAggregatesFilter<"EmailJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"EmailJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"EmailJob"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"EmailJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailJob"> | Date | string
  }

  export type EmailJobLogWhereInput = {
    AND?: EmailJobLogWhereInput | EmailJobLogWhereInput[]
    OR?: EmailJobLogWhereInput[]
    NOT?: EmailJobLogWhereInput | EmailJobLogWhereInput[]
    id?: StringFilter<"EmailJobLog"> | string
    jobId?: StringFilter<"EmailJobLog"> | string
    level?: EnumLogLevelFilter<"EmailJobLog"> | $Enums.LogLevel
    message?: StringFilter<"EmailJobLog"> | string
    metadata?: JsonNullableFilter<"EmailJobLog">
    createdAt?: DateTimeFilter<"EmailJobLog"> | Date | string
    emailJob?: XOR<EmailJobScalarRelationFilter, EmailJobWhereInput>
  }

  export type EmailJobLogOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    emailJob?: EmailJobOrderByWithRelationInput
  }

  export type EmailJobLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailJobLogWhereInput | EmailJobLogWhereInput[]
    OR?: EmailJobLogWhereInput[]
    NOT?: EmailJobLogWhereInput | EmailJobLogWhereInput[]
    jobId?: StringFilter<"EmailJobLog"> | string
    level?: EnumLogLevelFilter<"EmailJobLog"> | $Enums.LogLevel
    message?: StringFilter<"EmailJobLog"> | string
    metadata?: JsonNullableFilter<"EmailJobLog">
    createdAt?: DateTimeFilter<"EmailJobLog"> | Date | string
    emailJob?: XOR<EmailJobScalarRelationFilter, EmailJobWhereInput>
  }, "id">

  export type EmailJobLogOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailJobLogCountOrderByAggregateInput
    _max?: EmailJobLogMaxOrderByAggregateInput
    _min?: EmailJobLogMinOrderByAggregateInput
  }

  export type EmailJobLogScalarWhereWithAggregatesInput = {
    AND?: EmailJobLogScalarWhereWithAggregatesInput | EmailJobLogScalarWhereWithAggregatesInput[]
    OR?: EmailJobLogScalarWhereWithAggregatesInput[]
    NOT?: EmailJobLogScalarWhereWithAggregatesInput | EmailJobLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailJobLog"> | string
    jobId?: StringWithAggregatesFilter<"EmailJobLog"> | string
    level?: EnumLogLevelWithAggregatesFilter<"EmailJobLog"> | $Enums.LogLevel
    message?: StringWithAggregatesFilter<"EmailJobLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"EmailJobLog">
    createdAt?: DateTimeWithAggregatesFilter<"EmailJobLog"> | Date | string
  }

  export type CampaignAnalyticsWhereInput = {
    AND?: CampaignAnalyticsWhereInput | CampaignAnalyticsWhereInput[]
    OR?: CampaignAnalyticsWhereInput[]
    NOT?: CampaignAnalyticsWhereInput | CampaignAnalyticsWhereInput[]
    id?: StringFilter<"CampaignAnalytics"> | string
    campaignId?: StringFilter<"CampaignAnalytics"> | string
    sentCount?: IntFilter<"CampaignAnalytics"> | number
    openCount?: IntFilter<"CampaignAnalytics"> | number
    clickCount?: IntFilter<"CampaignAnalytics"> | number
    bounceCount?: IntFilter<"CampaignAnalytics"> | number
    unsubscribeCount?: IntFilter<"CampaignAnalytics"> | number
    lastUpdated?: DateTimeFilter<"CampaignAnalytics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    bounceCount?: SortOrder
    unsubscribeCount?: SortOrder
    lastUpdated?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId?: string
    AND?: CampaignAnalyticsWhereInput | CampaignAnalyticsWhereInput[]
    OR?: CampaignAnalyticsWhereInput[]
    NOT?: CampaignAnalyticsWhereInput | CampaignAnalyticsWhereInput[]
    sentCount?: IntFilter<"CampaignAnalytics"> | number
    openCount?: IntFilter<"CampaignAnalytics"> | number
    clickCount?: IntFilter<"CampaignAnalytics"> | number
    bounceCount?: IntFilter<"CampaignAnalytics"> | number
    unsubscribeCount?: IntFilter<"CampaignAnalytics"> | number
    lastUpdated?: DateTimeFilter<"CampaignAnalytics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "campaignId">

  export type CampaignAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    bounceCount?: SortOrder
    unsubscribeCount?: SortOrder
    lastUpdated?: SortOrder
    _count?: CampaignAnalyticsCountOrderByAggregateInput
    _avg?: CampaignAnalyticsAvgOrderByAggregateInput
    _max?: CampaignAnalyticsMaxOrderByAggregateInput
    _min?: CampaignAnalyticsMinOrderByAggregateInput
    _sum?: CampaignAnalyticsSumOrderByAggregateInput
  }

  export type CampaignAnalyticsScalarWhereWithAggregatesInput = {
    AND?: CampaignAnalyticsScalarWhereWithAggregatesInput | CampaignAnalyticsScalarWhereWithAggregatesInput[]
    OR?: CampaignAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: CampaignAnalyticsScalarWhereWithAggregatesInput | CampaignAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignAnalytics"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignAnalytics"> | string
    sentCount?: IntWithAggregatesFilter<"CampaignAnalytics"> | number
    openCount?: IntWithAggregatesFilter<"CampaignAnalytics"> | number
    clickCount?: IntWithAggregatesFilter<"CampaignAnalytics"> | number
    bounceCount?: IntWithAggregatesFilter<"CampaignAnalytics"> | number
    unsubscribeCount?: IntWithAggregatesFilter<"CampaignAnalytics"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"CampaignAnalytics"> | Date | string
  }

  export type EmailCategoryWhereInput = {
    AND?: EmailCategoryWhereInput | EmailCategoryWhereInput[]
    OR?: EmailCategoryWhereInput[]
    NOT?: EmailCategoryWhereInput | EmailCategoryWhereInput[]
    id?: StringFilter<"EmailCategory"> | string
    name?: StringFilter<"EmailCategory"> | string
    description?: StringNullableFilter<"EmailCategory"> | string | null
    createdAt?: DateTimeFilter<"EmailCategory"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCategory"> | Date | string
    templates?: EmailTemplateListRelationFilter
  }

  export type EmailCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templates?: EmailTemplateOrderByRelationAggregateInput
  }

  export type EmailCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EmailCategoryWhereInput | EmailCategoryWhereInput[]
    OR?: EmailCategoryWhereInput[]
    NOT?: EmailCategoryWhereInput | EmailCategoryWhereInput[]
    description?: StringNullableFilter<"EmailCategory"> | string | null
    createdAt?: DateTimeFilter<"EmailCategory"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCategory"> | Date | string
    templates?: EmailTemplateListRelationFilter
  }, "id" | "name">

  export type EmailCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailCategoryCountOrderByAggregateInput
    _max?: EmailCategoryMaxOrderByAggregateInput
    _min?: EmailCategoryMinOrderByAggregateInput
  }

  export type EmailCategoryScalarWhereWithAggregatesInput = {
    AND?: EmailCategoryScalarWhereWithAggregatesInput | EmailCategoryScalarWhereWithAggregatesInput[]
    OR?: EmailCategoryScalarWhereWithAggregatesInput[]
    NOT?: EmailCategoryScalarWhereWithAggregatesInput | EmailCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailCategory"> | string
    name?: StringWithAggregatesFilter<"EmailCategory"> | string
    description?: StringNullableWithAggregatesFilter<"EmailCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailCategory"> | Date | string
  }

  export type SmtpConfigWhereInput = {
    AND?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    OR?: SmtpConfigWhereInput[]
    NOT?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    id?: StringFilter<"SmtpConfig"> | string
    provider?: StringFilter<"SmtpConfig"> | string
    host?: StringFilter<"SmtpConfig"> | string
    port?: StringFilter<"SmtpConfig"> | string
    username?: StringFilter<"SmtpConfig"> | string
    password?: StringFilter<"SmtpConfig"> | string
    isActive?: BoolFilter<"SmtpConfig"> | boolean
    createdAt?: DateTimeFilter<"SmtpConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SmtpConfig"> | Date | string
    teamId?: StringFilter<"SmtpConfig"> | string
    campaigns?: CampaignListRelationFilter
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type SmtpConfigOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    team?: TeamOrderByWithRelationInput
  }

  export type SmtpConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_provider?: SmtpConfigTeamIdProviderCompoundUniqueInput
    AND?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    OR?: SmtpConfigWhereInput[]
    NOT?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    provider?: StringFilter<"SmtpConfig"> | string
    host?: StringFilter<"SmtpConfig"> | string
    port?: StringFilter<"SmtpConfig"> | string
    username?: StringFilter<"SmtpConfig"> | string
    password?: StringFilter<"SmtpConfig"> | string
    isActive?: BoolFilter<"SmtpConfig"> | boolean
    createdAt?: DateTimeFilter<"SmtpConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SmtpConfig"> | Date | string
    teamId?: StringFilter<"SmtpConfig"> | string
    campaigns?: CampaignListRelationFilter
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "teamId_provider">

  export type SmtpConfigOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    _count?: SmtpConfigCountOrderByAggregateInput
    _max?: SmtpConfigMaxOrderByAggregateInput
    _min?: SmtpConfigMinOrderByAggregateInput
  }

  export type SmtpConfigScalarWhereWithAggregatesInput = {
    AND?: SmtpConfigScalarWhereWithAggregatesInput | SmtpConfigScalarWhereWithAggregatesInput[]
    OR?: SmtpConfigScalarWhereWithAggregatesInput[]
    NOT?: SmtpConfigScalarWhereWithAggregatesInput | SmtpConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SmtpConfig"> | string
    provider?: StringWithAggregatesFilter<"SmtpConfig"> | string
    host?: StringWithAggregatesFilter<"SmtpConfig"> | string
    port?: StringWithAggregatesFilter<"SmtpConfig"> | string
    username?: StringWithAggregatesFilter<"SmtpConfig"> | string
    password?: StringWithAggregatesFilter<"SmtpConfig"> | string
    isActive?: BoolWithAggregatesFilter<"SmtpConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SmtpConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SmtpConfig"> | Date | string
    teamId?: StringWithAggregatesFilter<"SmtpConfig"> | string
  }

  export type AutomationWhereInput = {
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    id?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    isActive?: BoolFilter<"Automation"> | boolean
    teamId?: StringFilter<"Automation"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    nodes?: AutomationNodeListRelationFilter
    edges?: AutomationNodeEdgeListRelationFilter
  }

  export type AutomationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
    team?: TeamOrderByWithRelationInput
    nodes?: AutomationNodeOrderByRelationAggregateInput
    edges?: AutomationNodeEdgeOrderByRelationAggregateInput
  }

  export type AutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    name?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    isActive?: BoolFilter<"Automation"> | boolean
    teamId?: StringFilter<"Automation"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    nodes?: AutomationNodeListRelationFilter
    edges?: AutomationNodeEdgeListRelationFilter
  }, "id">

  export type AutomationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
    _count?: AutomationCountOrderByAggregateInput
    _max?: AutomationMaxOrderByAggregateInput
    _min?: AutomationMinOrderByAggregateInput
  }

  export type AutomationScalarWhereWithAggregatesInput = {
    AND?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    OR?: AutomationScalarWhereWithAggregatesInput[]
    NOT?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automation"> | string
    name?: StringWithAggregatesFilter<"Automation"> | string
    description?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Automation"> | boolean
    teamId?: StringWithAggregatesFilter<"Automation"> | string
  }

  export type AutomationNodeWhereInput = {
    AND?: AutomationNodeWhereInput | AutomationNodeWhereInput[]
    OR?: AutomationNodeWhereInput[]
    NOT?: AutomationNodeWhereInput | AutomationNodeWhereInput[]
    id?: StringFilter<"AutomationNode"> | string
    automationId?: StringFilter<"AutomationNode"> | string
    type?: EnumNodeTypeFilter<"AutomationNode"> | $Enums.NodeType
    createdAt?: DateTimeFilter<"AutomationNode"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationNode"> | Date | string
    data?: JsonNullableFilter<"AutomationNode">
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
    edgesFrom?: AutomationNodeEdgeListRelationFilter
    edgesTo?: AutomationNodeEdgeListRelationFilter
  }

  export type AutomationNodeOrderByWithRelationInput = {
    id?: SortOrder
    automationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    data?: SortOrderInput | SortOrder
    automation?: AutomationOrderByWithRelationInput
    edgesFrom?: AutomationNodeEdgeOrderByRelationAggregateInput
    edgesTo?: AutomationNodeEdgeOrderByRelationAggregateInput
  }

  export type AutomationNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationNodeWhereInput | AutomationNodeWhereInput[]
    OR?: AutomationNodeWhereInput[]
    NOT?: AutomationNodeWhereInput | AutomationNodeWhereInput[]
    automationId?: StringFilter<"AutomationNode"> | string
    type?: EnumNodeTypeFilter<"AutomationNode"> | $Enums.NodeType
    createdAt?: DateTimeFilter<"AutomationNode"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationNode"> | Date | string
    data?: JsonNullableFilter<"AutomationNode">
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
    edgesFrom?: AutomationNodeEdgeListRelationFilter
    edgesTo?: AutomationNodeEdgeListRelationFilter
  }, "id">

  export type AutomationNodeOrderByWithAggregationInput = {
    id?: SortOrder
    automationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    data?: SortOrderInput | SortOrder
    _count?: AutomationNodeCountOrderByAggregateInput
    _max?: AutomationNodeMaxOrderByAggregateInput
    _min?: AutomationNodeMinOrderByAggregateInput
  }

  export type AutomationNodeScalarWhereWithAggregatesInput = {
    AND?: AutomationNodeScalarWhereWithAggregatesInput | AutomationNodeScalarWhereWithAggregatesInput[]
    OR?: AutomationNodeScalarWhereWithAggregatesInput[]
    NOT?: AutomationNodeScalarWhereWithAggregatesInput | AutomationNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationNode"> | string
    automationId?: StringWithAggregatesFilter<"AutomationNode"> | string
    type?: EnumNodeTypeWithAggregatesFilter<"AutomationNode"> | $Enums.NodeType
    createdAt?: DateTimeWithAggregatesFilter<"AutomationNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationNode"> | Date | string
    data?: JsonNullableWithAggregatesFilter<"AutomationNode">
  }

  export type AutomationNodeEdgeWhereInput = {
    AND?: AutomationNodeEdgeWhereInput | AutomationNodeEdgeWhereInput[]
    OR?: AutomationNodeEdgeWhereInput[]
    NOT?: AutomationNodeEdgeWhereInput | AutomationNodeEdgeWhereInput[]
    id?: StringFilter<"AutomationNodeEdge"> | string
    automationId?: StringFilter<"AutomationNodeEdge"> | string
    sourceId?: StringFilter<"AutomationNodeEdge"> | string
    targetId?: StringFilter<"AutomationNodeEdge"> | string
    createdAt?: DateTimeFilter<"AutomationNodeEdge"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationNodeEdge"> | Date | string
    label?: StringNullableFilter<"AutomationNodeEdge"> | string | null
    animated?: BoolFilter<"AutomationNodeEdge"> | boolean
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
    source?: XOR<AutomationNodeScalarRelationFilter, AutomationNodeWhereInput>
    target?: XOR<AutomationNodeScalarRelationFilter, AutomationNodeWhereInput>
  }

  export type AutomationNodeEdgeOrderByWithRelationInput = {
    id?: SortOrder
    automationId?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    label?: SortOrderInput | SortOrder
    animated?: SortOrder
    automation?: AutomationOrderByWithRelationInput
    source?: AutomationNodeOrderByWithRelationInput
    target?: AutomationNodeOrderByWithRelationInput
  }

  export type AutomationNodeEdgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationNodeEdgeWhereInput | AutomationNodeEdgeWhereInput[]
    OR?: AutomationNodeEdgeWhereInput[]
    NOT?: AutomationNodeEdgeWhereInput | AutomationNodeEdgeWhereInput[]
    automationId?: StringFilter<"AutomationNodeEdge"> | string
    sourceId?: StringFilter<"AutomationNodeEdge"> | string
    targetId?: StringFilter<"AutomationNodeEdge"> | string
    createdAt?: DateTimeFilter<"AutomationNodeEdge"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationNodeEdge"> | Date | string
    label?: StringNullableFilter<"AutomationNodeEdge"> | string | null
    animated?: BoolFilter<"AutomationNodeEdge"> | boolean
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
    source?: XOR<AutomationNodeScalarRelationFilter, AutomationNodeWhereInput>
    target?: XOR<AutomationNodeScalarRelationFilter, AutomationNodeWhereInput>
  }, "id">

  export type AutomationNodeEdgeOrderByWithAggregationInput = {
    id?: SortOrder
    automationId?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    label?: SortOrderInput | SortOrder
    animated?: SortOrder
    _count?: AutomationNodeEdgeCountOrderByAggregateInput
    _max?: AutomationNodeEdgeMaxOrderByAggregateInput
    _min?: AutomationNodeEdgeMinOrderByAggregateInput
  }

  export type AutomationNodeEdgeScalarWhereWithAggregatesInput = {
    AND?: AutomationNodeEdgeScalarWhereWithAggregatesInput | AutomationNodeEdgeScalarWhereWithAggregatesInput[]
    OR?: AutomationNodeEdgeScalarWhereWithAggregatesInput[]
    NOT?: AutomationNodeEdgeScalarWhereWithAggregatesInput | AutomationNodeEdgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationNodeEdge"> | string
    automationId?: StringWithAggregatesFilter<"AutomationNodeEdge"> | string
    sourceId?: StringWithAggregatesFilter<"AutomationNodeEdge"> | string
    targetId?: StringWithAggregatesFilter<"AutomationNodeEdge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutomationNodeEdge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationNodeEdge"> | Date | string
    label?: StringNullableWithAggregatesFilter<"AutomationNodeEdge"> | string | null
    animated?: BoolWithAggregatesFilter<"AutomationNodeEdge"> | boolean
  }

  export type CustomDomainWhereInput = {
    AND?: CustomDomainWhereInput | CustomDomainWhereInput[]
    OR?: CustomDomainWhereInput[]
    NOT?: CustomDomainWhereInput | CustomDomainWhereInput[]
    id?: StringFilter<"CustomDomain"> | string
    domain?: StringFilter<"CustomDomain"> | string
    sslStatus?: StringFilter<"CustomDomain"> | string
    sslCertificate?: StringNullableFilter<"CustomDomain"> | string | null
    sslPrivateKey?: StringNullableFilter<"CustomDomain"> | string | null
    sslExpiresAt?: DateTimeNullableFilter<"CustomDomain"> | Date | string | null
    verificationToken?: StringFilter<"CustomDomain"> | string
    dnsChallenge?: StringNullableFilter<"CustomDomain"> | string | null
    dnsChallengeToken?: StringNullableFilter<"CustomDomain"> | string | null
    isVerified?: BoolFilter<"CustomDomain"> | boolean
    isActive?: BoolFilter<"CustomDomain"> | boolean
    teamId?: StringFilter<"CustomDomain"> | string
    createdAt?: DateTimeFilter<"CustomDomain"> | Date | string
    updatedAt?: DateTimeFilter<"CustomDomain"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type CustomDomainOrderByWithRelationInput = {
    id?: SortOrder
    domain?: SortOrder
    sslStatus?: SortOrder
    sslCertificate?: SortOrderInput | SortOrder
    sslPrivateKey?: SortOrderInput | SortOrder
    sslExpiresAt?: SortOrderInput | SortOrder
    verificationToken?: SortOrder
    dnsChallenge?: SortOrderInput | SortOrder
    dnsChallengeToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type CustomDomainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: CustomDomainWhereInput | CustomDomainWhereInput[]
    OR?: CustomDomainWhereInput[]
    NOT?: CustomDomainWhereInput | CustomDomainWhereInput[]
    sslStatus?: StringFilter<"CustomDomain"> | string
    sslCertificate?: StringNullableFilter<"CustomDomain"> | string | null
    sslPrivateKey?: StringNullableFilter<"CustomDomain"> | string | null
    sslExpiresAt?: DateTimeNullableFilter<"CustomDomain"> | Date | string | null
    verificationToken?: StringFilter<"CustomDomain"> | string
    dnsChallenge?: StringNullableFilter<"CustomDomain"> | string | null
    dnsChallengeToken?: StringNullableFilter<"CustomDomain"> | string | null
    isVerified?: BoolFilter<"CustomDomain"> | boolean
    isActive?: BoolFilter<"CustomDomain"> | boolean
    teamId?: StringFilter<"CustomDomain"> | string
    createdAt?: DateTimeFilter<"CustomDomain"> | Date | string
    updatedAt?: DateTimeFilter<"CustomDomain"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "domain">

  export type CustomDomainOrderByWithAggregationInput = {
    id?: SortOrder
    domain?: SortOrder
    sslStatus?: SortOrder
    sslCertificate?: SortOrderInput | SortOrder
    sslPrivateKey?: SortOrderInput | SortOrder
    sslExpiresAt?: SortOrderInput | SortOrder
    verificationToken?: SortOrder
    dnsChallenge?: SortOrderInput | SortOrder
    dnsChallengeToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomDomainCountOrderByAggregateInput
    _max?: CustomDomainMaxOrderByAggregateInput
    _min?: CustomDomainMinOrderByAggregateInput
  }

  export type CustomDomainScalarWhereWithAggregatesInput = {
    AND?: CustomDomainScalarWhereWithAggregatesInput | CustomDomainScalarWhereWithAggregatesInput[]
    OR?: CustomDomainScalarWhereWithAggregatesInput[]
    NOT?: CustomDomainScalarWhereWithAggregatesInput | CustomDomainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomDomain"> | string
    domain?: StringWithAggregatesFilter<"CustomDomain"> | string
    sslStatus?: StringWithAggregatesFilter<"CustomDomain"> | string
    sslCertificate?: StringNullableWithAggregatesFilter<"CustomDomain"> | string | null
    sslPrivateKey?: StringNullableWithAggregatesFilter<"CustomDomain"> | string | null
    sslExpiresAt?: DateTimeNullableWithAggregatesFilter<"CustomDomain"> | Date | string | null
    verificationToken?: StringWithAggregatesFilter<"CustomDomain"> | string
    dnsChallenge?: StringNullableWithAggregatesFilter<"CustomDomain"> | string | null
    dnsChallengeToken?: StringNullableWithAggregatesFilter<"CustomDomain"> | string | null
    isVerified?: BoolWithAggregatesFilter<"CustomDomain"> | boolean
    isActive?: BoolWithAggregatesFilter<"CustomDomain"> | boolean
    teamId?: StringWithAggregatesFilter<"CustomDomain"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomDomain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomDomain"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    teamId?: StringFilter<"Webhook"> | string
    lastStatus?: IntNullableFilter<"Webhook"> | number | null
    lastAttempt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    retryCount?: IntFilter<"Webhook"> | number
    events?: WebhookEventListRelationFilter
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    lastStatus?: SortOrderInput | SortOrder
    lastAttempt?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    events?: WebhookEventOrderByRelationAggregateInput
    team?: TeamOrderByWithRelationInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    teamId?: StringFilter<"Webhook"> | string
    lastStatus?: IntNullableFilter<"Webhook"> | number | null
    lastAttempt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    retryCount?: IntFilter<"Webhook"> | number
    events?: WebhookEventListRelationFilter
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    lastStatus?: SortOrderInput | SortOrder
    lastAttempt?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    name?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    teamId?: StringWithAggregatesFilter<"Webhook"> | string
    lastStatus?: IntNullableWithAggregatesFilter<"Webhook"> | number | null
    lastAttempt?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    retryCount?: IntWithAggregatesFilter<"Webhook"> | number
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    eventType?: EnumWebhookEventTypeFilter<"WebhookEvent"> | $Enums.WebhookEventType
    webhookId?: StringFilter<"WebhookEvent"> | string
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    eventType?: EnumWebhookEventTypeFilter<"WebhookEvent"> | $Enums.WebhookEventType
    webhookId?: StringFilter<"WebhookEvent"> | string
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEvent"> | string
    eventType?: EnumWebhookEventTypeWithAggregatesFilter<"WebhookEvent"> | $Enums.WebhookEventType
    webhookId?: StringWithAggregatesFilter<"WebhookEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    eventType?: EnumWebhookEventTypeFilter<"WebhookDelivery"> | $Enums.WebhookEventType
    payload?: JsonFilter<"WebhookDelivery">
    status?: IntFilter<"WebhookDelivery"> | number
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    webhookId?: StringFilter<"WebhookDelivery"> | string
    eventType?: EnumWebhookEventTypeFilter<"WebhookDelivery"> | $Enums.WebhookEventType
    payload?: JsonFilter<"WebhookDelivery">
    status?: IntFilter<"WebhookDelivery"> | number
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    webhookId?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    eventType?: EnumWebhookEventTypeWithAggregatesFilter<"WebhookDelivery"> | $Enums.WebhookEventType
    payload?: JsonWithAggregatesFilter<"WebhookDelivery">
    status?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    response?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    error?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team: TeamCreateNestedOneWithoutTemplatesInput
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
    sentEmails?: SentEmailCreateNestedManyWithoutTemplateInput
    category: EmailCategoryCreateNestedOneWithoutTemplatesInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    categoryId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team?: TeamUpdateOneRequiredWithoutTemplatesNestedInput
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTemplateNestedInput
    category?: EmailCategoryUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    categoryId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    team?: TeamCreateNestedOneWithoutUsersInput
    invitesSent?: TeamInviteCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    teamId?: string | null
    invitesSent?: TeamInviteUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    team?: TeamUpdateOneWithoutUsersNestedInput
    invitesSent?: TeamInviteUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    invitesSent?: TeamInviteUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    teamId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamInviteCreateInput = {
    id?: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    team: TeamCreateNestedOneWithoutInvitesInput
    inviter: UserCreateNestedOneWithoutInvitesSentInput
  }

  export type TeamInviteUncheckedCreateInput = {
    id?: string
    teamId: string
    inviterId: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
  }

  export type TeamInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutInvitesNestedInput
    inviter?: UserUpdateOneRequiredWithoutInvitesSentNestedInput
  }

  export type TeamInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInviteCreateManyInput = {
    id?: string
    teamId: string
    inviterId: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
  }

  export type TeamInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    key: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
    team: TeamCreateNestedOneWithoutApiKeysInput
    usageStats?: ApiKeyUsageCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    name: string
    key: string
    teamId: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
    usageStats?: ApiKeyUsageUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutApiKeysNestedInput
    usageStats?: ApiKeyUsageUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageStats?: ApiKeyUsageUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    name: string
    key: string
    teamId: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApiKeyUsageCreateInput = {
    id?: string
    endpoint: string
    method: string
    timestamp?: Date | string
    success?: boolean
    error?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    apiKey: ApiKeyCreateNestedOneWithoutUsageStatsInput
  }

  export type ApiKeyUsageUncheckedCreateInput = {
    id?: string
    apiKeyId: string
    endpoint: string
    method: string
    timestamp?: Date | string
    success?: boolean
    error?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiKeyUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: ApiKeyUpdateOneRequiredWithoutUsageStatsNestedInput
  }

  export type ApiKeyUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiKeyId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageCreateManyInput = {
    id?: string
    apiKeyId: string
    endpoint: string
    method: string
    timestamp?: Date | string
    success?: boolean
    error?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiKeyUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiKeyId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutCampaignsInput
    team: TeamCreateNestedOneWithoutCampaignsInput
    mailingList: MailingListCreateNestedOneWithoutCampaignsInput
    sentEmails?: SentEmailCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsCreateNestedOneWithoutCampaignInput
    smtpConfig?: SmtpConfigCreateNestedOneWithoutCampaignsInput
    emailJobs?: EmailJobCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput
    emailJobs?: EmailJobUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    team?: TeamUpdateOneRequiredWithoutCampaignsNestedInput
    mailingList?: MailingListUpdateOneRequiredWithoutCampaignsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUpdateOneWithoutCampaignNestedInput
    smtpConfig?: SmtpConfigUpdateOneWithoutCampaignsNestedInput
    emailJobs?: EmailJobUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput
    emailJobs?: EmailJobUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailingListCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutListsInput
    subscribers?: SubscriberCreateNestedManyWithoutMailingListInput
    campaigns?: CampaignCreateNestedManyWithoutMailingListInput
  }

  export type MailingListUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutMailingListInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMailingListInput
  }

  export type MailingListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutListsNestedInput
    subscribers?: SubscriberUpdateManyWithoutMailingListNestedInput
    campaigns?: CampaignUpdateManyWithoutMailingListNestedInput
  }

  export type MailingListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: SubscriberUncheckedUpdateManyWithoutMailingListNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutMailingListNestedInput
  }

  export type MailingListCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailingListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailingListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberCreateInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mailingList: MailingListCreateNestedOneWithoutSubscribersInput
    sentEmails?: SentEmailCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberUncheckedCreateInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    listId: string
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailingList?: MailingListUpdateOneRequiredWithoutSubscribersNestedInput
    sentEmails?: SentEmailUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberCreateManyInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    listId: string
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailCreateInput = {
    id?: string
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateCreateNestedOneWithoutSentEmailsInput
    campaign?: CampaignCreateNestedOneWithoutSentEmailsInput
    team: TeamCreateNestedOneWithoutSentEmailsInput
    emailJob?: EmailJobCreateNestedOneWithoutSentEmailsInput
    subscriber?: SubscriberCreateNestedOneWithoutSentEmailsInput
    tracking?: EmailTrackingCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailUncheckedCreateInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
    tracking?: EmailTrackingUncheckedCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateUpdateOneWithoutSentEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutSentEmailsNestedInput
    team?: TeamUpdateOneRequiredWithoutSentEmailsNestedInput
    emailJob?: EmailJobUpdateOneWithoutSentEmailsNestedInput
    subscriber?: SubscriberUpdateOneWithoutSentEmailsNestedInput
    tracking?: EmailTrackingUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    tracking?: EmailTrackingUncheckedUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailCreateManyInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
  }

  export type SentEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SentEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailTrackingCreateInput = {
    id?: string
    type: $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentEmail: SentEmailCreateNestedOneWithoutTrackingInput
  }

  export type EmailTrackingUncheckedCreateInput = {
    id?: string
    sentEmailId: string
    type: $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackingTypeFieldUpdateOperationsInput | $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmail?: SentEmailUpdateOneRequiredWithoutTrackingNestedInput
  }

  export type EmailTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentEmailId?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackingTypeFieldUpdateOperationsInput | $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingCreateManyInput = {
    id?: string
    sentEmailId: string
    type: $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackingTypeFieldUpdateOperationsInput | $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentEmailId?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackingTypeFieldUpdateOperationsInput | $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJobCreateInput = {
    id?: string
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutEmailJobsInput
    sentEmails?: SentEmailCreateNestedManyWithoutEmailJobInput
    logs?: EmailJobLogCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobUncheckedCreateInput = {
    id?: string
    campaignId?: string | null
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutEmailJobInput
    logs?: EmailJobLogUncheckedCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutEmailJobsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutEmailJobNestedInput
    logs?: EmailJobLogUpdateManyWithoutEmailJobNestedInput
  }

  export type EmailJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutEmailJobNestedInput
    logs?: EmailJobLogUncheckedUpdateManyWithoutEmailJobNestedInput
  }

  export type EmailJobCreateManyInput = {
    id?: string
    campaignId?: string | null
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJobLogCreateInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    emailJob: EmailJobCreateNestedOneWithoutLogsInput
  }

  export type EmailJobLogUncheckedCreateInput = {
    id?: string
    jobId: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailJobLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailJob?: EmailJobUpdateOneRequiredWithoutLogsNestedInput
  }

  export type EmailJobLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJobLogCreateManyInput = {
    id?: string
    jobId: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailJobLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJobLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalyticsCreateInput = {
    id?: string
    sentCount?: number
    openCount?: number
    clickCount?: number
    bounceCount?: number
    unsubscribeCount?: number
    lastUpdated?: Date | string
    campaign: CampaignCreateNestedOneWithoutAnalyticsInput
  }

  export type CampaignAnalyticsUncheckedCreateInput = {
    id?: string
    campaignId: string
    sentCount?: number
    openCount?: number
    clickCount?: number
    bounceCount?: number
    unsubscribeCount?: number
    lastUpdated?: Date | string
  }

  export type CampaignAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type CampaignAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalyticsCreateManyInput = {
    id?: string
    campaignId: string
    sentCount?: number
    openCount?: number
    clickCount?: number
    bounceCount?: number
    unsubscribeCount?: number
    lastUpdated?: Date | string
  }

  export type CampaignAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: EmailTemplateCreateNestedManyWithoutCategoryInput
  }

  export type EmailCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type EmailCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: EmailTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type EmailCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: EmailTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EmailCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmtpConfigCreateInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutSmtpConfigInput
    team: TeamCreateNestedOneWithoutSmtpConfigsInput
  }

  export type SmtpConfigUncheckedCreateInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutSmtpConfigInput
  }

  export type SmtpConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutSmtpConfigNestedInput
    team?: TeamUpdateOneRequiredWithoutSmtpConfigsNestedInput
  }

  export type SmtpConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    campaigns?: CampaignUncheckedUpdateManyWithoutSmtpConfigNestedInput
  }

  export type SmtpConfigCreateManyInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
  }

  export type SmtpConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmtpConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    team: TeamCreateNestedOneWithoutAutomationsInput
    nodes?: AutomationNodeCreateNestedManyWithoutAutomationInput
    edges?: AutomationNodeEdgeCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    teamId: string
    nodes?: AutomationNodeUncheckedCreateNestedManyWithoutAutomationInput
    edges?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutAutomationsNestedInput
    nodes?: AutomationNodeUpdateManyWithoutAutomationNestedInput
    edges?: AutomationNodeEdgeUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamId?: StringFieldUpdateOperationsInput | string
    nodes?: AutomationNodeUncheckedUpdateManyWithoutAutomationNestedInput
    edges?: AutomationNodeEdgeUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    teamId: string
  }

  export type AutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationNodeCreateInput = {
    id?: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    automation: AutomationCreateNestedOneWithoutNodesInput
    edgesFrom?: AutomationNodeEdgeCreateNestedManyWithoutSourceInput
    edgesTo?: AutomationNodeEdgeCreateNestedManyWithoutTargetInput
  }

  export type AutomationNodeUncheckedCreateInput = {
    id?: string
    automationId: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutSourceInput
    edgesTo?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AutomationNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    automation?: AutomationUpdateOneRequiredWithoutNodesNestedInput
    edgesFrom?: AutomationNodeEdgeUpdateManyWithoutSourceNestedInput
    edgesTo?: AutomationNodeEdgeUpdateManyWithoutTargetNestedInput
  }

  export type AutomationNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeUncheckedUpdateManyWithoutSourceNestedInput
    edgesTo?: AutomationNodeEdgeUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AutomationNodeCreateManyInput = {
    id?: string
    automationId: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AutomationNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AutomationNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AutomationNodeEdgeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
    automation: AutomationCreateNestedOneWithoutEdgesInput
    source: AutomationNodeCreateNestedOneWithoutEdgesFromInput
    target: AutomationNodeCreateNestedOneWithoutEdgesToInput
  }

  export type AutomationNodeEdgeUncheckedCreateInput = {
    id?: string
    automationId: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeEdgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    automation?: AutomationUpdateOneRequiredWithoutEdgesNestedInput
    source?: AutomationNodeUpdateOneRequiredWithoutEdgesFromNestedInput
    target?: AutomationNodeUpdateOneRequiredWithoutEdgesToNestedInput
  }

  export type AutomationNodeEdgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationNodeEdgeCreateManyInput = {
    id?: string
    automationId: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeEdgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationNodeEdgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomDomainCreateInput = {
    id?: string
    domain: string
    sslStatus?: string
    sslCertificate?: string | null
    sslPrivateKey?: string | null
    sslExpiresAt?: Date | string | null
    verificationToken?: string
    dnsChallenge?: string | null
    dnsChallengeToken?: string | null
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutCustomDomainsInput
  }

  export type CustomDomainUncheckedCreateInput = {
    id?: string
    domain: string
    sslStatus?: string
    sslCertificate?: string | null
    sslPrivateKey?: string | null
    sslExpiresAt?: Date | string | null
    verificationToken?: string
    dnsChallenge?: string | null
    dnsChallengeToken?: string | null
    isVerified?: boolean
    isActive?: boolean
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomDomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    sslStatus?: StringFieldUpdateOperationsInput | string
    sslCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    sslPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    sslExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: StringFieldUpdateOperationsInput | string
    dnsChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    dnsChallengeToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutCustomDomainsNestedInput
  }

  export type CustomDomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    sslStatus?: StringFieldUpdateOperationsInput | string
    sslCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    sslPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    sslExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: StringFieldUpdateOperationsInput | string
    dnsChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    dnsChallengeToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomDomainCreateManyInput = {
    id?: string
    domain: string
    sslStatus?: string
    sslCertificate?: string | null
    sslPrivateKey?: string | null
    sslExpiresAt?: Date | string | null
    verificationToken?: string
    dnsChallenge?: string | null
    dnsChallengeToken?: string | null
    isVerified?: boolean
    isActive?: boolean
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomDomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    sslStatus?: StringFieldUpdateOperationsInput | string
    sslCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    sslPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    sslExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: StringFieldUpdateOperationsInput | string
    dnsChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    dnsChallengeToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomDomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    sslStatus?: StringFieldUpdateOperationsInput | string
    sslCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    sslPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    sslExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: StringFieldUpdateOperationsInput | string
    dnsChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    dnsChallengeToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
    events?: WebhookEventCreateNestedManyWithoutWebhookInput
    team: TeamCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
    events?: WebhookEventUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    events?: WebhookEventUpdateManyWithoutWebhookNestedInput
    team?: TeamUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    events?: WebhookEventUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type WebhookEventCreateInput = {
    id?: string
    eventType: $Enums.WebhookEventType
    createdAt?: Date | string
    webhook: WebhookCreateNestedOneWithoutEventsInput
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    eventType: $Enums.WebhookEventType
    webhookId: string
    createdAt?: Date | string
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook?: WebhookUpdateOneRequiredWithoutEventsNestedInput
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    webhookId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    eventType: $Enums.WebhookEventType
    webhookId: string
    createdAt?: Date | string
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    webhookId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    webhookId: string
    eventType: $Enums.WebhookEventType
    payload: JsonNullValueInput | InputJsonValue
    status: number
    response?: string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    webhookId: string
    eventType: $Enums.WebhookEventType
    payload: JsonNullValueInput | InputJsonValue
    status: number
    response?: string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    webhookId: string
    eventType: $Enums.WebhookEventType
    payload: JsonNullValueInput | InputJsonValue
    status: number
    response?: string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type SentEmailListRelationFilter = {
    every?: SentEmailWhereInput
    some?: SentEmailWhereInput
    none?: SentEmailWhereInput
  }

  export type EmailCategoryScalarRelationFilter = {
    is?: EmailCategoryWhereInput
    isNot?: EmailCategoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SentEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    html?: SortOrder
    design?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    html?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    html?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type TeamInviteListRelationFilter = {
    every?: TeamInviteWhereInput
    some?: TeamInviteWhereInput
    none?: TeamInviteWhereInput
  }

  export type TeamInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type EmailTemplateListRelationFilter = {
    every?: EmailTemplateWhereInput
    some?: EmailTemplateWhereInput
    none?: EmailTemplateWhereInput
  }

  export type MailingListListRelationFilter = {
    every?: MailingListWhereInput
    some?: MailingListWhereInput
    none?: MailingListWhereInput
  }

  export type AutomationListRelationFilter = {
    every?: AutomationWhereInput
    some?: AutomationWhereInput
    none?: AutomationWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type SmtpConfigListRelationFilter = {
    every?: SmtpConfigWhereInput
    some?: SmtpConfigWhereInput
    none?: SmtpConfigWhereInput
  }

  export type CustomDomainListRelationFilter = {
    every?: CustomDomainWhereInput
    some?: CustomDomainWhereInput
    none?: CustomDomainWhereInput
  }

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput
    some?: WebhookWhereInput
    none?: WebhookWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MailingListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SmtpConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomDomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeamInviteCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    inviterId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
  }

  export type TeamInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    inviterId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
  }

  export type TeamInviteMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    inviterId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
  }

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ApiKeyUsageListRelationFilter = {
    every?: ApiKeyUsageWhereInput
    some?: ApiKeyUsageWhereInput
    none?: ApiKeyUsageWhereInput
  }

  export type ApiKeyUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    teamId?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    teamId?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    teamId?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ApiKeyScalarRelationFilter = {
    is?: ApiKeyWhereInput
    isNot?: ApiKeyWhereInput
  }

  export type ApiKeyUsageCountOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    timestamp?: SortOrder
    success?: SortOrder
    error?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type ApiKeyUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    timestamp?: SortOrder
    success?: SortOrder
    error?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type ApiKeyUsageMinOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    timestamp?: SortOrder
    success?: SortOrder
    error?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type EnumCampaignScheduleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignSchedule | EnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignScheduleNullableFilter<$PrismaModel> | $Enums.CampaignSchedule | null
  }

  export type EnumCampaignRecurringScheduleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRecurringSchedule | EnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignRecurringScheduleNullableFilter<$PrismaModel> | $Enums.CampaignRecurringSchedule | null
  }

  export type EmailTemplateScalarRelationFilter = {
    is?: EmailTemplateWhereInput
    isNot?: EmailTemplateWhereInput
  }

  export type MailingListScalarRelationFilter = {
    is?: MailingListWhereInput
    isNot?: MailingListWhereInput
  }

  export type CampaignAnalyticsNullableScalarRelationFilter = {
    is?: CampaignAnalyticsWhereInput | null
    isNot?: CampaignAnalyticsWhereInput | null
  }

  export type SmtpConfigNullableScalarRelationFilter = {
    is?: SmtpConfigWhereInput | null
    isNot?: SmtpConfigWhereInput | null
  }

  export type EmailJobListRelationFilter = {
    every?: EmailJobWhereInput
    some?: EmailJobWhereInput
    none?: EmailJobWhereInput
  }

  export type EmailJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    templateId?: SortOrder
    teamId?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    schedule?: SortOrder
    listId?: SortOrder
    recurringSchedule?: SortOrder
    cronExpression?: SortOrder
    smtpConfigId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    templateId?: SortOrder
    teamId?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    schedule?: SortOrder
    listId?: SortOrder
    recurringSchedule?: SortOrder
    cronExpression?: SortOrder
    smtpConfigId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    templateId?: SortOrder
    teamId?: SortOrder
    status?: SortOrder
    scheduledFor?: SortOrder
    schedule?: SortOrder
    listId?: SortOrder
    recurringSchedule?: SortOrder
    cronExpression?: SortOrder
    smtpConfigId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type EnumCampaignScheduleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignSchedule | EnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignScheduleNullableWithAggregatesFilter<$PrismaModel> | $Enums.CampaignSchedule | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCampaignScheduleNullableFilter<$PrismaModel>
    _max?: NestedEnumCampaignScheduleNullableFilter<$PrismaModel>
  }

  export type EnumCampaignRecurringScheduleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRecurringSchedule | EnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignRecurringScheduleNullableWithAggregatesFilter<$PrismaModel> | $Enums.CampaignRecurringSchedule | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCampaignRecurringScheduleNullableFilter<$PrismaModel>
    _max?: NestedEnumCampaignRecurringScheduleNullableFilter<$PrismaModel>
  }

  export type SubscriberListRelationFilter = {
    every?: SubscriberWhereInput
    some?: SubscriberWhereInput
    none?: SubscriberWhereInput
  }

  export type SubscriberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MailingListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailingListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailingListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberStatus | EnumSubscriberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberStatusFilter<$PrismaModel> | $Enums.SubscriberStatus
  }

  export type SubscriberEmailListIdCompoundUniqueInput = {
    email: string
    listId: string
  }

  export type SubscriberCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    title?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    customFields?: SortOrder
    source?: SortOrder
    listId?: SortOrder
    status?: SortOrder
    unsubscribedAt?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    title?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    source?: SortOrder
    listId?: SortOrder
    status?: SortOrder
    unsubscribedAt?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    title?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    source?: SortOrder
    listId?: SortOrder
    status?: SortOrder
    unsubscribedAt?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberStatus | EnumSubscriberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriberStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriberStatusFilter<$PrismaModel>
  }

  export type EnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type EmailTemplateNullableScalarRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type CampaignNullableScalarRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type EmailJobNullableScalarRelationFilter = {
    is?: EmailJobWhereInput | null
    isNot?: EmailJobWhereInput | null
  }

  export type SubscriberNullableScalarRelationFilter = {
    is?: SubscriberWhereInput | null
    isNot?: SubscriberWhereInput | null
  }

  export type EmailTrackingListRelationFilter = {
    every?: EmailTrackingWhereInput
    some?: EmailTrackingWhereInput
    none?: EmailTrackingWhereInput
  }

  export type EmailTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SentEmailCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    campaignId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    teamId?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    jobId?: SortOrder
    subscriberId?: SortOrder
  }

  export type SentEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    campaignId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    teamId?: SortOrder
    error?: SortOrder
    jobId?: SortOrder
    subscriberId?: SortOrder
  }

  export type SentEmailMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    campaignId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    teamId?: SortOrder
    error?: SortOrder
    jobId?: SortOrder
    subscriberId?: SortOrder
  }

  export type EnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type EnumTrackingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingType | EnumTrackingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingTypeFilter<$PrismaModel> | $Enums.TrackingType
  }

  export type SentEmailScalarRelationFilter = {
    is?: SentEmailWhereInput
    isNot?: SentEmailWhereInput
  }

  export type EmailTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    sentEmailId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    sentEmailId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    sentEmailId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTrackingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingType | EnumTrackingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackingTypeFilter<$PrismaModel>
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type EmailJobLogListRelationFilter = {
    every?: EmailJobLogWhereInput
    some?: EmailJobLogWhereInput
    none?: EmailJobLogWhereInput
  }

  export type EmailJobLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailJobCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    totalEmails?: SortOrder
    processedEmails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailJobAvgOrderByAggregateInput = {
    totalEmails?: SortOrder
    processedEmails?: SortOrder
  }

  export type EmailJobMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    totalEmails?: SortOrder
    processedEmails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailJobMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    totalEmails?: SortOrder
    processedEmails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailJobSumOrderByAggregateInput = {
    totalEmails?: SortOrder
    processedEmails?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type EnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type EmailJobScalarRelationFilter = {
    is?: EmailJobWhereInput
    isNot?: EmailJobWhereInput
  }

  export type EmailJobLogCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailJobLogMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailJobLogMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    bounceCount?: SortOrder
    unsubscribeCount?: SortOrder
    lastUpdated?: SortOrder
  }

  export type CampaignAnalyticsAvgOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    bounceCount?: SortOrder
    unsubscribeCount?: SortOrder
  }

  export type CampaignAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    bounceCount?: SortOrder
    unsubscribeCount?: SortOrder
    lastUpdated?: SortOrder
  }

  export type CampaignAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    bounceCount?: SortOrder
    unsubscribeCount?: SortOrder
    lastUpdated?: SortOrder
  }

  export type CampaignAnalyticsSumOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    bounceCount?: SortOrder
    unsubscribeCount?: SortOrder
  }

  export type EmailCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SmtpConfigTeamIdProviderCompoundUniqueInput = {
    teamId: string
    provider: string
  }

  export type SmtpConfigCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
  }

  export type SmtpConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
  }

  export type SmtpConfigMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
  }

  export type AutomationNodeListRelationFilter = {
    every?: AutomationNodeWhereInput
    some?: AutomationNodeWhereInput
    none?: AutomationNodeWhereInput
  }

  export type AutomationNodeEdgeListRelationFilter = {
    every?: AutomationNodeEdgeWhereInput
    some?: AutomationNodeEdgeWhereInput
    none?: AutomationNodeEdgeWhereInput
  }

  export type AutomationNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationNodeEdgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
  }

  export type AutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
  }

  export type AutomationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
  }

  export type EnumNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeFilter<$PrismaModel> | $Enums.NodeType
  }

  export type AutomationScalarRelationFilter = {
    is?: AutomationWhereInput
    isNot?: AutomationWhereInput
  }

  export type AutomationNodeCountOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    data?: SortOrder
  }

  export type AutomationNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationNodeMinOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.NodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeFilter<$PrismaModel>
  }

  export type AutomationNodeScalarRelationFilter = {
    is?: AutomationNodeWhereInput
    isNot?: AutomationNodeWhereInput
  }

  export type AutomationNodeEdgeCountOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    label?: SortOrder
    animated?: SortOrder
  }

  export type AutomationNodeEdgeMaxOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    label?: SortOrder
    animated?: SortOrder
  }

  export type AutomationNodeEdgeMinOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    label?: SortOrder
    animated?: SortOrder
  }

  export type CustomDomainCountOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    sslStatus?: SortOrder
    sslCertificate?: SortOrder
    sslPrivateKey?: SortOrder
    sslExpiresAt?: SortOrder
    verificationToken?: SortOrder
    dnsChallenge?: SortOrder
    dnsChallengeToken?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomDomainMaxOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    sslStatus?: SortOrder
    sslCertificate?: SortOrder
    sslPrivateKey?: SortOrder
    sslExpiresAt?: SortOrder
    verificationToken?: SortOrder
    dnsChallenge?: SortOrder
    dnsChallengeToken?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomDomainMinOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    sslStatus?: SortOrder
    sslCertificate?: SortOrder
    sslPrivateKey?: SortOrder
    sslExpiresAt?: SortOrder
    verificationToken?: SortOrder
    dnsChallenge?: SortOrder
    dnsChallengeToken?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type WebhookEventListRelationFilter = {
    every?: WebhookEventWhereInput
    some?: WebhookEventWhereInput
    none?: WebhookEventWhereInput
  }

  export type WebhookEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    lastStatus?: SortOrder
    lastAttempt?: SortOrder
    retryCount?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    lastStatus?: SortOrder
    retryCount?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    lastStatus?: SortOrder
    lastAttempt?: SortOrder
    retryCount?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    lastStatus?: SortOrder
    lastAttempt?: SortOrder
    retryCount?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    lastStatus?: SortOrder
    retryCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumWebhookEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEventType | EnumWebhookEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventTypeFilter<$PrismaModel> | $Enums.WebhookEventType
  }

  export type WebhookScalarRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    webhookId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumWebhookEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEventType | EnumWebhookEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.WebhookEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookEventTypeFilter<$PrismaModel>
    _max?: NestedEnumWebhookEventTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    response?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    eventType?: SortOrder
    status?: SortOrder
    response?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    eventType?: SortOrder
    status?: SortOrder
    response?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    status?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EmailTemplateCreatevariablesInput = {
    set: string[]
  }

  export type TeamCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<TeamCreateWithoutTemplatesInput, TeamUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTemplatesInput
    connect?: TeamWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type SentEmailCreateNestedManyWithoutTemplateInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type EmailCategoryCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<EmailCategoryCreateWithoutTemplatesInput, EmailCategoryUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: EmailCategoryCreateOrConnectWithoutTemplatesInput
    connect?: EmailCategoryWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type SentEmailUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EmailTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TeamUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<TeamCreateWithoutTemplatesInput, TeamUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTemplatesInput
    upsert?: TeamUpsertWithoutTemplatesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTemplatesInput, TeamUpdateWithoutTemplatesInput>, TeamUncheckedUpdateWithoutTemplatesInput>
  }

  export type CampaignUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTemplateInput | CampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTemplateInput | CampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTemplateInput | CampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type SentEmailUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutTemplateInput | SentEmailUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutTemplateInput | SentEmailUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutTemplateInput | SentEmailUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type EmailCategoryUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<EmailCategoryCreateWithoutTemplatesInput, EmailCategoryUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: EmailCategoryCreateOrConnectWithoutTemplatesInput
    upsert?: EmailCategoryUpsertWithoutTemplatesInput
    connect?: EmailCategoryWhereUniqueInput
    update?: XOR<XOR<EmailCategoryUpdateToOneWithWhereWithoutTemplatesInput, EmailCategoryUpdateWithoutTemplatesInput>, EmailCategoryUncheckedUpdateWithoutTemplatesInput>
  }

  export type CampaignUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTemplateInput | CampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTemplateInput | CampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTemplateInput | CampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type SentEmailUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutTemplateInput | SentEmailUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutTemplateInput | SentEmailUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutTemplateInput | SentEmailUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutUsersInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamInviteCreateNestedManyWithoutInviterInput = {
    create?: XOR<TeamInviteCreateWithoutInviterInput, TeamInviteUncheckedCreateWithoutInviterInput> | TeamInviteCreateWithoutInviterInput[] | TeamInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutInviterInput | TeamInviteCreateOrConnectWithoutInviterInput[]
    createMany?: TeamInviteCreateManyInviterInputEnvelope
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
  }

  export type TeamInviteUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<TeamInviteCreateWithoutInviterInput, TeamInviteUncheckedCreateWithoutInviterInput> | TeamInviteCreateWithoutInviterInput[] | TeamInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutInviterInput | TeamInviteCreateOrConnectWithoutInviterInput[]
    createMany?: TeamInviteCreateManyInviterInputEnvelope
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type TeamUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput
    upsert?: TeamUpsertWithoutUsersInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutUsersInput, TeamUpdateWithoutUsersInput>, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type TeamInviteUpdateManyWithoutInviterNestedInput = {
    create?: XOR<TeamInviteCreateWithoutInviterInput, TeamInviteUncheckedCreateWithoutInviterInput> | TeamInviteCreateWithoutInviterInput[] | TeamInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutInviterInput | TeamInviteCreateOrConnectWithoutInviterInput[]
    upsert?: TeamInviteUpsertWithWhereUniqueWithoutInviterInput | TeamInviteUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: TeamInviteCreateManyInviterInputEnvelope
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    update?: TeamInviteUpdateWithWhereUniqueWithoutInviterInput | TeamInviteUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: TeamInviteUpdateManyWithWhereWithoutInviterInput | TeamInviteUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[]
  }

  export type TeamInviteUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<TeamInviteCreateWithoutInviterInput, TeamInviteUncheckedCreateWithoutInviterInput> | TeamInviteCreateWithoutInviterInput[] | TeamInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutInviterInput | TeamInviteCreateOrConnectWithoutInviterInput[]
    upsert?: TeamInviteUpsertWithWhereUniqueWithoutInviterInput | TeamInviteUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: TeamInviteCreateManyInviterInputEnvelope
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    update?: TeamInviteUpdateWithWhereUniqueWithoutInviterInput | TeamInviteUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: TeamInviteUpdateManyWithWhereWithoutInviterInput | TeamInviteUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamInviteCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamInviteCreateWithoutTeamInput, TeamInviteUncheckedCreateWithoutTeamInput> | TeamInviteCreateWithoutTeamInput[] | TeamInviteUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutTeamInput | TeamInviteCreateOrConnectWithoutTeamInput[]
    createMany?: TeamInviteCreateManyTeamInputEnvelope
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmailTemplateCreateWithoutTeamInput, EmailTemplateUncheckedCreateWithoutTeamInput> | EmailTemplateCreateWithoutTeamInput[] | EmailTemplateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutTeamInput | EmailTemplateCreateOrConnectWithoutTeamInput[]
    createMany?: EmailTemplateCreateManyTeamInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type MailingListCreateNestedManyWithoutTeamInput = {
    create?: XOR<MailingListCreateWithoutTeamInput, MailingListUncheckedCreateWithoutTeamInput> | MailingListCreateWithoutTeamInput[] | MailingListUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MailingListCreateOrConnectWithoutTeamInput | MailingListCreateOrConnectWithoutTeamInput[]
    createMany?: MailingListCreateManyTeamInputEnvelope
    connect?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
  }

  export type AutomationCreateNestedManyWithoutTeamInput = {
    create?: XOR<AutomationCreateWithoutTeamInput, AutomationUncheckedCreateWithoutTeamInput> | AutomationCreateWithoutTeamInput[] | AutomationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTeamInput | AutomationCreateOrConnectWithoutTeamInput[]
    createMany?: AutomationCreateManyTeamInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutTeamInput = {
    create?: XOR<CampaignCreateWithoutTeamInput, CampaignUncheckedCreateWithoutTeamInput> | CampaignCreateWithoutTeamInput[] | CampaignUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamInput | CampaignCreateOrConnectWithoutTeamInput[]
    createMany?: CampaignCreateManyTeamInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutTeamInput = {
    create?: XOR<ApiKeyCreateWithoutTeamInput, ApiKeyUncheckedCreateWithoutTeamInput> | ApiKeyCreateWithoutTeamInput[] | ApiKeyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTeamInput | ApiKeyCreateOrConnectWithoutTeamInput[]
    createMany?: ApiKeyCreateManyTeamInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type SmtpConfigCreateNestedManyWithoutTeamInput = {
    create?: XOR<SmtpConfigCreateWithoutTeamInput, SmtpConfigUncheckedCreateWithoutTeamInput> | SmtpConfigCreateWithoutTeamInput[] | SmtpConfigUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SmtpConfigCreateOrConnectWithoutTeamInput | SmtpConfigCreateOrConnectWithoutTeamInput[]
    createMany?: SmtpConfigCreateManyTeamInputEnvelope
    connect?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
  }

  export type SentEmailCreateNestedManyWithoutTeamInput = {
    create?: XOR<SentEmailCreateWithoutTeamInput, SentEmailUncheckedCreateWithoutTeamInput> | SentEmailCreateWithoutTeamInput[] | SentEmailUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTeamInput | SentEmailCreateOrConnectWithoutTeamInput[]
    createMany?: SentEmailCreateManyTeamInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type CustomDomainCreateNestedManyWithoutTeamInput = {
    create?: XOR<CustomDomainCreateWithoutTeamInput, CustomDomainUncheckedCreateWithoutTeamInput> | CustomDomainCreateWithoutTeamInput[] | CustomDomainUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CustomDomainCreateOrConnectWithoutTeamInput | CustomDomainCreateOrConnectWithoutTeamInput[]
    createMany?: CustomDomainCreateManyTeamInputEnvelope
    connect?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
  }

  export type WebhookCreateNestedManyWithoutTeamInput = {
    create?: XOR<WebhookCreateWithoutTeamInput, WebhookUncheckedCreateWithoutTeamInput> | WebhookCreateWithoutTeamInput[] | WebhookUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTeamInput | WebhookCreateOrConnectWithoutTeamInput[]
    createMany?: WebhookCreateManyTeamInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamInviteUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamInviteCreateWithoutTeamInput, TeamInviteUncheckedCreateWithoutTeamInput> | TeamInviteCreateWithoutTeamInput[] | TeamInviteUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutTeamInput | TeamInviteCreateOrConnectWithoutTeamInput[]
    createMany?: TeamInviteCreateManyTeamInputEnvelope
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
  }

  export type EmailTemplateUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmailTemplateCreateWithoutTeamInput, EmailTemplateUncheckedCreateWithoutTeamInput> | EmailTemplateCreateWithoutTeamInput[] | EmailTemplateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutTeamInput | EmailTemplateCreateOrConnectWithoutTeamInput[]
    createMany?: EmailTemplateCreateManyTeamInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type MailingListUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<MailingListCreateWithoutTeamInput, MailingListUncheckedCreateWithoutTeamInput> | MailingListCreateWithoutTeamInput[] | MailingListUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MailingListCreateOrConnectWithoutTeamInput | MailingListCreateOrConnectWithoutTeamInput[]
    createMany?: MailingListCreateManyTeamInputEnvelope
    connect?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
  }

  export type AutomationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<AutomationCreateWithoutTeamInput, AutomationUncheckedCreateWithoutTeamInput> | AutomationCreateWithoutTeamInput[] | AutomationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTeamInput | AutomationCreateOrConnectWithoutTeamInput[]
    createMany?: AutomationCreateManyTeamInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<CampaignCreateWithoutTeamInput, CampaignUncheckedCreateWithoutTeamInput> | CampaignCreateWithoutTeamInput[] | CampaignUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamInput | CampaignCreateOrConnectWithoutTeamInput[]
    createMany?: CampaignCreateManyTeamInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ApiKeyCreateWithoutTeamInput, ApiKeyUncheckedCreateWithoutTeamInput> | ApiKeyCreateWithoutTeamInput[] | ApiKeyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTeamInput | ApiKeyCreateOrConnectWithoutTeamInput[]
    createMany?: ApiKeyCreateManyTeamInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type SmtpConfigUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<SmtpConfigCreateWithoutTeamInput, SmtpConfigUncheckedCreateWithoutTeamInput> | SmtpConfigCreateWithoutTeamInput[] | SmtpConfigUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SmtpConfigCreateOrConnectWithoutTeamInput | SmtpConfigCreateOrConnectWithoutTeamInput[]
    createMany?: SmtpConfigCreateManyTeamInputEnvelope
    connect?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
  }

  export type SentEmailUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<SentEmailCreateWithoutTeamInput, SentEmailUncheckedCreateWithoutTeamInput> | SentEmailCreateWithoutTeamInput[] | SentEmailUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTeamInput | SentEmailCreateOrConnectWithoutTeamInput[]
    createMany?: SentEmailCreateManyTeamInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type CustomDomainUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<CustomDomainCreateWithoutTeamInput, CustomDomainUncheckedCreateWithoutTeamInput> | CustomDomainCreateWithoutTeamInput[] | CustomDomainUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CustomDomainCreateOrConnectWithoutTeamInput | CustomDomainCreateOrConnectWithoutTeamInput[]
    createMany?: CustomDomainCreateManyTeamInputEnvelope
    connect?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<WebhookCreateWithoutTeamInput, WebhookUncheckedCreateWithoutTeamInput> | WebhookCreateWithoutTeamInput[] | WebhookUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTeamInput | WebhookCreateOrConnectWithoutTeamInput[]
    createMany?: WebhookCreateManyTeamInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamInviteUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamInviteCreateWithoutTeamInput, TeamInviteUncheckedCreateWithoutTeamInput> | TeamInviteCreateWithoutTeamInput[] | TeamInviteUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutTeamInput | TeamInviteCreateOrConnectWithoutTeamInput[]
    upsert?: TeamInviteUpsertWithWhereUniqueWithoutTeamInput | TeamInviteUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamInviteCreateManyTeamInputEnvelope
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    update?: TeamInviteUpdateWithWhereUniqueWithoutTeamInput | TeamInviteUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamInviteUpdateManyWithWhereWithoutTeamInput | TeamInviteUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[]
  }

  export type EmailTemplateUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutTeamInput, EmailTemplateUncheckedCreateWithoutTeamInput> | EmailTemplateCreateWithoutTeamInput[] | EmailTemplateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutTeamInput | EmailTemplateCreateOrConnectWithoutTeamInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutTeamInput | EmailTemplateUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmailTemplateCreateManyTeamInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutTeamInput | EmailTemplateUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutTeamInput | EmailTemplateUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type MailingListUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MailingListCreateWithoutTeamInput, MailingListUncheckedCreateWithoutTeamInput> | MailingListCreateWithoutTeamInput[] | MailingListUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MailingListCreateOrConnectWithoutTeamInput | MailingListCreateOrConnectWithoutTeamInput[]
    upsert?: MailingListUpsertWithWhereUniqueWithoutTeamInput | MailingListUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MailingListCreateManyTeamInputEnvelope
    set?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    disconnect?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    delete?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    connect?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    update?: MailingListUpdateWithWhereUniqueWithoutTeamInput | MailingListUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MailingListUpdateManyWithWhereWithoutTeamInput | MailingListUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MailingListScalarWhereInput | MailingListScalarWhereInput[]
  }

  export type AutomationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AutomationCreateWithoutTeamInput, AutomationUncheckedCreateWithoutTeamInput> | AutomationCreateWithoutTeamInput[] | AutomationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTeamInput | AutomationCreateOrConnectWithoutTeamInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutTeamInput | AutomationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AutomationCreateManyTeamInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutTeamInput | AutomationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutTeamInput | AutomationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CampaignCreateWithoutTeamInput, CampaignUncheckedCreateWithoutTeamInput> | CampaignCreateWithoutTeamInput[] | CampaignUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamInput | CampaignCreateOrConnectWithoutTeamInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTeamInput | CampaignUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CampaignCreateManyTeamInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTeamInput | CampaignUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTeamInput | CampaignUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ApiKeyCreateWithoutTeamInput, ApiKeyUncheckedCreateWithoutTeamInput> | ApiKeyCreateWithoutTeamInput[] | ApiKeyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTeamInput | ApiKeyCreateOrConnectWithoutTeamInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutTeamInput | ApiKeyUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ApiKeyCreateManyTeamInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutTeamInput | ApiKeyUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutTeamInput | ApiKeyUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type SmtpConfigUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SmtpConfigCreateWithoutTeamInput, SmtpConfigUncheckedCreateWithoutTeamInput> | SmtpConfigCreateWithoutTeamInput[] | SmtpConfigUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SmtpConfigCreateOrConnectWithoutTeamInput | SmtpConfigCreateOrConnectWithoutTeamInput[]
    upsert?: SmtpConfigUpsertWithWhereUniqueWithoutTeamInput | SmtpConfigUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SmtpConfigCreateManyTeamInputEnvelope
    set?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    disconnect?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    delete?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    connect?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    update?: SmtpConfigUpdateWithWhereUniqueWithoutTeamInput | SmtpConfigUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SmtpConfigUpdateManyWithWhereWithoutTeamInput | SmtpConfigUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SmtpConfigScalarWhereInput | SmtpConfigScalarWhereInput[]
  }

  export type SentEmailUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SentEmailCreateWithoutTeamInput, SentEmailUncheckedCreateWithoutTeamInput> | SentEmailCreateWithoutTeamInput[] | SentEmailUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTeamInput | SentEmailCreateOrConnectWithoutTeamInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutTeamInput | SentEmailUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SentEmailCreateManyTeamInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutTeamInput | SentEmailUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutTeamInput | SentEmailUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type CustomDomainUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CustomDomainCreateWithoutTeamInput, CustomDomainUncheckedCreateWithoutTeamInput> | CustomDomainCreateWithoutTeamInput[] | CustomDomainUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CustomDomainCreateOrConnectWithoutTeamInput | CustomDomainCreateOrConnectWithoutTeamInput[]
    upsert?: CustomDomainUpsertWithWhereUniqueWithoutTeamInput | CustomDomainUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CustomDomainCreateManyTeamInputEnvelope
    set?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    disconnect?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    delete?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    connect?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    update?: CustomDomainUpdateWithWhereUniqueWithoutTeamInput | CustomDomainUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CustomDomainUpdateManyWithWhereWithoutTeamInput | CustomDomainUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CustomDomainScalarWhereInput | CustomDomainScalarWhereInput[]
  }

  export type WebhookUpdateManyWithoutTeamNestedInput = {
    create?: XOR<WebhookCreateWithoutTeamInput, WebhookUncheckedCreateWithoutTeamInput> | WebhookCreateWithoutTeamInput[] | WebhookUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTeamInput | WebhookCreateOrConnectWithoutTeamInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutTeamInput | WebhookUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: WebhookCreateManyTeamInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutTeamInput | WebhookUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutTeamInput | WebhookUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamInviteUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamInviteCreateWithoutTeamInput, TeamInviteUncheckedCreateWithoutTeamInput> | TeamInviteCreateWithoutTeamInput[] | TeamInviteUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteCreateOrConnectWithoutTeamInput | TeamInviteCreateOrConnectWithoutTeamInput[]
    upsert?: TeamInviteUpsertWithWhereUniqueWithoutTeamInput | TeamInviteUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamInviteCreateManyTeamInputEnvelope
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[]
    update?: TeamInviteUpdateWithWhereUniqueWithoutTeamInput | TeamInviteUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamInviteUpdateManyWithWhereWithoutTeamInput | TeamInviteUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[]
  }

  export type EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutTeamInput, EmailTemplateUncheckedCreateWithoutTeamInput> | EmailTemplateCreateWithoutTeamInput[] | EmailTemplateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutTeamInput | EmailTemplateCreateOrConnectWithoutTeamInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutTeamInput | EmailTemplateUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmailTemplateCreateManyTeamInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutTeamInput | EmailTemplateUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutTeamInput | EmailTemplateUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type MailingListUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MailingListCreateWithoutTeamInput, MailingListUncheckedCreateWithoutTeamInput> | MailingListCreateWithoutTeamInput[] | MailingListUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MailingListCreateOrConnectWithoutTeamInput | MailingListCreateOrConnectWithoutTeamInput[]
    upsert?: MailingListUpsertWithWhereUniqueWithoutTeamInput | MailingListUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MailingListCreateManyTeamInputEnvelope
    set?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    disconnect?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    delete?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    connect?: MailingListWhereUniqueInput | MailingListWhereUniqueInput[]
    update?: MailingListUpdateWithWhereUniqueWithoutTeamInput | MailingListUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MailingListUpdateManyWithWhereWithoutTeamInput | MailingListUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MailingListScalarWhereInput | MailingListScalarWhereInput[]
  }

  export type AutomationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AutomationCreateWithoutTeamInput, AutomationUncheckedCreateWithoutTeamInput> | AutomationCreateWithoutTeamInput[] | AutomationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTeamInput | AutomationCreateOrConnectWithoutTeamInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutTeamInput | AutomationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AutomationCreateManyTeamInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutTeamInput | AutomationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutTeamInput | AutomationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CampaignCreateWithoutTeamInput, CampaignUncheckedCreateWithoutTeamInput> | CampaignCreateWithoutTeamInput[] | CampaignUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamInput | CampaignCreateOrConnectWithoutTeamInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTeamInput | CampaignUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CampaignCreateManyTeamInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTeamInput | CampaignUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTeamInput | CampaignUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ApiKeyCreateWithoutTeamInput, ApiKeyUncheckedCreateWithoutTeamInput> | ApiKeyCreateWithoutTeamInput[] | ApiKeyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTeamInput | ApiKeyCreateOrConnectWithoutTeamInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutTeamInput | ApiKeyUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ApiKeyCreateManyTeamInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutTeamInput | ApiKeyUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutTeamInput | ApiKeyUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SmtpConfigCreateWithoutTeamInput, SmtpConfigUncheckedCreateWithoutTeamInput> | SmtpConfigCreateWithoutTeamInput[] | SmtpConfigUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SmtpConfigCreateOrConnectWithoutTeamInput | SmtpConfigCreateOrConnectWithoutTeamInput[]
    upsert?: SmtpConfigUpsertWithWhereUniqueWithoutTeamInput | SmtpConfigUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SmtpConfigCreateManyTeamInputEnvelope
    set?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    disconnect?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    delete?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    connect?: SmtpConfigWhereUniqueInput | SmtpConfigWhereUniqueInput[]
    update?: SmtpConfigUpdateWithWhereUniqueWithoutTeamInput | SmtpConfigUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SmtpConfigUpdateManyWithWhereWithoutTeamInput | SmtpConfigUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SmtpConfigScalarWhereInput | SmtpConfigScalarWhereInput[]
  }

  export type SentEmailUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SentEmailCreateWithoutTeamInput, SentEmailUncheckedCreateWithoutTeamInput> | SentEmailCreateWithoutTeamInput[] | SentEmailUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTeamInput | SentEmailCreateOrConnectWithoutTeamInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutTeamInput | SentEmailUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SentEmailCreateManyTeamInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutTeamInput | SentEmailUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutTeamInput | SentEmailUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type CustomDomainUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CustomDomainCreateWithoutTeamInput, CustomDomainUncheckedCreateWithoutTeamInput> | CustomDomainCreateWithoutTeamInput[] | CustomDomainUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CustomDomainCreateOrConnectWithoutTeamInput | CustomDomainCreateOrConnectWithoutTeamInput[]
    upsert?: CustomDomainUpsertWithWhereUniqueWithoutTeamInput | CustomDomainUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CustomDomainCreateManyTeamInputEnvelope
    set?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    disconnect?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    delete?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    connect?: CustomDomainWhereUniqueInput | CustomDomainWhereUniqueInput[]
    update?: CustomDomainUpdateWithWhereUniqueWithoutTeamInput | CustomDomainUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CustomDomainUpdateManyWithWhereWithoutTeamInput | CustomDomainUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CustomDomainScalarWhereInput | CustomDomainScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<WebhookCreateWithoutTeamInput, WebhookUncheckedCreateWithoutTeamInput> | WebhookCreateWithoutTeamInput[] | WebhookUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTeamInput | WebhookCreateOrConnectWithoutTeamInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutTeamInput | WebhookUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: WebhookCreateManyTeamInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutTeamInput | WebhookUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutTeamInput | WebhookUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutInvitesInput = {
    create?: XOR<TeamCreateWithoutInvitesInput, TeamUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitesInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitesSentInput = {
    create?: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesSentInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus
  }

  export type TeamUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<TeamCreateWithoutInvitesInput, TeamUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitesInput
    upsert?: TeamUpsertWithoutInvitesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutInvitesInput, TeamUpdateWithoutInvitesInput>, TeamUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutInvitesSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesSentInput
    upsert?: UserUpsertWithoutInvitesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitesSentInput, UserUpdateWithoutInvitesSentInput>, UserUncheckedUpdateWithoutInvitesSentInput>
  }

  export type ApiKeyCreatescopesInput = {
    set: string[]
  }

  export type TeamCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<TeamCreateWithoutApiKeysInput, TeamUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: TeamCreateOrConnectWithoutApiKeysInput
    connect?: TeamWhereUniqueInput
  }

  export type ApiKeyUsageCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
  }

  export type ApiKeyUsageUncheckedCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ApiKeyUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TeamUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<TeamCreateWithoutApiKeysInput, TeamUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: TeamCreateOrConnectWithoutApiKeysInput
    upsert?: TeamUpsertWithoutApiKeysInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutApiKeysInput, TeamUpdateWithoutApiKeysInput>, TeamUncheckedUpdateWithoutApiKeysInput>
  }

  export type ApiKeyUsageUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    upsert?: ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    set?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    disconnect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    delete?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    update?: ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput | ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
  }

  export type ApiKeyUsageUncheckedUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    upsert?: ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    set?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    disconnect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    delete?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    update?: ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput | ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
  }

  export type ApiKeyCreateNestedOneWithoutUsageStatsInput = {
    create?: XOR<ApiKeyCreateWithoutUsageStatsInput, ApiKeyUncheckedCreateWithoutUsageStatsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageStatsInput
    connect?: ApiKeyWhereUniqueInput
  }

  export type ApiKeyUpdateOneRequiredWithoutUsageStatsNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUsageStatsInput, ApiKeyUncheckedCreateWithoutUsageStatsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageStatsInput
    upsert?: ApiKeyUpsertWithoutUsageStatsInput
    connect?: ApiKeyWhereUniqueInput
    update?: XOR<XOR<ApiKeyUpdateToOneWithWhereWithoutUsageStatsInput, ApiKeyUpdateWithoutUsageStatsInput>, ApiKeyUncheckedUpdateWithoutUsageStatsInput>
  }

  export type EmailTemplateCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCampaignsInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<TeamCreateWithoutCampaignsInput, TeamUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCampaignsInput
    connect?: TeamWhereUniqueInput
  }

  export type MailingListCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<MailingListCreateWithoutCampaignsInput, MailingListUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MailingListCreateOrConnectWithoutCampaignsInput
    connect?: MailingListWhereUniqueInput
  }

  export type SentEmailCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SentEmailCreateWithoutCampaignInput, SentEmailUncheckedCreateWithoutCampaignInput> | SentEmailCreateWithoutCampaignInput[] | SentEmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutCampaignInput | SentEmailCreateOrConnectWithoutCampaignInput[]
    createMany?: SentEmailCreateManyCampaignInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type CampaignAnalyticsCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignAnalyticsCreateWithoutCampaignInput, CampaignAnalyticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAnalyticsCreateOrConnectWithoutCampaignInput
    connect?: CampaignAnalyticsWhereUniqueInput
  }

  export type SmtpConfigCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<SmtpConfigCreateWithoutCampaignsInput, SmtpConfigUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: SmtpConfigCreateOrConnectWithoutCampaignsInput
    connect?: SmtpConfigWhereUniqueInput
  }

  export type EmailJobCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailJobCreateWithoutCampaignInput, EmailJobUncheckedCreateWithoutCampaignInput> | EmailJobCreateWithoutCampaignInput[] | EmailJobUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailJobCreateOrConnectWithoutCampaignInput | EmailJobCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailJobCreateManyCampaignInputEnvelope
    connect?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
  }

  export type SentEmailUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SentEmailCreateWithoutCampaignInput, SentEmailUncheckedCreateWithoutCampaignInput> | SentEmailCreateWithoutCampaignInput[] | SentEmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutCampaignInput | SentEmailCreateOrConnectWithoutCampaignInput[]
    createMany?: SentEmailCreateManyCampaignInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignAnalyticsCreateWithoutCampaignInput, CampaignAnalyticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAnalyticsCreateOrConnectWithoutCampaignInput
    connect?: CampaignAnalyticsWhereUniqueInput
  }

  export type EmailJobUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailJobCreateWithoutCampaignInput, EmailJobUncheckedCreateWithoutCampaignInput> | EmailJobCreateWithoutCampaignInput[] | EmailJobUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailJobCreateOrConnectWithoutCampaignInput | EmailJobCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailJobCreateManyCampaignInputEnvelope
    connect?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type NullableEnumCampaignScheduleFieldUpdateOperationsInput = {
    set?: $Enums.CampaignSchedule | null
  }

  export type NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput = {
    set?: $Enums.CampaignRecurringSchedule | null
  }

  export type EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCampaignsInput
    upsert?: EmailTemplateUpsertWithoutCampaignsInput
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutCampaignsInput, EmailTemplateUpdateWithoutCampaignsInput>, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type TeamUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<TeamCreateWithoutCampaignsInput, TeamUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCampaignsInput
    upsert?: TeamUpsertWithoutCampaignsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutCampaignsInput, TeamUpdateWithoutCampaignsInput>, TeamUncheckedUpdateWithoutCampaignsInput>
  }

  export type MailingListUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<MailingListCreateWithoutCampaignsInput, MailingListUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MailingListCreateOrConnectWithoutCampaignsInput
    upsert?: MailingListUpsertWithoutCampaignsInput
    connect?: MailingListWhereUniqueInput
    update?: XOR<XOR<MailingListUpdateToOneWithWhereWithoutCampaignsInput, MailingListUpdateWithoutCampaignsInput>, MailingListUncheckedUpdateWithoutCampaignsInput>
  }

  export type SentEmailUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SentEmailCreateWithoutCampaignInput, SentEmailUncheckedCreateWithoutCampaignInput> | SentEmailCreateWithoutCampaignInput[] | SentEmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutCampaignInput | SentEmailCreateOrConnectWithoutCampaignInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutCampaignInput | SentEmailUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SentEmailCreateManyCampaignInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutCampaignInput | SentEmailUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutCampaignInput | SentEmailUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type CampaignAnalyticsUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignAnalyticsCreateWithoutCampaignInput, CampaignAnalyticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAnalyticsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignAnalyticsUpsertWithoutCampaignInput
    disconnect?: CampaignAnalyticsWhereInput | boolean
    delete?: CampaignAnalyticsWhereInput | boolean
    connect?: CampaignAnalyticsWhereUniqueInput
    update?: XOR<XOR<CampaignAnalyticsUpdateToOneWithWhereWithoutCampaignInput, CampaignAnalyticsUpdateWithoutCampaignInput>, CampaignAnalyticsUncheckedUpdateWithoutCampaignInput>
  }

  export type SmtpConfigUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<SmtpConfigCreateWithoutCampaignsInput, SmtpConfigUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: SmtpConfigCreateOrConnectWithoutCampaignsInput
    upsert?: SmtpConfigUpsertWithoutCampaignsInput
    disconnect?: SmtpConfigWhereInput | boolean
    delete?: SmtpConfigWhereInput | boolean
    connect?: SmtpConfigWhereUniqueInput
    update?: XOR<XOR<SmtpConfigUpdateToOneWithWhereWithoutCampaignsInput, SmtpConfigUpdateWithoutCampaignsInput>, SmtpConfigUncheckedUpdateWithoutCampaignsInput>
  }

  export type EmailJobUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailJobCreateWithoutCampaignInput, EmailJobUncheckedCreateWithoutCampaignInput> | EmailJobCreateWithoutCampaignInput[] | EmailJobUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailJobCreateOrConnectWithoutCampaignInput | EmailJobCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailJobUpsertWithWhereUniqueWithoutCampaignInput | EmailJobUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailJobCreateManyCampaignInputEnvelope
    set?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    disconnect?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    delete?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    connect?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    update?: EmailJobUpdateWithWhereUniqueWithoutCampaignInput | EmailJobUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailJobUpdateManyWithWhereWithoutCampaignInput | EmailJobUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailJobScalarWhereInput | EmailJobScalarWhereInput[]
  }

  export type SentEmailUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SentEmailCreateWithoutCampaignInput, SentEmailUncheckedCreateWithoutCampaignInput> | SentEmailCreateWithoutCampaignInput[] | SentEmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutCampaignInput | SentEmailCreateOrConnectWithoutCampaignInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutCampaignInput | SentEmailUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SentEmailCreateManyCampaignInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutCampaignInput | SentEmailUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutCampaignInput | SentEmailUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignAnalyticsCreateWithoutCampaignInput, CampaignAnalyticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAnalyticsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignAnalyticsUpsertWithoutCampaignInput
    disconnect?: CampaignAnalyticsWhereInput | boolean
    delete?: CampaignAnalyticsWhereInput | boolean
    connect?: CampaignAnalyticsWhereUniqueInput
    update?: XOR<XOR<CampaignAnalyticsUpdateToOneWithWhereWithoutCampaignInput, CampaignAnalyticsUpdateWithoutCampaignInput>, CampaignAnalyticsUncheckedUpdateWithoutCampaignInput>
  }

  export type EmailJobUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailJobCreateWithoutCampaignInput, EmailJobUncheckedCreateWithoutCampaignInput> | EmailJobCreateWithoutCampaignInput[] | EmailJobUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailJobCreateOrConnectWithoutCampaignInput | EmailJobCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailJobUpsertWithWhereUniqueWithoutCampaignInput | EmailJobUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailJobCreateManyCampaignInputEnvelope
    set?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    disconnect?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    delete?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    connect?: EmailJobWhereUniqueInput | EmailJobWhereUniqueInput[]
    update?: EmailJobUpdateWithWhereUniqueWithoutCampaignInput | EmailJobUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailJobUpdateManyWithWhereWithoutCampaignInput | EmailJobUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailJobScalarWhereInput | EmailJobScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutListsInput = {
    create?: XOR<TeamCreateWithoutListsInput, TeamUncheckedCreateWithoutListsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutListsInput
    connect?: TeamWhereUniqueInput
  }

  export type SubscriberCreateNestedManyWithoutMailingListInput = {
    create?: XOR<SubscriberCreateWithoutMailingListInput, SubscriberUncheckedCreateWithoutMailingListInput> | SubscriberCreateWithoutMailingListInput[] | SubscriberUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutMailingListInput | SubscriberCreateOrConnectWithoutMailingListInput[]
    createMany?: SubscriberCreateManyMailingListInputEnvelope
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutMailingListInput = {
    create?: XOR<CampaignCreateWithoutMailingListInput, CampaignUncheckedCreateWithoutMailingListInput> | CampaignCreateWithoutMailingListInput[] | CampaignUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMailingListInput | CampaignCreateOrConnectWithoutMailingListInput[]
    createMany?: CampaignCreateManyMailingListInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type SubscriberUncheckedCreateNestedManyWithoutMailingListInput = {
    create?: XOR<SubscriberCreateWithoutMailingListInput, SubscriberUncheckedCreateWithoutMailingListInput> | SubscriberCreateWithoutMailingListInput[] | SubscriberUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutMailingListInput | SubscriberCreateOrConnectWithoutMailingListInput[]
    createMany?: SubscriberCreateManyMailingListInputEnvelope
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutMailingListInput = {
    create?: XOR<CampaignCreateWithoutMailingListInput, CampaignUncheckedCreateWithoutMailingListInput> | CampaignCreateWithoutMailingListInput[] | CampaignUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMailingListInput | CampaignCreateOrConnectWithoutMailingListInput[]
    createMany?: CampaignCreateManyMailingListInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type TeamUpdateOneRequiredWithoutListsNestedInput = {
    create?: XOR<TeamCreateWithoutListsInput, TeamUncheckedCreateWithoutListsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutListsInput
    upsert?: TeamUpsertWithoutListsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutListsInput, TeamUpdateWithoutListsInput>, TeamUncheckedUpdateWithoutListsInput>
  }

  export type SubscriberUpdateManyWithoutMailingListNestedInput = {
    create?: XOR<SubscriberCreateWithoutMailingListInput, SubscriberUncheckedCreateWithoutMailingListInput> | SubscriberCreateWithoutMailingListInput[] | SubscriberUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutMailingListInput | SubscriberCreateOrConnectWithoutMailingListInput[]
    upsert?: SubscriberUpsertWithWhereUniqueWithoutMailingListInput | SubscriberUpsertWithWhereUniqueWithoutMailingListInput[]
    createMany?: SubscriberCreateManyMailingListInputEnvelope
    set?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    disconnect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    delete?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    update?: SubscriberUpdateWithWhereUniqueWithoutMailingListInput | SubscriberUpdateWithWhereUniqueWithoutMailingListInput[]
    updateMany?: SubscriberUpdateManyWithWhereWithoutMailingListInput | SubscriberUpdateManyWithWhereWithoutMailingListInput[]
    deleteMany?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutMailingListNestedInput = {
    create?: XOR<CampaignCreateWithoutMailingListInput, CampaignUncheckedCreateWithoutMailingListInput> | CampaignCreateWithoutMailingListInput[] | CampaignUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMailingListInput | CampaignCreateOrConnectWithoutMailingListInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutMailingListInput | CampaignUpsertWithWhereUniqueWithoutMailingListInput[]
    createMany?: CampaignCreateManyMailingListInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutMailingListInput | CampaignUpdateWithWhereUniqueWithoutMailingListInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutMailingListInput | CampaignUpdateManyWithWhereWithoutMailingListInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type SubscriberUncheckedUpdateManyWithoutMailingListNestedInput = {
    create?: XOR<SubscriberCreateWithoutMailingListInput, SubscriberUncheckedCreateWithoutMailingListInput> | SubscriberCreateWithoutMailingListInput[] | SubscriberUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutMailingListInput | SubscriberCreateOrConnectWithoutMailingListInput[]
    upsert?: SubscriberUpsertWithWhereUniqueWithoutMailingListInput | SubscriberUpsertWithWhereUniqueWithoutMailingListInput[]
    createMany?: SubscriberCreateManyMailingListInputEnvelope
    set?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    disconnect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    delete?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    update?: SubscriberUpdateWithWhereUniqueWithoutMailingListInput | SubscriberUpdateWithWhereUniqueWithoutMailingListInput[]
    updateMany?: SubscriberUpdateManyWithWhereWithoutMailingListInput | SubscriberUpdateManyWithWhereWithoutMailingListInput[]
    deleteMany?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutMailingListNestedInput = {
    create?: XOR<CampaignCreateWithoutMailingListInput, CampaignUncheckedCreateWithoutMailingListInput> | CampaignCreateWithoutMailingListInput[] | CampaignUncheckedCreateWithoutMailingListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMailingListInput | CampaignCreateOrConnectWithoutMailingListInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutMailingListInput | CampaignUpsertWithWhereUniqueWithoutMailingListInput[]
    createMany?: CampaignCreateManyMailingListInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutMailingListInput | CampaignUpdateWithWhereUniqueWithoutMailingListInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutMailingListInput | CampaignUpdateManyWithWhereWithoutMailingListInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type SubscriberCreatetagsInput = {
    set: string[]
  }

  export type MailingListCreateNestedOneWithoutSubscribersInput = {
    create?: XOR<MailingListCreateWithoutSubscribersInput, MailingListUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: MailingListCreateOrConnectWithoutSubscribersInput
    connect?: MailingListWhereUniqueInput
  }

  export type SentEmailCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<SentEmailCreateWithoutSubscriberInput, SentEmailUncheckedCreateWithoutSubscriberInput> | SentEmailCreateWithoutSubscriberInput[] | SentEmailUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutSubscriberInput | SentEmailCreateOrConnectWithoutSubscriberInput[]
    createMany?: SentEmailCreateManySubscriberInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type SentEmailUncheckedCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<SentEmailCreateWithoutSubscriberInput, SentEmailUncheckedCreateWithoutSubscriberInput> | SentEmailCreateWithoutSubscriberInput[] | SentEmailUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutSubscriberInput | SentEmailCreateOrConnectWithoutSubscriberInput[]
    createMany?: SentEmailCreateManySubscriberInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type SubscriberUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumSubscriberStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriberStatus
  }

  export type MailingListUpdateOneRequiredWithoutSubscribersNestedInput = {
    create?: XOR<MailingListCreateWithoutSubscribersInput, MailingListUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: MailingListCreateOrConnectWithoutSubscribersInput
    upsert?: MailingListUpsertWithoutSubscribersInput
    connect?: MailingListWhereUniqueInput
    update?: XOR<XOR<MailingListUpdateToOneWithWhereWithoutSubscribersInput, MailingListUpdateWithoutSubscribersInput>, MailingListUncheckedUpdateWithoutSubscribersInput>
  }

  export type SentEmailUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<SentEmailCreateWithoutSubscriberInput, SentEmailUncheckedCreateWithoutSubscriberInput> | SentEmailCreateWithoutSubscriberInput[] | SentEmailUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutSubscriberInput | SentEmailCreateOrConnectWithoutSubscriberInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutSubscriberInput | SentEmailUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: SentEmailCreateManySubscriberInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutSubscriberInput | SentEmailUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutSubscriberInput | SentEmailUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type SentEmailUncheckedUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<SentEmailCreateWithoutSubscriberInput, SentEmailUncheckedCreateWithoutSubscriberInput> | SentEmailCreateWithoutSubscriberInput[] | SentEmailUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutSubscriberInput | SentEmailCreateOrConnectWithoutSubscriberInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutSubscriberInput | SentEmailUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: SentEmailCreateManySubscriberInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutSubscriberInput | SentEmailUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutSubscriberInput | SentEmailUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type EmailTemplateCreateNestedOneWithoutSentEmailsInput = {
    create?: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutSentEmailsInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutSentEmailsInput = {
    create?: XOR<CampaignCreateWithoutSentEmailsInput, CampaignUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSentEmailsInput
    connect?: CampaignWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSentEmailsInput = {
    create?: XOR<TeamCreateWithoutSentEmailsInput, TeamUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSentEmailsInput
    connect?: TeamWhereUniqueInput
  }

  export type EmailJobCreateNestedOneWithoutSentEmailsInput = {
    create?: XOR<EmailJobCreateWithoutSentEmailsInput, EmailJobUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: EmailJobCreateOrConnectWithoutSentEmailsInput
    connect?: EmailJobWhereUniqueInput
  }

  export type SubscriberCreateNestedOneWithoutSentEmailsInput = {
    create?: XOR<SubscriberCreateWithoutSentEmailsInput, SubscriberUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: SubscriberCreateOrConnectWithoutSentEmailsInput
    connect?: SubscriberWhereUniqueInput
  }

  export type EmailTrackingCreateNestedManyWithoutSentEmailInput = {
    create?: XOR<EmailTrackingCreateWithoutSentEmailInput, EmailTrackingUncheckedCreateWithoutSentEmailInput> | EmailTrackingCreateWithoutSentEmailInput[] | EmailTrackingUncheckedCreateWithoutSentEmailInput[]
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutSentEmailInput | EmailTrackingCreateOrConnectWithoutSentEmailInput[]
    createMany?: EmailTrackingCreateManySentEmailInputEnvelope
    connect?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
  }

  export type EmailTrackingUncheckedCreateNestedManyWithoutSentEmailInput = {
    create?: XOR<EmailTrackingCreateWithoutSentEmailInput, EmailTrackingUncheckedCreateWithoutSentEmailInput> | EmailTrackingCreateWithoutSentEmailInput[] | EmailTrackingUncheckedCreateWithoutSentEmailInput[]
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutSentEmailInput | EmailTrackingCreateOrConnectWithoutSentEmailInput[]
    createMany?: EmailTrackingCreateManySentEmailInputEnvelope
    connect?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
  }

  export type EnumEmailStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmailStatus
  }

  export type EmailTemplateUpdateOneWithoutSentEmailsNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutSentEmailsInput
    upsert?: EmailTemplateUpsertWithoutSentEmailsInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutSentEmailsInput, EmailTemplateUpdateWithoutSentEmailsInput>, EmailTemplateUncheckedUpdateWithoutSentEmailsInput>
  }

  export type CampaignUpdateOneWithoutSentEmailsNestedInput = {
    create?: XOR<CampaignCreateWithoutSentEmailsInput, CampaignUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSentEmailsInput
    upsert?: CampaignUpsertWithoutSentEmailsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSentEmailsInput, CampaignUpdateWithoutSentEmailsInput>, CampaignUncheckedUpdateWithoutSentEmailsInput>
  }

  export type TeamUpdateOneRequiredWithoutSentEmailsNestedInput = {
    create?: XOR<TeamCreateWithoutSentEmailsInput, TeamUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSentEmailsInput
    upsert?: TeamUpsertWithoutSentEmailsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSentEmailsInput, TeamUpdateWithoutSentEmailsInput>, TeamUncheckedUpdateWithoutSentEmailsInput>
  }

  export type EmailJobUpdateOneWithoutSentEmailsNestedInput = {
    create?: XOR<EmailJobCreateWithoutSentEmailsInput, EmailJobUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: EmailJobCreateOrConnectWithoutSentEmailsInput
    upsert?: EmailJobUpsertWithoutSentEmailsInput
    disconnect?: EmailJobWhereInput | boolean
    delete?: EmailJobWhereInput | boolean
    connect?: EmailJobWhereUniqueInput
    update?: XOR<XOR<EmailJobUpdateToOneWithWhereWithoutSentEmailsInput, EmailJobUpdateWithoutSentEmailsInput>, EmailJobUncheckedUpdateWithoutSentEmailsInput>
  }

  export type SubscriberUpdateOneWithoutSentEmailsNestedInput = {
    create?: XOR<SubscriberCreateWithoutSentEmailsInput, SubscriberUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: SubscriberCreateOrConnectWithoutSentEmailsInput
    upsert?: SubscriberUpsertWithoutSentEmailsInput
    disconnect?: SubscriberWhereInput | boolean
    delete?: SubscriberWhereInput | boolean
    connect?: SubscriberWhereUniqueInput
    update?: XOR<XOR<SubscriberUpdateToOneWithWhereWithoutSentEmailsInput, SubscriberUpdateWithoutSentEmailsInput>, SubscriberUncheckedUpdateWithoutSentEmailsInput>
  }

  export type EmailTrackingUpdateManyWithoutSentEmailNestedInput = {
    create?: XOR<EmailTrackingCreateWithoutSentEmailInput, EmailTrackingUncheckedCreateWithoutSentEmailInput> | EmailTrackingCreateWithoutSentEmailInput[] | EmailTrackingUncheckedCreateWithoutSentEmailInput[]
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutSentEmailInput | EmailTrackingCreateOrConnectWithoutSentEmailInput[]
    upsert?: EmailTrackingUpsertWithWhereUniqueWithoutSentEmailInput | EmailTrackingUpsertWithWhereUniqueWithoutSentEmailInput[]
    createMany?: EmailTrackingCreateManySentEmailInputEnvelope
    set?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    disconnect?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    delete?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    connect?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    update?: EmailTrackingUpdateWithWhereUniqueWithoutSentEmailInput | EmailTrackingUpdateWithWhereUniqueWithoutSentEmailInput[]
    updateMany?: EmailTrackingUpdateManyWithWhereWithoutSentEmailInput | EmailTrackingUpdateManyWithWhereWithoutSentEmailInput[]
    deleteMany?: EmailTrackingScalarWhereInput | EmailTrackingScalarWhereInput[]
  }

  export type EmailTrackingUncheckedUpdateManyWithoutSentEmailNestedInput = {
    create?: XOR<EmailTrackingCreateWithoutSentEmailInput, EmailTrackingUncheckedCreateWithoutSentEmailInput> | EmailTrackingCreateWithoutSentEmailInput[] | EmailTrackingUncheckedCreateWithoutSentEmailInput[]
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutSentEmailInput | EmailTrackingCreateOrConnectWithoutSentEmailInput[]
    upsert?: EmailTrackingUpsertWithWhereUniqueWithoutSentEmailInput | EmailTrackingUpsertWithWhereUniqueWithoutSentEmailInput[]
    createMany?: EmailTrackingCreateManySentEmailInputEnvelope
    set?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    disconnect?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    delete?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    connect?: EmailTrackingWhereUniqueInput | EmailTrackingWhereUniqueInput[]
    update?: EmailTrackingUpdateWithWhereUniqueWithoutSentEmailInput | EmailTrackingUpdateWithWhereUniqueWithoutSentEmailInput[]
    updateMany?: EmailTrackingUpdateManyWithWhereWithoutSentEmailInput | EmailTrackingUpdateManyWithWhereWithoutSentEmailInput[]
    deleteMany?: EmailTrackingScalarWhereInput | EmailTrackingScalarWhereInput[]
  }

  export type SentEmailCreateNestedOneWithoutTrackingInput = {
    create?: XOR<SentEmailCreateWithoutTrackingInput, SentEmailUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: SentEmailCreateOrConnectWithoutTrackingInput
    connect?: SentEmailWhereUniqueInput
  }

  export type EnumTrackingTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrackingType
  }

  export type SentEmailUpdateOneRequiredWithoutTrackingNestedInput = {
    create?: XOR<SentEmailCreateWithoutTrackingInput, SentEmailUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: SentEmailCreateOrConnectWithoutTrackingInput
    upsert?: SentEmailUpsertWithoutTrackingInput
    connect?: SentEmailWhereUniqueInput
    update?: XOR<XOR<SentEmailUpdateToOneWithWhereWithoutTrackingInput, SentEmailUpdateWithoutTrackingInput>, SentEmailUncheckedUpdateWithoutTrackingInput>
  }

  export type CampaignCreateNestedOneWithoutEmailJobsInput = {
    create?: XOR<CampaignCreateWithoutEmailJobsInput, CampaignUncheckedCreateWithoutEmailJobsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailJobsInput
    connect?: CampaignWhereUniqueInput
  }

  export type SentEmailCreateNestedManyWithoutEmailJobInput = {
    create?: XOR<SentEmailCreateWithoutEmailJobInput, SentEmailUncheckedCreateWithoutEmailJobInput> | SentEmailCreateWithoutEmailJobInput[] | SentEmailUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutEmailJobInput | SentEmailCreateOrConnectWithoutEmailJobInput[]
    createMany?: SentEmailCreateManyEmailJobInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type EmailJobLogCreateNestedManyWithoutEmailJobInput = {
    create?: XOR<EmailJobLogCreateWithoutEmailJobInput, EmailJobLogUncheckedCreateWithoutEmailJobInput> | EmailJobLogCreateWithoutEmailJobInput[] | EmailJobLogUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: EmailJobLogCreateOrConnectWithoutEmailJobInput | EmailJobLogCreateOrConnectWithoutEmailJobInput[]
    createMany?: EmailJobLogCreateManyEmailJobInputEnvelope
    connect?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
  }

  export type SentEmailUncheckedCreateNestedManyWithoutEmailJobInput = {
    create?: XOR<SentEmailCreateWithoutEmailJobInput, SentEmailUncheckedCreateWithoutEmailJobInput> | SentEmailCreateWithoutEmailJobInput[] | SentEmailUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutEmailJobInput | SentEmailCreateOrConnectWithoutEmailJobInput[]
    createMany?: SentEmailCreateManyEmailJobInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type EmailJobLogUncheckedCreateNestedManyWithoutEmailJobInput = {
    create?: XOR<EmailJobLogCreateWithoutEmailJobInput, EmailJobLogUncheckedCreateWithoutEmailJobInput> | EmailJobLogCreateWithoutEmailJobInput[] | EmailJobLogUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: EmailJobLogCreateOrConnectWithoutEmailJobInput | EmailJobLogCreateOrConnectWithoutEmailJobInput[]
    createMany?: EmailJobLogCreateManyEmailJobInputEnvelope
    connect?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type CampaignUpdateOneWithoutEmailJobsNestedInput = {
    create?: XOR<CampaignCreateWithoutEmailJobsInput, CampaignUncheckedCreateWithoutEmailJobsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailJobsInput
    upsert?: CampaignUpsertWithoutEmailJobsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEmailJobsInput, CampaignUpdateWithoutEmailJobsInput>, CampaignUncheckedUpdateWithoutEmailJobsInput>
  }

  export type SentEmailUpdateManyWithoutEmailJobNestedInput = {
    create?: XOR<SentEmailCreateWithoutEmailJobInput, SentEmailUncheckedCreateWithoutEmailJobInput> | SentEmailCreateWithoutEmailJobInput[] | SentEmailUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutEmailJobInput | SentEmailCreateOrConnectWithoutEmailJobInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutEmailJobInput | SentEmailUpsertWithWhereUniqueWithoutEmailJobInput[]
    createMany?: SentEmailCreateManyEmailJobInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutEmailJobInput | SentEmailUpdateWithWhereUniqueWithoutEmailJobInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutEmailJobInput | SentEmailUpdateManyWithWhereWithoutEmailJobInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type EmailJobLogUpdateManyWithoutEmailJobNestedInput = {
    create?: XOR<EmailJobLogCreateWithoutEmailJobInput, EmailJobLogUncheckedCreateWithoutEmailJobInput> | EmailJobLogCreateWithoutEmailJobInput[] | EmailJobLogUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: EmailJobLogCreateOrConnectWithoutEmailJobInput | EmailJobLogCreateOrConnectWithoutEmailJobInput[]
    upsert?: EmailJobLogUpsertWithWhereUniqueWithoutEmailJobInput | EmailJobLogUpsertWithWhereUniqueWithoutEmailJobInput[]
    createMany?: EmailJobLogCreateManyEmailJobInputEnvelope
    set?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    disconnect?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    delete?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    connect?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    update?: EmailJobLogUpdateWithWhereUniqueWithoutEmailJobInput | EmailJobLogUpdateWithWhereUniqueWithoutEmailJobInput[]
    updateMany?: EmailJobLogUpdateManyWithWhereWithoutEmailJobInput | EmailJobLogUpdateManyWithWhereWithoutEmailJobInput[]
    deleteMany?: EmailJobLogScalarWhereInput | EmailJobLogScalarWhereInput[]
  }

  export type SentEmailUncheckedUpdateManyWithoutEmailJobNestedInput = {
    create?: XOR<SentEmailCreateWithoutEmailJobInput, SentEmailUncheckedCreateWithoutEmailJobInput> | SentEmailCreateWithoutEmailJobInput[] | SentEmailUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutEmailJobInput | SentEmailCreateOrConnectWithoutEmailJobInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutEmailJobInput | SentEmailUpsertWithWhereUniqueWithoutEmailJobInput[]
    createMany?: SentEmailCreateManyEmailJobInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutEmailJobInput | SentEmailUpdateWithWhereUniqueWithoutEmailJobInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutEmailJobInput | SentEmailUpdateManyWithWhereWithoutEmailJobInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type EmailJobLogUncheckedUpdateManyWithoutEmailJobNestedInput = {
    create?: XOR<EmailJobLogCreateWithoutEmailJobInput, EmailJobLogUncheckedCreateWithoutEmailJobInput> | EmailJobLogCreateWithoutEmailJobInput[] | EmailJobLogUncheckedCreateWithoutEmailJobInput[]
    connectOrCreate?: EmailJobLogCreateOrConnectWithoutEmailJobInput | EmailJobLogCreateOrConnectWithoutEmailJobInput[]
    upsert?: EmailJobLogUpsertWithWhereUniqueWithoutEmailJobInput | EmailJobLogUpsertWithWhereUniqueWithoutEmailJobInput[]
    createMany?: EmailJobLogCreateManyEmailJobInputEnvelope
    set?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    disconnect?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    delete?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    connect?: EmailJobLogWhereUniqueInput | EmailJobLogWhereUniqueInput[]
    update?: EmailJobLogUpdateWithWhereUniqueWithoutEmailJobInput | EmailJobLogUpdateWithWhereUniqueWithoutEmailJobInput[]
    updateMany?: EmailJobLogUpdateManyWithWhereWithoutEmailJobInput | EmailJobLogUpdateManyWithWhereWithoutEmailJobInput[]
    deleteMany?: EmailJobLogScalarWhereInput | EmailJobLogScalarWhereInput[]
  }

  export type EmailJobCreateNestedOneWithoutLogsInput = {
    create?: XOR<EmailJobCreateWithoutLogsInput, EmailJobUncheckedCreateWithoutLogsInput>
    connectOrCreate?: EmailJobCreateOrConnectWithoutLogsInput
    connect?: EmailJobWhereUniqueInput
  }

  export type EnumLogLevelFieldUpdateOperationsInput = {
    set?: $Enums.LogLevel
  }

  export type EmailJobUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<EmailJobCreateWithoutLogsInput, EmailJobUncheckedCreateWithoutLogsInput>
    connectOrCreate?: EmailJobCreateOrConnectWithoutLogsInput
    upsert?: EmailJobUpsertWithoutLogsInput
    connect?: EmailJobWhereUniqueInput
    update?: XOR<XOR<EmailJobUpdateToOneWithWhereWithoutLogsInput, EmailJobUpdateWithoutLogsInput>, EmailJobUncheckedUpdateWithoutLogsInput>
  }

  export type CampaignCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<CampaignCreateWithoutAnalyticsInput, CampaignUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAnalyticsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<CampaignCreateWithoutAnalyticsInput, CampaignUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAnalyticsInput
    upsert?: CampaignUpsertWithoutAnalyticsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAnalyticsInput, CampaignUpdateWithoutAnalyticsInput>, CampaignUncheckedUpdateWithoutAnalyticsInput>
  }

  export type EmailTemplateCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EmailTemplateCreateWithoutCategoryInput, EmailTemplateUncheckedCreateWithoutCategoryInput> | EmailTemplateCreateWithoutCategoryInput[] | EmailTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCategoryInput | EmailTemplateCreateOrConnectWithoutCategoryInput[]
    createMany?: EmailTemplateCreateManyCategoryInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type EmailTemplateUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EmailTemplateCreateWithoutCategoryInput, EmailTemplateUncheckedCreateWithoutCategoryInput> | EmailTemplateCreateWithoutCategoryInput[] | EmailTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCategoryInput | EmailTemplateCreateOrConnectWithoutCategoryInput[]
    createMany?: EmailTemplateCreateManyCategoryInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type EmailTemplateUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCategoryInput, EmailTemplateUncheckedCreateWithoutCategoryInput> | EmailTemplateCreateWithoutCategoryInput[] | EmailTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCategoryInput | EmailTemplateCreateOrConnectWithoutCategoryInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutCategoryInput | EmailTemplateUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EmailTemplateCreateManyCategoryInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutCategoryInput | EmailTemplateUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutCategoryInput | EmailTemplateUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type EmailTemplateUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCategoryInput, EmailTemplateUncheckedCreateWithoutCategoryInput> | EmailTemplateCreateWithoutCategoryInput[] | EmailTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCategoryInput | EmailTemplateCreateOrConnectWithoutCategoryInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutCategoryInput | EmailTemplateUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EmailTemplateCreateManyCategoryInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutCategoryInput | EmailTemplateUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutCategoryInput | EmailTemplateUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type CampaignCreateNestedManyWithoutSmtpConfigInput = {
    create?: XOR<CampaignCreateWithoutSmtpConfigInput, CampaignUncheckedCreateWithoutSmtpConfigInput> | CampaignCreateWithoutSmtpConfigInput[] | CampaignUncheckedCreateWithoutSmtpConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSmtpConfigInput | CampaignCreateOrConnectWithoutSmtpConfigInput[]
    createMany?: CampaignCreateManySmtpConfigInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type TeamCreateNestedOneWithoutSmtpConfigsInput = {
    create?: XOR<TeamCreateWithoutSmtpConfigsInput, TeamUncheckedCreateWithoutSmtpConfigsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSmtpConfigsInput
    connect?: TeamWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutSmtpConfigInput = {
    create?: XOR<CampaignCreateWithoutSmtpConfigInput, CampaignUncheckedCreateWithoutSmtpConfigInput> | CampaignCreateWithoutSmtpConfigInput[] | CampaignUncheckedCreateWithoutSmtpConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSmtpConfigInput | CampaignCreateOrConnectWithoutSmtpConfigInput[]
    createMany?: CampaignCreateManySmtpConfigInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUpdateManyWithoutSmtpConfigNestedInput = {
    create?: XOR<CampaignCreateWithoutSmtpConfigInput, CampaignUncheckedCreateWithoutSmtpConfigInput> | CampaignCreateWithoutSmtpConfigInput[] | CampaignUncheckedCreateWithoutSmtpConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSmtpConfigInput | CampaignCreateOrConnectWithoutSmtpConfigInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSmtpConfigInput | CampaignUpsertWithWhereUniqueWithoutSmtpConfigInput[]
    createMany?: CampaignCreateManySmtpConfigInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSmtpConfigInput | CampaignUpdateWithWhereUniqueWithoutSmtpConfigInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSmtpConfigInput | CampaignUpdateManyWithWhereWithoutSmtpConfigInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type TeamUpdateOneRequiredWithoutSmtpConfigsNestedInput = {
    create?: XOR<TeamCreateWithoutSmtpConfigsInput, TeamUncheckedCreateWithoutSmtpConfigsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSmtpConfigsInput
    upsert?: TeamUpsertWithoutSmtpConfigsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSmtpConfigsInput, TeamUpdateWithoutSmtpConfigsInput>, TeamUncheckedUpdateWithoutSmtpConfigsInput>
  }

  export type CampaignUncheckedUpdateManyWithoutSmtpConfigNestedInput = {
    create?: XOR<CampaignCreateWithoutSmtpConfigInput, CampaignUncheckedCreateWithoutSmtpConfigInput> | CampaignCreateWithoutSmtpConfigInput[] | CampaignUncheckedCreateWithoutSmtpConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSmtpConfigInput | CampaignCreateOrConnectWithoutSmtpConfigInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSmtpConfigInput | CampaignUpsertWithWhereUniqueWithoutSmtpConfigInput[]
    createMany?: CampaignCreateManySmtpConfigInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSmtpConfigInput | CampaignUpdateWithWhereUniqueWithoutSmtpConfigInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSmtpConfigInput | CampaignUpdateManyWithWhereWithoutSmtpConfigInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutAutomationsInput = {
    create?: XOR<TeamCreateWithoutAutomationsInput, TeamUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAutomationsInput
    connect?: TeamWhereUniqueInput
  }

  export type AutomationNodeCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationNodeCreateWithoutAutomationInput, AutomationNodeUncheckedCreateWithoutAutomationInput> | AutomationNodeCreateWithoutAutomationInput[] | AutomationNodeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutAutomationInput | AutomationNodeCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationNodeCreateManyAutomationInputEnvelope
    connect?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
  }

  export type AutomationNodeEdgeCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutAutomationInput, AutomationNodeEdgeUncheckedCreateWithoutAutomationInput> | AutomationNodeEdgeCreateWithoutAutomationInput[] | AutomationNodeEdgeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutAutomationInput | AutomationNodeEdgeCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationNodeEdgeCreateManyAutomationInputEnvelope
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
  }

  export type AutomationNodeUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationNodeCreateWithoutAutomationInput, AutomationNodeUncheckedCreateWithoutAutomationInput> | AutomationNodeCreateWithoutAutomationInput[] | AutomationNodeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutAutomationInput | AutomationNodeCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationNodeCreateManyAutomationInputEnvelope
    connect?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
  }

  export type AutomationNodeEdgeUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutAutomationInput, AutomationNodeEdgeUncheckedCreateWithoutAutomationInput> | AutomationNodeEdgeCreateWithoutAutomationInput[] | AutomationNodeEdgeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutAutomationInput | AutomationNodeEdgeCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationNodeEdgeCreateManyAutomationInputEnvelope
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
  }

  export type TeamUpdateOneRequiredWithoutAutomationsNestedInput = {
    create?: XOR<TeamCreateWithoutAutomationsInput, TeamUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAutomationsInput
    upsert?: TeamUpsertWithoutAutomationsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutAutomationsInput, TeamUpdateWithoutAutomationsInput>, TeamUncheckedUpdateWithoutAutomationsInput>
  }

  export type AutomationNodeUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationNodeCreateWithoutAutomationInput, AutomationNodeUncheckedCreateWithoutAutomationInput> | AutomationNodeCreateWithoutAutomationInput[] | AutomationNodeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutAutomationInput | AutomationNodeCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationNodeUpsertWithWhereUniqueWithoutAutomationInput | AutomationNodeUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationNodeCreateManyAutomationInputEnvelope
    set?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    disconnect?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    delete?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    connect?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    update?: AutomationNodeUpdateWithWhereUniqueWithoutAutomationInput | AutomationNodeUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationNodeUpdateManyWithWhereWithoutAutomationInput | AutomationNodeUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationNodeScalarWhereInput | AutomationNodeScalarWhereInput[]
  }

  export type AutomationNodeEdgeUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutAutomationInput, AutomationNodeEdgeUncheckedCreateWithoutAutomationInput> | AutomationNodeEdgeCreateWithoutAutomationInput[] | AutomationNodeEdgeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutAutomationInput | AutomationNodeEdgeCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationNodeEdgeUpsertWithWhereUniqueWithoutAutomationInput | AutomationNodeEdgeUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationNodeEdgeCreateManyAutomationInputEnvelope
    set?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    disconnect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    delete?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    update?: AutomationNodeEdgeUpdateWithWhereUniqueWithoutAutomationInput | AutomationNodeEdgeUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationNodeEdgeUpdateManyWithWhereWithoutAutomationInput | AutomationNodeEdgeUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
  }

  export type AutomationNodeUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationNodeCreateWithoutAutomationInput, AutomationNodeUncheckedCreateWithoutAutomationInput> | AutomationNodeCreateWithoutAutomationInput[] | AutomationNodeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutAutomationInput | AutomationNodeCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationNodeUpsertWithWhereUniqueWithoutAutomationInput | AutomationNodeUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationNodeCreateManyAutomationInputEnvelope
    set?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    disconnect?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    delete?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    connect?: AutomationNodeWhereUniqueInput | AutomationNodeWhereUniqueInput[]
    update?: AutomationNodeUpdateWithWhereUniqueWithoutAutomationInput | AutomationNodeUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationNodeUpdateManyWithWhereWithoutAutomationInput | AutomationNodeUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationNodeScalarWhereInput | AutomationNodeScalarWhereInput[]
  }

  export type AutomationNodeEdgeUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutAutomationInput, AutomationNodeEdgeUncheckedCreateWithoutAutomationInput> | AutomationNodeEdgeCreateWithoutAutomationInput[] | AutomationNodeEdgeUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutAutomationInput | AutomationNodeEdgeCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationNodeEdgeUpsertWithWhereUniqueWithoutAutomationInput | AutomationNodeEdgeUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationNodeEdgeCreateManyAutomationInputEnvelope
    set?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    disconnect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    delete?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    update?: AutomationNodeEdgeUpdateWithWhereUniqueWithoutAutomationInput | AutomationNodeEdgeUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationNodeEdgeUpdateManyWithWhereWithoutAutomationInput | AutomationNodeEdgeUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
  }

  export type AutomationCreateNestedOneWithoutNodesInput = {
    create?: XOR<AutomationCreateWithoutNodesInput, AutomationUncheckedCreateWithoutNodesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutNodesInput
    connect?: AutomationWhereUniqueInput
  }

  export type AutomationNodeEdgeCreateNestedManyWithoutSourceInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutSourceInput, AutomationNodeEdgeUncheckedCreateWithoutSourceInput> | AutomationNodeEdgeCreateWithoutSourceInput[] | AutomationNodeEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutSourceInput | AutomationNodeEdgeCreateOrConnectWithoutSourceInput[]
    createMany?: AutomationNodeEdgeCreateManySourceInputEnvelope
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
  }

  export type AutomationNodeEdgeCreateNestedManyWithoutTargetInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutTargetInput, AutomationNodeEdgeUncheckedCreateWithoutTargetInput> | AutomationNodeEdgeCreateWithoutTargetInput[] | AutomationNodeEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutTargetInput | AutomationNodeEdgeCreateOrConnectWithoutTargetInput[]
    createMany?: AutomationNodeEdgeCreateManyTargetInputEnvelope
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
  }

  export type AutomationNodeEdgeUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutSourceInput, AutomationNodeEdgeUncheckedCreateWithoutSourceInput> | AutomationNodeEdgeCreateWithoutSourceInput[] | AutomationNodeEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutSourceInput | AutomationNodeEdgeCreateOrConnectWithoutSourceInput[]
    createMany?: AutomationNodeEdgeCreateManySourceInputEnvelope
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
  }

  export type AutomationNodeEdgeUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutTargetInput, AutomationNodeEdgeUncheckedCreateWithoutTargetInput> | AutomationNodeEdgeCreateWithoutTargetInput[] | AutomationNodeEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutTargetInput | AutomationNodeEdgeCreateOrConnectWithoutTargetInput[]
    createMany?: AutomationNodeEdgeCreateManyTargetInputEnvelope
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
  }

  export type EnumNodeTypeFieldUpdateOperationsInput = {
    set?: $Enums.NodeType
  }

  export type AutomationUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<AutomationCreateWithoutNodesInput, AutomationUncheckedCreateWithoutNodesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutNodesInput
    upsert?: AutomationUpsertWithoutNodesInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutNodesInput, AutomationUpdateWithoutNodesInput>, AutomationUncheckedUpdateWithoutNodesInput>
  }

  export type AutomationNodeEdgeUpdateManyWithoutSourceNestedInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutSourceInput, AutomationNodeEdgeUncheckedCreateWithoutSourceInput> | AutomationNodeEdgeCreateWithoutSourceInput[] | AutomationNodeEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutSourceInput | AutomationNodeEdgeCreateOrConnectWithoutSourceInput[]
    upsert?: AutomationNodeEdgeUpsertWithWhereUniqueWithoutSourceInput | AutomationNodeEdgeUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: AutomationNodeEdgeCreateManySourceInputEnvelope
    set?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    disconnect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    delete?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    update?: AutomationNodeEdgeUpdateWithWhereUniqueWithoutSourceInput | AutomationNodeEdgeUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: AutomationNodeEdgeUpdateManyWithWhereWithoutSourceInput | AutomationNodeEdgeUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
  }

  export type AutomationNodeEdgeUpdateManyWithoutTargetNestedInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutTargetInput, AutomationNodeEdgeUncheckedCreateWithoutTargetInput> | AutomationNodeEdgeCreateWithoutTargetInput[] | AutomationNodeEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutTargetInput | AutomationNodeEdgeCreateOrConnectWithoutTargetInput[]
    upsert?: AutomationNodeEdgeUpsertWithWhereUniqueWithoutTargetInput | AutomationNodeEdgeUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: AutomationNodeEdgeCreateManyTargetInputEnvelope
    set?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    disconnect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    delete?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    update?: AutomationNodeEdgeUpdateWithWhereUniqueWithoutTargetInput | AutomationNodeEdgeUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: AutomationNodeEdgeUpdateManyWithWhereWithoutTargetInput | AutomationNodeEdgeUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
  }

  export type AutomationNodeEdgeUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutSourceInput, AutomationNodeEdgeUncheckedCreateWithoutSourceInput> | AutomationNodeEdgeCreateWithoutSourceInput[] | AutomationNodeEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutSourceInput | AutomationNodeEdgeCreateOrConnectWithoutSourceInput[]
    upsert?: AutomationNodeEdgeUpsertWithWhereUniqueWithoutSourceInput | AutomationNodeEdgeUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: AutomationNodeEdgeCreateManySourceInputEnvelope
    set?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    disconnect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    delete?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    update?: AutomationNodeEdgeUpdateWithWhereUniqueWithoutSourceInput | AutomationNodeEdgeUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: AutomationNodeEdgeUpdateManyWithWhereWithoutSourceInput | AutomationNodeEdgeUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
  }

  export type AutomationNodeEdgeUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<AutomationNodeEdgeCreateWithoutTargetInput, AutomationNodeEdgeUncheckedCreateWithoutTargetInput> | AutomationNodeEdgeCreateWithoutTargetInput[] | AutomationNodeEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: AutomationNodeEdgeCreateOrConnectWithoutTargetInput | AutomationNodeEdgeCreateOrConnectWithoutTargetInput[]
    upsert?: AutomationNodeEdgeUpsertWithWhereUniqueWithoutTargetInput | AutomationNodeEdgeUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: AutomationNodeEdgeCreateManyTargetInputEnvelope
    set?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    disconnect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    delete?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    connect?: AutomationNodeEdgeWhereUniqueInput | AutomationNodeEdgeWhereUniqueInput[]
    update?: AutomationNodeEdgeUpdateWithWhereUniqueWithoutTargetInput | AutomationNodeEdgeUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: AutomationNodeEdgeUpdateManyWithWhereWithoutTargetInput | AutomationNodeEdgeUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
  }

  export type AutomationCreateNestedOneWithoutEdgesInput = {
    create?: XOR<AutomationCreateWithoutEdgesInput, AutomationUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutEdgesInput
    connect?: AutomationWhereUniqueInput
  }

  export type AutomationNodeCreateNestedOneWithoutEdgesFromInput = {
    create?: XOR<AutomationNodeCreateWithoutEdgesFromInput, AutomationNodeUncheckedCreateWithoutEdgesFromInput>
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutEdgesFromInput
    connect?: AutomationNodeWhereUniqueInput
  }

  export type AutomationNodeCreateNestedOneWithoutEdgesToInput = {
    create?: XOR<AutomationNodeCreateWithoutEdgesToInput, AutomationNodeUncheckedCreateWithoutEdgesToInput>
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutEdgesToInput
    connect?: AutomationNodeWhereUniqueInput
  }

  export type AutomationUpdateOneRequiredWithoutEdgesNestedInput = {
    create?: XOR<AutomationCreateWithoutEdgesInput, AutomationUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutEdgesInput
    upsert?: AutomationUpsertWithoutEdgesInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutEdgesInput, AutomationUpdateWithoutEdgesInput>, AutomationUncheckedUpdateWithoutEdgesInput>
  }

  export type AutomationNodeUpdateOneRequiredWithoutEdgesFromNestedInput = {
    create?: XOR<AutomationNodeCreateWithoutEdgesFromInput, AutomationNodeUncheckedCreateWithoutEdgesFromInput>
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutEdgesFromInput
    upsert?: AutomationNodeUpsertWithoutEdgesFromInput
    connect?: AutomationNodeWhereUniqueInput
    update?: XOR<XOR<AutomationNodeUpdateToOneWithWhereWithoutEdgesFromInput, AutomationNodeUpdateWithoutEdgesFromInput>, AutomationNodeUncheckedUpdateWithoutEdgesFromInput>
  }

  export type AutomationNodeUpdateOneRequiredWithoutEdgesToNestedInput = {
    create?: XOR<AutomationNodeCreateWithoutEdgesToInput, AutomationNodeUncheckedCreateWithoutEdgesToInput>
    connectOrCreate?: AutomationNodeCreateOrConnectWithoutEdgesToInput
    upsert?: AutomationNodeUpsertWithoutEdgesToInput
    connect?: AutomationNodeWhereUniqueInput
    update?: XOR<XOR<AutomationNodeUpdateToOneWithWhereWithoutEdgesToInput, AutomationNodeUpdateWithoutEdgesToInput>, AutomationNodeUncheckedUpdateWithoutEdgesToInput>
  }

  export type TeamCreateNestedOneWithoutCustomDomainsInput = {
    create?: XOR<TeamCreateWithoutCustomDomainsInput, TeamUncheckedCreateWithoutCustomDomainsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCustomDomainsInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutCustomDomainsNestedInput = {
    create?: XOR<TeamCreateWithoutCustomDomainsInput, TeamUncheckedCreateWithoutCustomDomainsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCustomDomainsInput
    upsert?: TeamUpsertWithoutCustomDomainsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutCustomDomainsInput, TeamUpdateWithoutCustomDomainsInput>, TeamUncheckedUpdateWithoutCustomDomainsInput>
  }

  export type WebhookEventCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookEventCreateWithoutWebhookInput, WebhookEventUncheckedCreateWithoutWebhookInput> | WebhookEventCreateWithoutWebhookInput[] | WebhookEventUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutWebhookInput | WebhookEventCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookEventCreateManyWebhookInputEnvelope
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
  }

  export type TeamCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<TeamCreateWithoutWebhooksInput, TeamUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutWebhooksInput
    connect?: TeamWhereUniqueInput
  }

  export type WebhookEventUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookEventCreateWithoutWebhookInput, WebhookEventUncheckedCreateWithoutWebhookInput> | WebhookEventCreateWithoutWebhookInput[] | WebhookEventUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutWebhookInput | WebhookEventCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookEventCreateManyWebhookInputEnvelope
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WebhookEventUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookEventCreateWithoutWebhookInput, WebhookEventUncheckedCreateWithoutWebhookInput> | WebhookEventCreateWithoutWebhookInput[] | WebhookEventUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutWebhookInput | WebhookEventCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookEventUpsertWithWhereUniqueWithoutWebhookInput | WebhookEventUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookEventCreateManyWebhookInputEnvelope
    set?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    disconnect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    delete?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    update?: WebhookEventUpdateWithWhereUniqueWithoutWebhookInput | WebhookEventUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookEventUpdateManyWithWhereWithoutWebhookInput | WebhookEventUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
  }

  export type TeamUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<TeamCreateWithoutWebhooksInput, TeamUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutWebhooksInput
    upsert?: TeamUpsertWithoutWebhooksInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutWebhooksInput, TeamUpdateWithoutWebhooksInput>, TeamUncheckedUpdateWithoutWebhooksInput>
  }

  export type WebhookEventUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookEventCreateWithoutWebhookInput, WebhookEventUncheckedCreateWithoutWebhookInput> | WebhookEventCreateWithoutWebhookInput[] | WebhookEventUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutWebhookInput | WebhookEventCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookEventUpsertWithWhereUniqueWithoutWebhookInput | WebhookEventUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookEventCreateManyWebhookInputEnvelope
    set?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    disconnect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    delete?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    update?: WebhookEventUpdateWithWhereUniqueWithoutWebhookInput | WebhookEventUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookEventUpdateManyWithWhereWithoutWebhookInput | WebhookEventUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutEventsInput = {
    create?: XOR<WebhookCreateWithoutEventsInput, WebhookUncheckedCreateWithoutEventsInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutEventsInput
    connect?: WebhookWhereUniqueInput
  }

  export type EnumWebhookEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.WebhookEventType
  }

  export type WebhookUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<WebhookCreateWithoutEventsInput, WebhookUncheckedCreateWithoutEventsInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutEventsInput
    upsert?: WebhookUpsertWithoutEventsInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutEventsInput, WebhookUpdateWithoutEventsInput>, WebhookUncheckedUpdateWithoutEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignScheduleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignSchedule | EnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignScheduleNullableFilter<$PrismaModel> | $Enums.CampaignSchedule | null
  }

  export type NestedEnumCampaignRecurringScheduleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRecurringSchedule | EnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignRecurringScheduleNullableFilter<$PrismaModel> | $Enums.CampaignRecurringSchedule | null
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumCampaignScheduleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignSchedule | EnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignSchedule[] | ListEnumCampaignScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignScheduleNullableWithAggregatesFilter<$PrismaModel> | $Enums.CampaignSchedule | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCampaignScheduleNullableFilter<$PrismaModel>
    _max?: NestedEnumCampaignScheduleNullableFilter<$PrismaModel>
  }

  export type NestedEnumCampaignRecurringScheduleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRecurringSchedule | EnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignRecurringSchedule[] | ListEnumCampaignRecurringScheduleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignRecurringScheduleNullableWithAggregatesFilter<$PrismaModel> | $Enums.CampaignRecurringSchedule | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCampaignRecurringScheduleNullableFilter<$PrismaModel>
    _max?: NestedEnumCampaignRecurringScheduleNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberStatus | EnumSubscriberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberStatusFilter<$PrismaModel> | $Enums.SubscriberStatus
  }

  export type NestedEnumSubscriberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberStatus | EnumSubscriberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberStatus[] | ListEnumSubscriberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriberStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriberStatusFilter<$PrismaModel>
  }

  export type NestedEnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrackingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingType | EnumTrackingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingTypeFilter<$PrismaModel> | $Enums.TrackingType
  }

  export type NestedEnumTrackingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingType | EnumTrackingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingType[] | ListEnumTrackingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackingTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NestedEnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type NestedEnumNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeFilter<$PrismaModel> | $Enums.NodeType
  }

  export type NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.NodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumWebhookEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEventType | EnumWebhookEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventTypeFilter<$PrismaModel> | $Enums.WebhookEventType
  }

  export type NestedEnumWebhookEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookEventType | EnumWebhookEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookEventType[] | ListEnumWebhookEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.WebhookEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookEventTypeFilter<$PrismaModel>
    _max?: NestedEnumWebhookEventTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TeamCreateWithoutTemplatesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTemplatesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTemplatesInput, TeamUncheckedCreateWithoutTemplatesInput>
  }

  export type CampaignCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutCampaignsInput
    mailingList: MailingListCreateNestedOneWithoutCampaignsInput
    sentEmails?: SentEmailCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsCreateNestedOneWithoutCampaignInput
    smtpConfig?: SmtpConfigCreateNestedOneWithoutCampaignsInput
    emailJobs?: EmailJobCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput
    emailJobs?: EmailJobUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput>
  }

  export type CampaignCreateManyTemplateInputEnvelope = {
    data: CampaignCreateManyTemplateInput | CampaignCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type SentEmailCreateWithoutTemplateInput = {
    id?: string
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaign?: CampaignCreateNestedOneWithoutSentEmailsInput
    team: TeamCreateNestedOneWithoutSentEmailsInput
    emailJob?: EmailJobCreateNestedOneWithoutSentEmailsInput
    subscriber?: SubscriberCreateNestedOneWithoutSentEmailsInput
    tracking?: EmailTrackingCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailUncheckedCreateWithoutTemplateInput = {
    id?: string
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
    tracking?: EmailTrackingUncheckedCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailCreateOrConnectWithoutTemplateInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput>
  }

  export type SentEmailCreateManyTemplateInputEnvelope = {
    data: SentEmailCreateManyTemplateInput | SentEmailCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type EmailCategoryCreateWithoutTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCategoryUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCategoryCreateOrConnectWithoutTemplatesInput = {
    where: EmailCategoryWhereUniqueInput
    create: XOR<EmailCategoryCreateWithoutTemplatesInput, EmailCategoryUncheckedCreateWithoutTemplatesInput>
  }

  export type TeamUpsertWithoutTemplatesInput = {
    update: XOR<TeamUpdateWithoutTemplatesInput, TeamUncheckedUpdateWithoutTemplatesInput>
    create: XOR<TeamCreateWithoutTemplatesInput, TeamUncheckedCreateWithoutTemplatesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTemplatesInput, TeamUncheckedUpdateWithoutTemplatesInput>
  }

  export type TeamUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutTemplateInput, CampaignUncheckedUpdateWithoutTemplateInput>
    create: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutTemplateInput, CampaignUncheckedUpdateWithoutTemplateInput>
  }

  export type CampaignUpdateManyWithWhereWithoutTemplateInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutTemplateInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    templateId?: StringFilter<"Campaign"> | string
    teamId?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    schedule?: EnumCampaignScheduleNullableFilter<"Campaign"> | $Enums.CampaignSchedule | null
    listId?: StringFilter<"Campaign"> | string
    recurringSchedule?: EnumCampaignRecurringScheduleNullableFilter<"Campaign"> | $Enums.CampaignRecurringSchedule | null
    cronExpression?: StringNullableFilter<"Campaign"> | string | null
    smtpConfigId?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type SentEmailUpsertWithWhereUniqueWithoutTemplateInput = {
    where: SentEmailWhereUniqueInput
    update: XOR<SentEmailUpdateWithoutTemplateInput, SentEmailUncheckedUpdateWithoutTemplateInput>
    create: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput>
  }

  export type SentEmailUpdateWithWhereUniqueWithoutTemplateInput = {
    where: SentEmailWhereUniqueInput
    data: XOR<SentEmailUpdateWithoutTemplateInput, SentEmailUncheckedUpdateWithoutTemplateInput>
  }

  export type SentEmailUpdateManyWithWhereWithoutTemplateInput = {
    where: SentEmailScalarWhereInput
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyWithoutTemplateInput>
  }

  export type SentEmailScalarWhereInput = {
    AND?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
    OR?: SentEmailScalarWhereInput[]
    NOT?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
    id?: StringFilter<"SentEmail"> | string
    templateId?: StringNullableFilter<"SentEmail"> | string | null
    campaignId?: StringNullableFilter<"SentEmail"> | string | null
    recipient?: StringFilter<"SentEmail"> | string
    subject?: StringFilter<"SentEmail"> | string
    content?: StringNullableFilter<"SentEmail"> | string | null
    status?: EnumEmailStatusFilter<"SentEmail"> | $Enums.EmailStatus
    sentAt?: DateTimeFilter<"SentEmail"> | Date | string
    openedAt?: DateTimeNullableFilter<"SentEmail"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"SentEmail"> | Date | string | null
    teamId?: StringFilter<"SentEmail"> | string
    error?: StringNullableFilter<"SentEmail"> | string | null
    metadata?: JsonNullableFilter<"SentEmail">
    jobId?: StringNullableFilter<"SentEmail"> | string | null
    subscriberId?: StringNullableFilter<"SentEmail"> | string | null
  }

  export type EmailCategoryUpsertWithoutTemplatesInput = {
    update: XOR<EmailCategoryUpdateWithoutTemplatesInput, EmailCategoryUncheckedUpdateWithoutTemplatesInput>
    create: XOR<EmailCategoryCreateWithoutTemplatesInput, EmailCategoryUncheckedCreateWithoutTemplatesInput>
    where?: EmailCategoryWhereInput
  }

  export type EmailCategoryUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: EmailCategoryWhereInput
    data: XOR<EmailCategoryUpdateWithoutTemplatesInput, EmailCategoryUncheckedUpdateWithoutTemplatesInput>
  }

  export type EmailCategoryUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCategoryUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateWithoutUsersInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutUsersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
  }

  export type TeamInviteCreateWithoutInviterInput = {
    id?: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    team: TeamCreateNestedOneWithoutInvitesInput
  }

  export type TeamInviteUncheckedCreateWithoutInviterInput = {
    id?: string
    teamId: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
  }

  export type TeamInviteCreateOrConnectWithoutInviterInput = {
    where: TeamInviteWhereUniqueInput
    create: XOR<TeamInviteCreateWithoutInviterInput, TeamInviteUncheckedCreateWithoutInviterInput>
  }

  export type TeamInviteCreateManyInviterInputEnvelope = {
    data: TeamInviteCreateManyInviterInput | TeamInviteCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutUsersInput = {
    update: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutUsersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type TeamUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamInviteUpsertWithWhereUniqueWithoutInviterInput = {
    where: TeamInviteWhereUniqueInput
    update: XOR<TeamInviteUpdateWithoutInviterInput, TeamInviteUncheckedUpdateWithoutInviterInput>
    create: XOR<TeamInviteCreateWithoutInviterInput, TeamInviteUncheckedCreateWithoutInviterInput>
  }

  export type TeamInviteUpdateWithWhereUniqueWithoutInviterInput = {
    where: TeamInviteWhereUniqueInput
    data: XOR<TeamInviteUpdateWithoutInviterInput, TeamInviteUncheckedUpdateWithoutInviterInput>
  }

  export type TeamInviteUpdateManyWithWhereWithoutInviterInput = {
    where: TeamInviteScalarWhereInput
    data: XOR<TeamInviteUpdateManyMutationInput, TeamInviteUncheckedUpdateManyWithoutInviterInput>
  }

  export type TeamInviteScalarWhereInput = {
    AND?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[]
    OR?: TeamInviteScalarWhereInput[]
    NOT?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[]
    id?: StringFilter<"TeamInvite"> | string
    teamId?: StringFilter<"TeamInvite"> | string
    inviterId?: StringFilter<"TeamInvite"> | string
    status?: EnumInviteStatusFilter<"TeamInvite"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"TeamInvite"> | Date | string
    createdAt?: DateTimeFilter<"TeamInvite"> | Date | string
    updatedAt?: DateTimeFilter<"TeamInvite"> | Date | string
    email?: StringFilter<"TeamInvite"> | string
    name?: StringFilter<"TeamInvite"> | string
  }

  export type UserCreateWithoutTeamInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    invitesSent?: TeamInviteCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateWithoutTeamInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    invitesSent?: TeamInviteUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserCreateOrConnectWithoutTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserCreateManyTeamInputEnvelope = {
    data: UserCreateManyTeamInput | UserCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamInviteCreateWithoutTeamInput = {
    id?: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    inviter: UserCreateNestedOneWithoutInvitesSentInput
  }

  export type TeamInviteUncheckedCreateWithoutTeamInput = {
    id?: string
    inviterId: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
  }

  export type TeamInviteCreateOrConnectWithoutTeamInput = {
    where: TeamInviteWhereUniqueInput
    create: XOR<TeamInviteCreateWithoutTeamInput, TeamInviteUncheckedCreateWithoutTeamInput>
  }

  export type TeamInviteCreateManyTeamInputEnvelope = {
    data: TeamInviteCreateManyTeamInput | TeamInviteCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutTeamInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
    sentEmails?: SentEmailCreateNestedManyWithoutTemplateInput
    category: EmailCategoryCreateNestedOneWithoutTemplatesInput
  }

  export type EmailTemplateUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutTeamInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutTeamInput, EmailTemplateUncheckedCreateWithoutTeamInput>
  }

  export type EmailTemplateCreateManyTeamInputEnvelope = {
    data: EmailTemplateCreateManyTeamInput | EmailTemplateCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type MailingListCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: SubscriberCreateNestedManyWithoutMailingListInput
    campaigns?: CampaignCreateNestedManyWithoutMailingListInput
  }

  export type MailingListUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutMailingListInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMailingListInput
  }

  export type MailingListCreateOrConnectWithoutTeamInput = {
    where: MailingListWhereUniqueInput
    create: XOR<MailingListCreateWithoutTeamInput, MailingListUncheckedCreateWithoutTeamInput>
  }

  export type MailingListCreateManyTeamInputEnvelope = {
    data: MailingListCreateManyTeamInput | MailingListCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type AutomationCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    nodes?: AutomationNodeCreateNestedManyWithoutAutomationInput
    edges?: AutomationNodeEdgeCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    nodes?: AutomationNodeUncheckedCreateNestedManyWithoutAutomationInput
    edges?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutTeamInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutTeamInput, AutomationUncheckedCreateWithoutTeamInput>
  }

  export type AutomationCreateManyTeamInputEnvelope = {
    data: AutomationCreateManyTeamInput | AutomationCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutCampaignsInput
    mailingList: MailingListCreateNestedOneWithoutCampaignsInput
    sentEmails?: SentEmailCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsCreateNestedOneWithoutCampaignInput
    smtpConfig?: SmtpConfigCreateNestedOneWithoutCampaignsInput
    emailJobs?: EmailJobCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput
    emailJobs?: EmailJobUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTeamInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTeamInput, CampaignUncheckedCreateWithoutTeamInput>
  }

  export type CampaignCreateManyTeamInputEnvelope = {
    data: CampaignCreateManyTeamInput | CampaignCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutTeamInput = {
    id?: string
    name: string
    key: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
    usageStats?: ApiKeyUsageCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    key: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
    usageStats?: ApiKeyUsageUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyCreateOrConnectWithoutTeamInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutTeamInput, ApiKeyUncheckedCreateWithoutTeamInput>
  }

  export type ApiKeyCreateManyTeamInputEnvelope = {
    data: ApiKeyCreateManyTeamInput | ApiKeyCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type SmtpConfigCreateWithoutTeamInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutSmtpConfigInput
  }

  export type SmtpConfigUncheckedCreateWithoutTeamInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutSmtpConfigInput
  }

  export type SmtpConfigCreateOrConnectWithoutTeamInput = {
    where: SmtpConfigWhereUniqueInput
    create: XOR<SmtpConfigCreateWithoutTeamInput, SmtpConfigUncheckedCreateWithoutTeamInput>
  }

  export type SmtpConfigCreateManyTeamInputEnvelope = {
    data: SmtpConfigCreateManyTeamInput | SmtpConfigCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type SentEmailCreateWithoutTeamInput = {
    id?: string
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateCreateNestedOneWithoutSentEmailsInput
    campaign?: CampaignCreateNestedOneWithoutSentEmailsInput
    emailJob?: EmailJobCreateNestedOneWithoutSentEmailsInput
    subscriber?: SubscriberCreateNestedOneWithoutSentEmailsInput
    tracking?: EmailTrackingCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailUncheckedCreateWithoutTeamInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
    tracking?: EmailTrackingUncheckedCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailCreateOrConnectWithoutTeamInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutTeamInput, SentEmailUncheckedCreateWithoutTeamInput>
  }

  export type SentEmailCreateManyTeamInputEnvelope = {
    data: SentEmailCreateManyTeamInput | SentEmailCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type CustomDomainCreateWithoutTeamInput = {
    id?: string
    domain: string
    sslStatus?: string
    sslCertificate?: string | null
    sslPrivateKey?: string | null
    sslExpiresAt?: Date | string | null
    verificationToken?: string
    dnsChallenge?: string | null
    dnsChallengeToken?: string | null
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomDomainUncheckedCreateWithoutTeamInput = {
    id?: string
    domain: string
    sslStatus?: string
    sslCertificate?: string | null
    sslPrivateKey?: string | null
    sslExpiresAt?: Date | string | null
    verificationToken?: string
    dnsChallenge?: string | null
    dnsChallengeToken?: string | null
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomDomainCreateOrConnectWithoutTeamInput = {
    where: CustomDomainWhereUniqueInput
    create: XOR<CustomDomainCreateWithoutTeamInput, CustomDomainUncheckedCreateWithoutTeamInput>
  }

  export type CustomDomainCreateManyTeamInputEnvelope = {
    data: CustomDomainCreateManyTeamInput | CustomDomainCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutTeamInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
    events?: WebhookEventCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
    events?: WebhookEventUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookCreateOrConnectWithoutTeamInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutTeamInput, WebhookUncheckedCreateWithoutTeamInput>
  }

  export type WebhookCreateManyTeamInputEnvelope = {
    data: WebhookCreateManyTeamInput | WebhookCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
  }

  export type UserUpdateManyWithWhereWithoutTeamInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    teamId?: StringNullableFilter<"User"> | string | null
  }

  export type TeamInviteUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamInviteWhereUniqueInput
    update: XOR<TeamInviteUpdateWithoutTeamInput, TeamInviteUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamInviteCreateWithoutTeamInput, TeamInviteUncheckedCreateWithoutTeamInput>
  }

  export type TeamInviteUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamInviteWhereUniqueInput
    data: XOR<TeamInviteUpdateWithoutTeamInput, TeamInviteUncheckedUpdateWithoutTeamInput>
  }

  export type TeamInviteUpdateManyWithWhereWithoutTeamInput = {
    where: TeamInviteScalarWhereInput
    data: XOR<TeamInviteUpdateManyMutationInput, TeamInviteUncheckedUpdateManyWithoutTeamInput>
  }

  export type EmailTemplateUpsertWithWhereUniqueWithoutTeamInput = {
    where: EmailTemplateWhereUniqueInput
    update: XOR<EmailTemplateUpdateWithoutTeamInput, EmailTemplateUncheckedUpdateWithoutTeamInput>
    create: XOR<EmailTemplateCreateWithoutTeamInput, EmailTemplateUncheckedCreateWithoutTeamInput>
  }

  export type EmailTemplateUpdateWithWhereUniqueWithoutTeamInput = {
    where: EmailTemplateWhereUniqueInput
    data: XOR<EmailTemplateUpdateWithoutTeamInput, EmailTemplateUncheckedUpdateWithoutTeamInput>
  }

  export type EmailTemplateUpdateManyWithWhereWithoutTeamInput = {
    where: EmailTemplateScalarWhereInput
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyWithoutTeamInput>
  }

  export type EmailTemplateScalarWhereInput = {
    AND?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    OR?: EmailTemplateScalarWhereInput[]
    NOT?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    content?: StringNullableFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    teamId?: StringFilter<"EmailTemplate"> | string
    categoryId?: StringFilter<"EmailTemplate"> | string
    html?: StringNullableFilter<"EmailTemplate"> | string | null
    design?: JsonNullableFilter<"EmailTemplate">
  }

  export type MailingListUpsertWithWhereUniqueWithoutTeamInput = {
    where: MailingListWhereUniqueInput
    update: XOR<MailingListUpdateWithoutTeamInput, MailingListUncheckedUpdateWithoutTeamInput>
    create: XOR<MailingListCreateWithoutTeamInput, MailingListUncheckedCreateWithoutTeamInput>
  }

  export type MailingListUpdateWithWhereUniqueWithoutTeamInput = {
    where: MailingListWhereUniqueInput
    data: XOR<MailingListUpdateWithoutTeamInput, MailingListUncheckedUpdateWithoutTeamInput>
  }

  export type MailingListUpdateManyWithWhereWithoutTeamInput = {
    where: MailingListScalarWhereInput
    data: XOR<MailingListUpdateManyMutationInput, MailingListUncheckedUpdateManyWithoutTeamInput>
  }

  export type MailingListScalarWhereInput = {
    AND?: MailingListScalarWhereInput | MailingListScalarWhereInput[]
    OR?: MailingListScalarWhereInput[]
    NOT?: MailingListScalarWhereInput | MailingListScalarWhereInput[]
    id?: StringFilter<"MailingList"> | string
    name?: StringFilter<"MailingList"> | string
    description?: StringNullableFilter<"MailingList"> | string | null
    teamId?: StringFilter<"MailingList"> | string
    createdAt?: DateTimeFilter<"MailingList"> | Date | string
    updatedAt?: DateTimeFilter<"MailingList"> | Date | string
  }

  export type AutomationUpsertWithWhereUniqueWithoutTeamInput = {
    where: AutomationWhereUniqueInput
    update: XOR<AutomationUpdateWithoutTeamInput, AutomationUncheckedUpdateWithoutTeamInput>
    create: XOR<AutomationCreateWithoutTeamInput, AutomationUncheckedCreateWithoutTeamInput>
  }

  export type AutomationUpdateWithWhereUniqueWithoutTeamInput = {
    where: AutomationWhereUniqueInput
    data: XOR<AutomationUpdateWithoutTeamInput, AutomationUncheckedUpdateWithoutTeamInput>
  }

  export type AutomationUpdateManyWithWhereWithoutTeamInput = {
    where: AutomationScalarWhereInput
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyWithoutTeamInput>
  }

  export type AutomationScalarWhereInput = {
    AND?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    OR?: AutomationScalarWhereInput[]
    NOT?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    id?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    isActive?: BoolFilter<"Automation"> | boolean
    teamId?: StringFilter<"Automation"> | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutTeamInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutTeamInput, CampaignUncheckedUpdateWithoutTeamInput>
    create: XOR<CampaignCreateWithoutTeamInput, CampaignUncheckedCreateWithoutTeamInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutTeamInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutTeamInput, CampaignUncheckedUpdateWithoutTeamInput>
  }

  export type CampaignUpdateManyWithWhereWithoutTeamInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutTeamInput>
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutTeamInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutTeamInput, ApiKeyUncheckedUpdateWithoutTeamInput>
    create: XOR<ApiKeyCreateWithoutTeamInput, ApiKeyUncheckedCreateWithoutTeamInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutTeamInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutTeamInput, ApiKeyUncheckedUpdateWithoutTeamInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutTeamInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutTeamInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    teamId?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    scopes?: StringNullableListFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    isActive?: BoolFilter<"ApiKey"> | boolean
  }

  export type SmtpConfigUpsertWithWhereUniqueWithoutTeamInput = {
    where: SmtpConfigWhereUniqueInput
    update: XOR<SmtpConfigUpdateWithoutTeamInput, SmtpConfigUncheckedUpdateWithoutTeamInput>
    create: XOR<SmtpConfigCreateWithoutTeamInput, SmtpConfigUncheckedCreateWithoutTeamInput>
  }

  export type SmtpConfigUpdateWithWhereUniqueWithoutTeamInput = {
    where: SmtpConfigWhereUniqueInput
    data: XOR<SmtpConfigUpdateWithoutTeamInput, SmtpConfigUncheckedUpdateWithoutTeamInput>
  }

  export type SmtpConfigUpdateManyWithWhereWithoutTeamInput = {
    where: SmtpConfigScalarWhereInput
    data: XOR<SmtpConfigUpdateManyMutationInput, SmtpConfigUncheckedUpdateManyWithoutTeamInput>
  }

  export type SmtpConfigScalarWhereInput = {
    AND?: SmtpConfigScalarWhereInput | SmtpConfigScalarWhereInput[]
    OR?: SmtpConfigScalarWhereInput[]
    NOT?: SmtpConfigScalarWhereInput | SmtpConfigScalarWhereInput[]
    id?: StringFilter<"SmtpConfig"> | string
    provider?: StringFilter<"SmtpConfig"> | string
    host?: StringFilter<"SmtpConfig"> | string
    port?: StringFilter<"SmtpConfig"> | string
    username?: StringFilter<"SmtpConfig"> | string
    password?: StringFilter<"SmtpConfig"> | string
    isActive?: BoolFilter<"SmtpConfig"> | boolean
    createdAt?: DateTimeFilter<"SmtpConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SmtpConfig"> | Date | string
    teamId?: StringFilter<"SmtpConfig"> | string
  }

  export type SentEmailUpsertWithWhereUniqueWithoutTeamInput = {
    where: SentEmailWhereUniqueInput
    update: XOR<SentEmailUpdateWithoutTeamInput, SentEmailUncheckedUpdateWithoutTeamInput>
    create: XOR<SentEmailCreateWithoutTeamInput, SentEmailUncheckedCreateWithoutTeamInput>
  }

  export type SentEmailUpdateWithWhereUniqueWithoutTeamInput = {
    where: SentEmailWhereUniqueInput
    data: XOR<SentEmailUpdateWithoutTeamInput, SentEmailUncheckedUpdateWithoutTeamInput>
  }

  export type SentEmailUpdateManyWithWhereWithoutTeamInput = {
    where: SentEmailScalarWhereInput
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyWithoutTeamInput>
  }

  export type CustomDomainUpsertWithWhereUniqueWithoutTeamInput = {
    where: CustomDomainWhereUniqueInput
    update: XOR<CustomDomainUpdateWithoutTeamInput, CustomDomainUncheckedUpdateWithoutTeamInput>
    create: XOR<CustomDomainCreateWithoutTeamInput, CustomDomainUncheckedCreateWithoutTeamInput>
  }

  export type CustomDomainUpdateWithWhereUniqueWithoutTeamInput = {
    where: CustomDomainWhereUniqueInput
    data: XOR<CustomDomainUpdateWithoutTeamInput, CustomDomainUncheckedUpdateWithoutTeamInput>
  }

  export type CustomDomainUpdateManyWithWhereWithoutTeamInput = {
    where: CustomDomainScalarWhereInput
    data: XOR<CustomDomainUpdateManyMutationInput, CustomDomainUncheckedUpdateManyWithoutTeamInput>
  }

  export type CustomDomainScalarWhereInput = {
    AND?: CustomDomainScalarWhereInput | CustomDomainScalarWhereInput[]
    OR?: CustomDomainScalarWhereInput[]
    NOT?: CustomDomainScalarWhereInput | CustomDomainScalarWhereInput[]
    id?: StringFilter<"CustomDomain"> | string
    domain?: StringFilter<"CustomDomain"> | string
    sslStatus?: StringFilter<"CustomDomain"> | string
    sslCertificate?: StringNullableFilter<"CustomDomain"> | string | null
    sslPrivateKey?: StringNullableFilter<"CustomDomain"> | string | null
    sslExpiresAt?: DateTimeNullableFilter<"CustomDomain"> | Date | string | null
    verificationToken?: StringFilter<"CustomDomain"> | string
    dnsChallenge?: StringNullableFilter<"CustomDomain"> | string | null
    dnsChallengeToken?: StringNullableFilter<"CustomDomain"> | string | null
    isVerified?: BoolFilter<"CustomDomain"> | boolean
    isActive?: BoolFilter<"CustomDomain"> | boolean
    teamId?: StringFilter<"CustomDomain"> | string
    createdAt?: DateTimeFilter<"CustomDomain"> | Date | string
    updatedAt?: DateTimeFilter<"CustomDomain"> | Date | string
  }

  export type WebhookUpsertWithWhereUniqueWithoutTeamInput = {
    where: WebhookWhereUniqueInput
    update: XOR<WebhookUpdateWithoutTeamInput, WebhookUncheckedUpdateWithoutTeamInput>
    create: XOR<WebhookCreateWithoutTeamInput, WebhookUncheckedCreateWithoutTeamInput>
  }

  export type WebhookUpdateWithWhereUniqueWithoutTeamInput = {
    where: WebhookWhereUniqueInput
    data: XOR<WebhookUpdateWithoutTeamInput, WebhookUncheckedUpdateWithoutTeamInput>
  }

  export type WebhookUpdateManyWithWhereWithoutTeamInput = {
    where: WebhookScalarWhereInput
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutTeamInput>
  }

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    OR?: WebhookScalarWhereInput[]
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    id?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    teamId?: StringFilter<"Webhook"> | string
    lastStatus?: IntNullableFilter<"Webhook"> | number | null
    lastAttempt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    retryCount?: IntFilter<"Webhook"> | number
  }

  export type TeamCreateWithoutInvitesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutInvitesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutInvitesInput, TeamUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutInvitesSentInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    team?: TeamCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutInvitesSentInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
    teamId?: string | null
  }

  export type UserCreateOrConnectWithoutInvitesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
  }

  export type TeamUpsertWithoutInvitesInput = {
    update: XOR<TeamUpdateWithoutInvitesInput, TeamUncheckedUpdateWithoutInvitesInput>
    create: XOR<TeamCreateWithoutInvitesInput, TeamUncheckedCreateWithoutInvitesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutInvitesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutInvitesInput, TeamUncheckedUpdateWithoutInvitesInput>
  }

  export type TeamUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutInvitesSentInput = {
    update: XOR<UserUpdateWithoutInvitesSentInput, UserUncheckedUpdateWithoutInvitesSentInput>
    create: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitesSentInput, UserUncheckedUpdateWithoutInvitesSentInput>
  }

  export type UserUpdateWithoutInvitesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    team?: TeamUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamCreateWithoutApiKeysInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutApiKeysInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutApiKeysInput, TeamUncheckedCreateWithoutApiKeysInput>
  }

  export type ApiKeyUsageCreateWithoutApiKeyInput = {
    id?: string
    endpoint: string
    method: string
    timestamp?: Date | string
    success?: boolean
    error?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiKeyUsageUncheckedCreateWithoutApiKeyInput = {
    id?: string
    endpoint: string
    method: string
    timestamp?: Date | string
    success?: boolean
    error?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiKeyUsageCreateOrConnectWithoutApiKeyInput = {
    where: ApiKeyUsageWhereUniqueInput
    create: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput>
  }

  export type ApiKeyUsageCreateManyApiKeyInputEnvelope = {
    data: ApiKeyUsageCreateManyApiKeyInput | ApiKeyUsageCreateManyApiKeyInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutApiKeysInput = {
    update: XOR<TeamUpdateWithoutApiKeysInput, TeamUncheckedUpdateWithoutApiKeysInput>
    create: XOR<TeamCreateWithoutApiKeysInput, TeamUncheckedCreateWithoutApiKeysInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutApiKeysInput, TeamUncheckedUpdateWithoutApiKeysInput>
  }

  export type TeamUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput = {
    where: ApiKeyUsageWhereUniqueInput
    update: XOR<ApiKeyUsageUpdateWithoutApiKeyInput, ApiKeyUsageUncheckedUpdateWithoutApiKeyInput>
    create: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput>
  }

  export type ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput = {
    where: ApiKeyUsageWhereUniqueInput
    data: XOR<ApiKeyUsageUpdateWithoutApiKeyInput, ApiKeyUsageUncheckedUpdateWithoutApiKeyInput>
  }

  export type ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput = {
    where: ApiKeyUsageScalarWhereInput
    data: XOR<ApiKeyUsageUpdateManyMutationInput, ApiKeyUsageUncheckedUpdateManyWithoutApiKeyInput>
  }

  export type ApiKeyUsageScalarWhereInput = {
    AND?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
    OR?: ApiKeyUsageScalarWhereInput[]
    NOT?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
    id?: StringFilter<"ApiKeyUsage"> | string
    apiKeyId?: StringFilter<"ApiKeyUsage"> | string
    endpoint?: StringFilter<"ApiKeyUsage"> | string
    method?: StringFilter<"ApiKeyUsage"> | string
    timestamp?: DateTimeFilter<"ApiKeyUsage"> | Date | string
    success?: BoolFilter<"ApiKeyUsage"> | boolean
    error?: StringNullableFilter<"ApiKeyUsage"> | string | null
    ipAddress?: StringNullableFilter<"ApiKeyUsage"> | string | null
    userAgent?: StringNullableFilter<"ApiKeyUsage"> | string | null
  }

  export type ApiKeyCreateWithoutUsageStatsInput = {
    id?: string
    name: string
    key: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
    team: TeamCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateWithoutUsageStatsInput = {
    id?: string
    name: string
    key: string
    teamId: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
  }

  export type ApiKeyCreateOrConnectWithoutUsageStatsInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUsageStatsInput, ApiKeyUncheckedCreateWithoutUsageStatsInput>
  }

  export type ApiKeyUpsertWithoutUsageStatsInput = {
    update: XOR<ApiKeyUpdateWithoutUsageStatsInput, ApiKeyUncheckedUpdateWithoutUsageStatsInput>
    create: XOR<ApiKeyCreateWithoutUsageStatsInput, ApiKeyUncheckedCreateWithoutUsageStatsInput>
    where?: ApiKeyWhereInput
  }

  export type ApiKeyUpdateToOneWithWhereWithoutUsageStatsInput = {
    where?: ApiKeyWhereInput
    data: XOR<ApiKeyUpdateWithoutUsageStatsInput, ApiKeyUncheckedUpdateWithoutUsageStatsInput>
  }

  export type ApiKeyUpdateWithoutUsageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateWithoutUsageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailTemplateCreateWithoutCampaignsInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team: TeamCreateNestedOneWithoutTemplatesInput
    sentEmails?: SentEmailCreateNestedManyWithoutTemplateInput
    category: EmailCategoryCreateNestedOneWithoutTemplatesInput
  }

  export type EmailTemplateUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    categoryId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutCampaignsInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
  }

  export type TeamCreateWithoutCampaignsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCampaignsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCampaignsInput, TeamUncheckedCreateWithoutCampaignsInput>
  }

  export type MailingListCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutListsInput
    subscribers?: SubscriberCreateNestedManyWithoutMailingListInput
  }

  export type MailingListUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutMailingListInput
  }

  export type MailingListCreateOrConnectWithoutCampaignsInput = {
    where: MailingListWhereUniqueInput
    create: XOR<MailingListCreateWithoutCampaignsInput, MailingListUncheckedCreateWithoutCampaignsInput>
  }

  export type SentEmailCreateWithoutCampaignInput = {
    id?: string
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateCreateNestedOneWithoutSentEmailsInput
    team: TeamCreateNestedOneWithoutSentEmailsInput
    emailJob?: EmailJobCreateNestedOneWithoutSentEmailsInput
    subscriber?: SubscriberCreateNestedOneWithoutSentEmailsInput
    tracking?: EmailTrackingCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailUncheckedCreateWithoutCampaignInput = {
    id?: string
    templateId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
    tracking?: EmailTrackingUncheckedCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailCreateOrConnectWithoutCampaignInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutCampaignInput, SentEmailUncheckedCreateWithoutCampaignInput>
  }

  export type SentEmailCreateManyCampaignInputEnvelope = {
    data: SentEmailCreateManyCampaignInput | SentEmailCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignAnalyticsCreateWithoutCampaignInput = {
    id?: string
    sentCount?: number
    openCount?: number
    clickCount?: number
    bounceCount?: number
    unsubscribeCount?: number
    lastUpdated?: Date | string
  }

  export type CampaignAnalyticsUncheckedCreateWithoutCampaignInput = {
    id?: string
    sentCount?: number
    openCount?: number
    clickCount?: number
    bounceCount?: number
    unsubscribeCount?: number
    lastUpdated?: Date | string
  }

  export type CampaignAnalyticsCreateOrConnectWithoutCampaignInput = {
    where: CampaignAnalyticsWhereUniqueInput
    create: XOR<CampaignAnalyticsCreateWithoutCampaignInput, CampaignAnalyticsUncheckedCreateWithoutCampaignInput>
  }

  export type SmtpConfigCreateWithoutCampaignsInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutSmtpConfigsInput
  }

  export type SmtpConfigUncheckedCreateWithoutCampaignsInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
  }

  export type SmtpConfigCreateOrConnectWithoutCampaignsInput = {
    where: SmtpConfigWhereUniqueInput
    create: XOR<SmtpConfigCreateWithoutCampaignsInput, SmtpConfigUncheckedCreateWithoutCampaignsInput>
  }

  export type EmailJobCreateWithoutCampaignInput = {
    id?: string
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailCreateNestedManyWithoutEmailJobInput
    logs?: EmailJobLogCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobUncheckedCreateWithoutCampaignInput = {
    id?: string
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutEmailJobInput
    logs?: EmailJobLogUncheckedCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobCreateOrConnectWithoutCampaignInput = {
    where: EmailJobWhereUniqueInput
    create: XOR<EmailJobCreateWithoutCampaignInput, EmailJobUncheckedCreateWithoutCampaignInput>
  }

  export type EmailJobCreateManyCampaignInputEnvelope = {
    data: EmailJobCreateManyCampaignInput | EmailJobCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateUpsertWithoutCampaignsInput = {
    update: XOR<EmailTemplateUpdateWithoutCampaignsInput, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
    create: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutCampaignsInput, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type EmailTemplateUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team?: TeamUpdateOneRequiredWithoutTemplatesNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTemplateNestedInput
    category?: EmailCategoryUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TeamUpsertWithoutCampaignsInput = {
    update: XOR<TeamUpdateWithoutCampaignsInput, TeamUncheckedUpdateWithoutCampaignsInput>
    create: XOR<TeamCreateWithoutCampaignsInput, TeamUncheckedCreateWithoutCampaignsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutCampaignsInput, TeamUncheckedUpdateWithoutCampaignsInput>
  }

  export type TeamUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type MailingListUpsertWithoutCampaignsInput = {
    update: XOR<MailingListUpdateWithoutCampaignsInput, MailingListUncheckedUpdateWithoutCampaignsInput>
    create: XOR<MailingListCreateWithoutCampaignsInput, MailingListUncheckedCreateWithoutCampaignsInput>
    where?: MailingListWhereInput
  }

  export type MailingListUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: MailingListWhereInput
    data: XOR<MailingListUpdateWithoutCampaignsInput, MailingListUncheckedUpdateWithoutCampaignsInput>
  }

  export type MailingListUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutListsNestedInput
    subscribers?: SubscriberUpdateManyWithoutMailingListNestedInput
  }

  export type MailingListUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: SubscriberUncheckedUpdateManyWithoutMailingListNestedInput
  }

  export type SentEmailUpsertWithWhereUniqueWithoutCampaignInput = {
    where: SentEmailWhereUniqueInput
    update: XOR<SentEmailUpdateWithoutCampaignInput, SentEmailUncheckedUpdateWithoutCampaignInput>
    create: XOR<SentEmailCreateWithoutCampaignInput, SentEmailUncheckedCreateWithoutCampaignInput>
  }

  export type SentEmailUpdateWithWhereUniqueWithoutCampaignInput = {
    where: SentEmailWhereUniqueInput
    data: XOR<SentEmailUpdateWithoutCampaignInput, SentEmailUncheckedUpdateWithoutCampaignInput>
  }

  export type SentEmailUpdateManyWithWhereWithoutCampaignInput = {
    where: SentEmailScalarWhereInput
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignAnalyticsUpsertWithoutCampaignInput = {
    update: XOR<CampaignAnalyticsUpdateWithoutCampaignInput, CampaignAnalyticsUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignAnalyticsCreateWithoutCampaignInput, CampaignAnalyticsUncheckedCreateWithoutCampaignInput>
    where?: CampaignAnalyticsWhereInput
  }

  export type CampaignAnalyticsUpdateToOneWithWhereWithoutCampaignInput = {
    where?: CampaignAnalyticsWhereInput
    data: XOR<CampaignAnalyticsUpdateWithoutCampaignInput, CampaignAnalyticsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignAnalyticsUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalyticsUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmtpConfigUpsertWithoutCampaignsInput = {
    update: XOR<SmtpConfigUpdateWithoutCampaignsInput, SmtpConfigUncheckedUpdateWithoutCampaignsInput>
    create: XOR<SmtpConfigCreateWithoutCampaignsInput, SmtpConfigUncheckedCreateWithoutCampaignsInput>
    where?: SmtpConfigWhereInput
  }

  export type SmtpConfigUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: SmtpConfigWhereInput
    data: XOR<SmtpConfigUpdateWithoutCampaignsInput, SmtpConfigUncheckedUpdateWithoutCampaignsInput>
  }

  export type SmtpConfigUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutSmtpConfigsNestedInput
  }

  export type SmtpConfigUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailJobUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EmailJobWhereUniqueInput
    update: XOR<EmailJobUpdateWithoutCampaignInput, EmailJobUncheckedUpdateWithoutCampaignInput>
    create: XOR<EmailJobCreateWithoutCampaignInput, EmailJobUncheckedCreateWithoutCampaignInput>
  }

  export type EmailJobUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EmailJobWhereUniqueInput
    data: XOR<EmailJobUpdateWithoutCampaignInput, EmailJobUncheckedUpdateWithoutCampaignInput>
  }

  export type EmailJobUpdateManyWithWhereWithoutCampaignInput = {
    where: EmailJobScalarWhereInput
    data: XOR<EmailJobUpdateManyMutationInput, EmailJobUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EmailJobScalarWhereInput = {
    AND?: EmailJobScalarWhereInput | EmailJobScalarWhereInput[]
    OR?: EmailJobScalarWhereInput[]
    NOT?: EmailJobScalarWhereInput | EmailJobScalarWhereInput[]
    id?: StringFilter<"EmailJob"> | string
    campaignId?: StringNullableFilter<"EmailJob"> | string | null
    status?: EnumJobStatusFilter<"EmailJob"> | $Enums.JobStatus
    totalEmails?: IntFilter<"EmailJob"> | number
    processedEmails?: IntFilter<"EmailJob"> | number
    startedAt?: DateTimeNullableFilter<"EmailJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"EmailJob"> | Date | string | null
    error?: StringNullableFilter<"EmailJob"> | string | null
    createdAt?: DateTimeFilter<"EmailJob"> | Date | string
    updatedAt?: DateTimeFilter<"EmailJob"> | Date | string
  }

  export type TeamCreateWithoutListsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutListsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutListsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutListsInput, TeamUncheckedCreateWithoutListsInput>
  }

  export type SubscriberCreateWithoutMailingListInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberUncheckedCreateWithoutMailingListInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberCreateOrConnectWithoutMailingListInput = {
    where: SubscriberWhereUniqueInput
    create: XOR<SubscriberCreateWithoutMailingListInput, SubscriberUncheckedCreateWithoutMailingListInput>
  }

  export type SubscriberCreateManyMailingListInputEnvelope = {
    data: SubscriberCreateManyMailingListInput | SubscriberCreateManyMailingListInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutMailingListInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutCampaignsInput
    team: TeamCreateNestedOneWithoutCampaignsInput
    sentEmails?: SentEmailCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsCreateNestedOneWithoutCampaignInput
    smtpConfig?: SmtpConfigCreateNestedOneWithoutCampaignsInput
    emailJobs?: EmailJobCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMailingListInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput
    emailJobs?: EmailJobUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMailingListInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMailingListInput, CampaignUncheckedCreateWithoutMailingListInput>
  }

  export type CampaignCreateManyMailingListInputEnvelope = {
    data: CampaignCreateManyMailingListInput | CampaignCreateManyMailingListInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutListsInput = {
    update: XOR<TeamUpdateWithoutListsInput, TeamUncheckedUpdateWithoutListsInput>
    create: XOR<TeamCreateWithoutListsInput, TeamUncheckedCreateWithoutListsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutListsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutListsInput, TeamUncheckedUpdateWithoutListsInput>
  }

  export type TeamUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type SubscriberUpsertWithWhereUniqueWithoutMailingListInput = {
    where: SubscriberWhereUniqueInput
    update: XOR<SubscriberUpdateWithoutMailingListInput, SubscriberUncheckedUpdateWithoutMailingListInput>
    create: XOR<SubscriberCreateWithoutMailingListInput, SubscriberUncheckedCreateWithoutMailingListInput>
  }

  export type SubscriberUpdateWithWhereUniqueWithoutMailingListInput = {
    where: SubscriberWhereUniqueInput
    data: XOR<SubscriberUpdateWithoutMailingListInput, SubscriberUncheckedUpdateWithoutMailingListInput>
  }

  export type SubscriberUpdateManyWithWhereWithoutMailingListInput = {
    where: SubscriberScalarWhereInput
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyWithoutMailingListInput>
  }

  export type SubscriberScalarWhereInput = {
    AND?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
    OR?: SubscriberScalarWhereInput[]
    NOT?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
    id?: StringFilter<"Subscriber"> | string
    email?: StringFilter<"Subscriber"> | string
    firstName?: StringNullableFilter<"Subscriber"> | string | null
    lastName?: StringNullableFilter<"Subscriber"> | string | null
    phone?: StringNullableFilter<"Subscriber"> | string | null
    company?: StringNullableFilter<"Subscriber"> | string | null
    title?: StringNullableFilter<"Subscriber"> | string | null
    address?: StringNullableFilter<"Subscriber"> | string | null
    addressLine2?: StringNullableFilter<"Subscriber"> | string | null
    city?: StringNullableFilter<"Subscriber"> | string | null
    state?: StringNullableFilter<"Subscriber"> | string | null
    postalCode?: StringNullableFilter<"Subscriber"> | string | null
    country?: StringNullableFilter<"Subscriber"> | string | null
    metadata?: JsonNullableFilter<"Subscriber">
    tags?: StringNullableListFilter<"Subscriber">
    customFields?: JsonNullableFilter<"Subscriber">
    source?: StringNullableFilter<"Subscriber"> | string | null
    listId?: StringFilter<"Subscriber"> | string
    status?: EnumSubscriberStatusFilter<"Subscriber"> | $Enums.SubscriberStatus
    unsubscribedAt?: DateTimeNullableFilter<"Subscriber"> | Date | string | null
    lastActivityAt?: DateTimeNullableFilter<"Subscriber"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriber"> | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutMailingListInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutMailingListInput, CampaignUncheckedUpdateWithoutMailingListInput>
    create: XOR<CampaignCreateWithoutMailingListInput, CampaignUncheckedCreateWithoutMailingListInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutMailingListInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutMailingListInput, CampaignUncheckedUpdateWithoutMailingListInput>
  }

  export type CampaignUpdateManyWithWhereWithoutMailingListInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutMailingListInput>
  }

  export type MailingListCreateWithoutSubscribersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutListsInput
    campaigns?: CampaignCreateNestedManyWithoutMailingListInput
  }

  export type MailingListUncheckedCreateWithoutSubscribersInput = {
    id?: string
    name: string
    description?: string | null
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMailingListInput
  }

  export type MailingListCreateOrConnectWithoutSubscribersInput = {
    where: MailingListWhereUniqueInput
    create: XOR<MailingListCreateWithoutSubscribersInput, MailingListUncheckedCreateWithoutSubscribersInput>
  }

  export type SentEmailCreateWithoutSubscriberInput = {
    id?: string
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateCreateNestedOneWithoutSentEmailsInput
    campaign?: CampaignCreateNestedOneWithoutSentEmailsInput
    team: TeamCreateNestedOneWithoutSentEmailsInput
    emailJob?: EmailJobCreateNestedOneWithoutSentEmailsInput
    tracking?: EmailTrackingCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailUncheckedCreateWithoutSubscriberInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    tracking?: EmailTrackingUncheckedCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailCreateOrConnectWithoutSubscriberInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutSubscriberInput, SentEmailUncheckedCreateWithoutSubscriberInput>
  }

  export type SentEmailCreateManySubscriberInputEnvelope = {
    data: SentEmailCreateManySubscriberInput | SentEmailCreateManySubscriberInput[]
    skipDuplicates?: boolean
  }

  export type MailingListUpsertWithoutSubscribersInput = {
    update: XOR<MailingListUpdateWithoutSubscribersInput, MailingListUncheckedUpdateWithoutSubscribersInput>
    create: XOR<MailingListCreateWithoutSubscribersInput, MailingListUncheckedCreateWithoutSubscribersInput>
    where?: MailingListWhereInput
  }

  export type MailingListUpdateToOneWithWhereWithoutSubscribersInput = {
    where?: MailingListWhereInput
    data: XOR<MailingListUpdateWithoutSubscribersInput, MailingListUncheckedUpdateWithoutSubscribersInput>
  }

  export type MailingListUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutListsNestedInput
    campaigns?: CampaignUpdateManyWithoutMailingListNestedInput
  }

  export type MailingListUncheckedUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutMailingListNestedInput
  }

  export type SentEmailUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: SentEmailWhereUniqueInput
    update: XOR<SentEmailUpdateWithoutSubscriberInput, SentEmailUncheckedUpdateWithoutSubscriberInput>
    create: XOR<SentEmailCreateWithoutSubscriberInput, SentEmailUncheckedCreateWithoutSubscriberInput>
  }

  export type SentEmailUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: SentEmailWhereUniqueInput
    data: XOR<SentEmailUpdateWithoutSubscriberInput, SentEmailUncheckedUpdateWithoutSubscriberInput>
  }

  export type SentEmailUpdateManyWithWhereWithoutSubscriberInput = {
    where: SentEmailScalarWhereInput
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyWithoutSubscriberInput>
  }

  export type EmailTemplateCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team: TeamCreateNestedOneWithoutTemplatesInput
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
    category: EmailCategoryCreateNestedOneWithoutTemplatesInput
  }

  export type EmailTemplateUncheckedCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    categoryId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutSentEmailsInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
  }

  export type CampaignCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutCampaignsInput
    team: TeamCreateNestedOneWithoutCampaignsInput
    mailingList: MailingListCreateNestedOneWithoutCampaignsInput
    analytics?: CampaignAnalyticsCreateNestedOneWithoutCampaignInput
    smtpConfig?: SmtpConfigCreateNestedOneWithoutCampaignsInput
    emailJobs?: EmailJobCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput
    emailJobs?: EmailJobUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSentEmailsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSentEmailsInput, CampaignUncheckedCreateWithoutSentEmailsInput>
  }

  export type TeamCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSentEmailsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSentEmailsInput, TeamUncheckedCreateWithoutSentEmailsInput>
  }

  export type EmailJobCreateWithoutSentEmailsInput = {
    id?: string
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutEmailJobsInput
    logs?: EmailJobLogCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobUncheckedCreateWithoutSentEmailsInput = {
    id?: string
    campaignId?: string | null
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: EmailJobLogUncheckedCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobCreateOrConnectWithoutSentEmailsInput = {
    where: EmailJobWhereUniqueInput
    create: XOR<EmailJobCreateWithoutSentEmailsInput, EmailJobUncheckedCreateWithoutSentEmailsInput>
  }

  export type SubscriberCreateWithoutSentEmailsInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mailingList: MailingListCreateNestedOneWithoutSubscribersInput
  }

  export type SubscriberUncheckedCreateWithoutSentEmailsInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    listId: string
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberCreateOrConnectWithoutSentEmailsInput = {
    where: SubscriberWhereUniqueInput
    create: XOR<SubscriberCreateWithoutSentEmailsInput, SubscriberUncheckedCreateWithoutSentEmailsInput>
  }

  export type EmailTrackingCreateWithoutSentEmailInput = {
    id?: string
    type: $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailTrackingUncheckedCreateWithoutSentEmailInput = {
    id?: string
    type: $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailTrackingCreateOrConnectWithoutSentEmailInput = {
    where: EmailTrackingWhereUniqueInput
    create: XOR<EmailTrackingCreateWithoutSentEmailInput, EmailTrackingUncheckedCreateWithoutSentEmailInput>
  }

  export type EmailTrackingCreateManySentEmailInputEnvelope = {
    data: EmailTrackingCreateManySentEmailInput | EmailTrackingCreateManySentEmailInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateUpsertWithoutSentEmailsInput = {
    update: XOR<EmailTemplateUpdateWithoutSentEmailsInput, EmailTemplateUncheckedUpdateWithoutSentEmailsInput>
    create: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutSentEmailsInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutSentEmailsInput, EmailTemplateUncheckedUpdateWithoutSentEmailsInput>
  }

  export type EmailTemplateUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team?: TeamUpdateOneRequiredWithoutTemplatesNestedInput
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
    category?: EmailCategoryUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type CampaignUpsertWithoutSentEmailsInput = {
    update: XOR<CampaignUpdateWithoutSentEmailsInput, CampaignUncheckedUpdateWithoutSentEmailsInput>
    create: XOR<CampaignCreateWithoutSentEmailsInput, CampaignUncheckedCreateWithoutSentEmailsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSentEmailsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSentEmailsInput, CampaignUncheckedUpdateWithoutSentEmailsInput>
  }

  export type CampaignUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    team?: TeamUpdateOneRequiredWithoutCampaignsNestedInput
    mailingList?: MailingListUpdateOneRequiredWithoutCampaignsNestedInput
    analytics?: CampaignAnalyticsUpdateOneWithoutCampaignNestedInput
    smtpConfig?: SmtpConfigUpdateOneWithoutCampaignsNestedInput
    emailJobs?: EmailJobUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput
    emailJobs?: EmailJobUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type TeamUpsertWithoutSentEmailsInput = {
    update: XOR<TeamUpdateWithoutSentEmailsInput, TeamUncheckedUpdateWithoutSentEmailsInput>
    create: XOR<TeamCreateWithoutSentEmailsInput, TeamUncheckedCreateWithoutSentEmailsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSentEmailsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSentEmailsInput, TeamUncheckedUpdateWithoutSentEmailsInput>
  }

  export type TeamUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type EmailJobUpsertWithoutSentEmailsInput = {
    update: XOR<EmailJobUpdateWithoutSentEmailsInput, EmailJobUncheckedUpdateWithoutSentEmailsInput>
    create: XOR<EmailJobCreateWithoutSentEmailsInput, EmailJobUncheckedCreateWithoutSentEmailsInput>
    where?: EmailJobWhereInput
  }

  export type EmailJobUpdateToOneWithWhereWithoutSentEmailsInput = {
    where?: EmailJobWhereInput
    data: XOR<EmailJobUpdateWithoutSentEmailsInput, EmailJobUncheckedUpdateWithoutSentEmailsInput>
  }

  export type EmailJobUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutEmailJobsNestedInput
    logs?: EmailJobLogUpdateManyWithoutEmailJobNestedInput
  }

  export type EmailJobUncheckedUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: EmailJobLogUncheckedUpdateManyWithoutEmailJobNestedInput
  }

  export type SubscriberUpsertWithoutSentEmailsInput = {
    update: XOR<SubscriberUpdateWithoutSentEmailsInput, SubscriberUncheckedUpdateWithoutSentEmailsInput>
    create: XOR<SubscriberCreateWithoutSentEmailsInput, SubscriberUncheckedCreateWithoutSentEmailsInput>
    where?: SubscriberWhereInput
  }

  export type SubscriberUpdateToOneWithWhereWithoutSentEmailsInput = {
    where?: SubscriberWhereInput
    data: XOR<SubscriberUpdateWithoutSentEmailsInput, SubscriberUncheckedUpdateWithoutSentEmailsInput>
  }

  export type SubscriberUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailingList?: MailingListUpdateOneRequiredWithoutSubscribersNestedInput
  }

  export type SubscriberUncheckedUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingUpsertWithWhereUniqueWithoutSentEmailInput = {
    where: EmailTrackingWhereUniqueInput
    update: XOR<EmailTrackingUpdateWithoutSentEmailInput, EmailTrackingUncheckedUpdateWithoutSentEmailInput>
    create: XOR<EmailTrackingCreateWithoutSentEmailInput, EmailTrackingUncheckedCreateWithoutSentEmailInput>
  }

  export type EmailTrackingUpdateWithWhereUniqueWithoutSentEmailInput = {
    where: EmailTrackingWhereUniqueInput
    data: XOR<EmailTrackingUpdateWithoutSentEmailInput, EmailTrackingUncheckedUpdateWithoutSentEmailInput>
  }

  export type EmailTrackingUpdateManyWithWhereWithoutSentEmailInput = {
    where: EmailTrackingScalarWhereInput
    data: XOR<EmailTrackingUpdateManyMutationInput, EmailTrackingUncheckedUpdateManyWithoutSentEmailInput>
  }

  export type EmailTrackingScalarWhereInput = {
    AND?: EmailTrackingScalarWhereInput | EmailTrackingScalarWhereInput[]
    OR?: EmailTrackingScalarWhereInput[]
    NOT?: EmailTrackingScalarWhereInput | EmailTrackingScalarWhereInput[]
    id?: StringFilter<"EmailTracking"> | string
    sentEmailId?: StringFilter<"EmailTracking"> | string
    type?: EnumTrackingTypeFilter<"EmailTracking"> | $Enums.TrackingType
    data?: JsonNullableFilter<"EmailTracking">
    createdAt?: DateTimeFilter<"EmailTracking"> | Date | string
  }

  export type SentEmailCreateWithoutTrackingInput = {
    id?: string
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateCreateNestedOneWithoutSentEmailsInput
    campaign?: CampaignCreateNestedOneWithoutSentEmailsInput
    team: TeamCreateNestedOneWithoutSentEmailsInput
    emailJob?: EmailJobCreateNestedOneWithoutSentEmailsInput
    subscriber?: SubscriberCreateNestedOneWithoutSentEmailsInput
  }

  export type SentEmailUncheckedCreateWithoutTrackingInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
  }

  export type SentEmailCreateOrConnectWithoutTrackingInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutTrackingInput, SentEmailUncheckedCreateWithoutTrackingInput>
  }

  export type SentEmailUpsertWithoutTrackingInput = {
    update: XOR<SentEmailUpdateWithoutTrackingInput, SentEmailUncheckedUpdateWithoutTrackingInput>
    create: XOR<SentEmailCreateWithoutTrackingInput, SentEmailUncheckedCreateWithoutTrackingInput>
    where?: SentEmailWhereInput
  }

  export type SentEmailUpdateToOneWithWhereWithoutTrackingInput = {
    where?: SentEmailWhereInput
    data: XOR<SentEmailUpdateWithoutTrackingInput, SentEmailUncheckedUpdateWithoutTrackingInput>
  }

  export type SentEmailUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateUpdateOneWithoutSentEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutSentEmailsNestedInput
    team?: TeamUpdateOneRequiredWithoutSentEmailsNestedInput
    emailJob?: EmailJobUpdateOneWithoutSentEmailsNestedInput
    subscriber?: SubscriberUpdateOneWithoutSentEmailsNestedInput
  }

  export type SentEmailUncheckedUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateWithoutEmailJobsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutCampaignsInput
    team: TeamCreateNestedOneWithoutCampaignsInput
    mailingList: MailingListCreateNestedOneWithoutCampaignsInput
    sentEmails?: SentEmailCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsCreateNestedOneWithoutCampaignInput
    smtpConfig?: SmtpConfigCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutEmailJobsInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEmailJobsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEmailJobsInput, CampaignUncheckedCreateWithoutEmailJobsInput>
  }

  export type SentEmailCreateWithoutEmailJobInput = {
    id?: string
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateCreateNestedOneWithoutSentEmailsInput
    campaign?: CampaignCreateNestedOneWithoutSentEmailsInput
    team: TeamCreateNestedOneWithoutSentEmailsInput
    subscriber?: SubscriberCreateNestedOneWithoutSentEmailsInput
    tracking?: EmailTrackingCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailUncheckedCreateWithoutEmailJobInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriberId?: string | null
    tracking?: EmailTrackingUncheckedCreateNestedManyWithoutSentEmailInput
  }

  export type SentEmailCreateOrConnectWithoutEmailJobInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutEmailJobInput, SentEmailUncheckedCreateWithoutEmailJobInput>
  }

  export type SentEmailCreateManyEmailJobInputEnvelope = {
    data: SentEmailCreateManyEmailJobInput | SentEmailCreateManyEmailJobInput[]
    skipDuplicates?: boolean
  }

  export type EmailJobLogCreateWithoutEmailJobInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailJobLogUncheckedCreateWithoutEmailJobInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailJobLogCreateOrConnectWithoutEmailJobInput = {
    where: EmailJobLogWhereUniqueInput
    create: XOR<EmailJobLogCreateWithoutEmailJobInput, EmailJobLogUncheckedCreateWithoutEmailJobInput>
  }

  export type EmailJobLogCreateManyEmailJobInputEnvelope = {
    data: EmailJobLogCreateManyEmailJobInput | EmailJobLogCreateManyEmailJobInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutEmailJobsInput = {
    update: XOR<CampaignUpdateWithoutEmailJobsInput, CampaignUncheckedUpdateWithoutEmailJobsInput>
    create: XOR<CampaignCreateWithoutEmailJobsInput, CampaignUncheckedCreateWithoutEmailJobsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEmailJobsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEmailJobsInput, CampaignUncheckedUpdateWithoutEmailJobsInput>
  }

  export type CampaignUpdateWithoutEmailJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    team?: TeamUpdateOneRequiredWithoutCampaignsNestedInput
    mailingList?: MailingListUpdateOneRequiredWithoutCampaignsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUpdateOneWithoutCampaignNestedInput
    smtpConfig?: SmtpConfigUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEmailJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type SentEmailUpsertWithWhereUniqueWithoutEmailJobInput = {
    where: SentEmailWhereUniqueInput
    update: XOR<SentEmailUpdateWithoutEmailJobInput, SentEmailUncheckedUpdateWithoutEmailJobInput>
    create: XOR<SentEmailCreateWithoutEmailJobInput, SentEmailUncheckedCreateWithoutEmailJobInput>
  }

  export type SentEmailUpdateWithWhereUniqueWithoutEmailJobInput = {
    where: SentEmailWhereUniqueInput
    data: XOR<SentEmailUpdateWithoutEmailJobInput, SentEmailUncheckedUpdateWithoutEmailJobInput>
  }

  export type SentEmailUpdateManyWithWhereWithoutEmailJobInput = {
    where: SentEmailScalarWhereInput
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyWithoutEmailJobInput>
  }

  export type EmailJobLogUpsertWithWhereUniqueWithoutEmailJobInput = {
    where: EmailJobLogWhereUniqueInput
    update: XOR<EmailJobLogUpdateWithoutEmailJobInput, EmailJobLogUncheckedUpdateWithoutEmailJobInput>
    create: XOR<EmailJobLogCreateWithoutEmailJobInput, EmailJobLogUncheckedCreateWithoutEmailJobInput>
  }

  export type EmailJobLogUpdateWithWhereUniqueWithoutEmailJobInput = {
    where: EmailJobLogWhereUniqueInput
    data: XOR<EmailJobLogUpdateWithoutEmailJobInput, EmailJobLogUncheckedUpdateWithoutEmailJobInput>
  }

  export type EmailJobLogUpdateManyWithWhereWithoutEmailJobInput = {
    where: EmailJobLogScalarWhereInput
    data: XOR<EmailJobLogUpdateManyMutationInput, EmailJobLogUncheckedUpdateManyWithoutEmailJobInput>
  }

  export type EmailJobLogScalarWhereInput = {
    AND?: EmailJobLogScalarWhereInput | EmailJobLogScalarWhereInput[]
    OR?: EmailJobLogScalarWhereInput[]
    NOT?: EmailJobLogScalarWhereInput | EmailJobLogScalarWhereInput[]
    id?: StringFilter<"EmailJobLog"> | string
    jobId?: StringFilter<"EmailJobLog"> | string
    level?: EnumLogLevelFilter<"EmailJobLog"> | $Enums.LogLevel
    message?: StringFilter<"EmailJobLog"> | string
    metadata?: JsonNullableFilter<"EmailJobLog">
    createdAt?: DateTimeFilter<"EmailJobLog"> | Date | string
  }

  export type EmailJobCreateWithoutLogsInput = {
    id?: string
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutEmailJobsInput
    sentEmails?: SentEmailCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobUncheckedCreateWithoutLogsInput = {
    id?: string
    campaignId?: string | null
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutEmailJobInput
  }

  export type EmailJobCreateOrConnectWithoutLogsInput = {
    where: EmailJobWhereUniqueInput
    create: XOR<EmailJobCreateWithoutLogsInput, EmailJobUncheckedCreateWithoutLogsInput>
  }

  export type EmailJobUpsertWithoutLogsInput = {
    update: XOR<EmailJobUpdateWithoutLogsInput, EmailJobUncheckedUpdateWithoutLogsInput>
    create: XOR<EmailJobCreateWithoutLogsInput, EmailJobUncheckedCreateWithoutLogsInput>
    where?: EmailJobWhereInput
  }

  export type EmailJobUpdateToOneWithWhereWithoutLogsInput = {
    where?: EmailJobWhereInput
    data: XOR<EmailJobUpdateWithoutLogsInput, EmailJobUncheckedUpdateWithoutLogsInput>
  }

  export type EmailJobUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutEmailJobsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutEmailJobNestedInput
  }

  export type EmailJobUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutEmailJobNestedInput
  }

  export type CampaignCreateWithoutAnalyticsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutCampaignsInput
    team: TeamCreateNestedOneWithoutCampaignsInput
    mailingList: MailingListCreateNestedOneWithoutCampaignsInput
    sentEmails?: SentEmailCreateNestedManyWithoutCampaignInput
    smtpConfig?: SmtpConfigCreateNestedOneWithoutCampaignsInput
    emailJobs?: EmailJobCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutCampaignInput
    emailJobs?: EmailJobUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAnalyticsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAnalyticsInput, CampaignUncheckedCreateWithoutAnalyticsInput>
  }

  export type CampaignUpsertWithoutAnalyticsInput = {
    update: XOR<CampaignUpdateWithoutAnalyticsInput, CampaignUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<CampaignCreateWithoutAnalyticsInput, CampaignUncheckedCreateWithoutAnalyticsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAnalyticsInput, CampaignUncheckedUpdateWithoutAnalyticsInput>
  }

  export type CampaignUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    team?: TeamUpdateOneRequiredWithoutCampaignsNestedInput
    mailingList?: MailingListUpdateOneRequiredWithoutCampaignsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutCampaignNestedInput
    smtpConfig?: SmtpConfigUpdateOneWithoutCampaignsNestedInput
    emailJobs?: EmailJobUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutCampaignNestedInput
    emailJobs?: EmailJobUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EmailTemplateCreateWithoutCategoryInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team: TeamCreateNestedOneWithoutTemplatesInput
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
    sentEmails?: SentEmailCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutCategoryInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutCategoryInput, EmailTemplateUncheckedCreateWithoutCategoryInput>
  }

  export type EmailTemplateCreateManyCategoryInputEnvelope = {
    data: EmailTemplateCreateManyCategoryInput | EmailTemplateCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EmailTemplateWhereUniqueInput
    update: XOR<EmailTemplateUpdateWithoutCategoryInput, EmailTemplateUncheckedUpdateWithoutCategoryInput>
    create: XOR<EmailTemplateCreateWithoutCategoryInput, EmailTemplateUncheckedCreateWithoutCategoryInput>
  }

  export type EmailTemplateUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EmailTemplateWhereUniqueInput
    data: XOR<EmailTemplateUpdateWithoutCategoryInput, EmailTemplateUncheckedUpdateWithoutCategoryInput>
  }

  export type EmailTemplateUpdateManyWithWhereWithoutCategoryInput = {
    where: EmailTemplateScalarWhereInput
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CampaignCreateWithoutSmtpConfigInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutCampaignsInput
    team: TeamCreateNestedOneWithoutCampaignsInput
    mailingList: MailingListCreateNestedOneWithoutCampaignsInput
    sentEmails?: SentEmailCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsCreateNestedOneWithoutCampaignInput
    emailJobs?: EmailJobCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSmtpConfigInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutCampaignInput
    analytics?: CampaignAnalyticsUncheckedCreateNestedOneWithoutCampaignInput
    emailJobs?: EmailJobUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSmtpConfigInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSmtpConfigInput, CampaignUncheckedCreateWithoutSmtpConfigInput>
  }

  export type CampaignCreateManySmtpConfigInputEnvelope = {
    data: CampaignCreateManySmtpConfigInput | CampaignCreateManySmtpConfigInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutSmtpConfigsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSmtpConfigsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSmtpConfigsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSmtpConfigsInput, TeamUncheckedCreateWithoutSmtpConfigsInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutSmtpConfigInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutSmtpConfigInput, CampaignUncheckedUpdateWithoutSmtpConfigInput>
    create: XOR<CampaignCreateWithoutSmtpConfigInput, CampaignUncheckedCreateWithoutSmtpConfigInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutSmtpConfigInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutSmtpConfigInput, CampaignUncheckedUpdateWithoutSmtpConfigInput>
  }

  export type CampaignUpdateManyWithWhereWithoutSmtpConfigInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutSmtpConfigInput>
  }

  export type TeamUpsertWithoutSmtpConfigsInput = {
    update: XOR<TeamUpdateWithoutSmtpConfigsInput, TeamUncheckedUpdateWithoutSmtpConfigsInput>
    create: XOR<TeamCreateWithoutSmtpConfigsInput, TeamUncheckedCreateWithoutSmtpConfigsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSmtpConfigsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSmtpConfigsInput, TeamUncheckedUpdateWithoutSmtpConfigsInput>
  }

  export type TeamUpdateWithoutSmtpConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSmtpConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateWithoutAutomationsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutAutomationsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutAutomationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutAutomationsInput, TeamUncheckedCreateWithoutAutomationsInput>
  }

  export type AutomationNodeCreateWithoutAutomationInput = {
    id?: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeCreateNestedManyWithoutSourceInput
    edgesTo?: AutomationNodeEdgeCreateNestedManyWithoutTargetInput
  }

  export type AutomationNodeUncheckedCreateWithoutAutomationInput = {
    id?: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutSourceInput
    edgesTo?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AutomationNodeCreateOrConnectWithoutAutomationInput = {
    where: AutomationNodeWhereUniqueInput
    create: XOR<AutomationNodeCreateWithoutAutomationInput, AutomationNodeUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationNodeCreateManyAutomationInputEnvelope = {
    data: AutomationNodeCreateManyAutomationInput | AutomationNodeCreateManyAutomationInput[]
    skipDuplicates?: boolean
  }

  export type AutomationNodeEdgeCreateWithoutAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
    source: AutomationNodeCreateNestedOneWithoutEdgesFromInput
    target: AutomationNodeCreateNestedOneWithoutEdgesToInput
  }

  export type AutomationNodeEdgeUncheckedCreateWithoutAutomationInput = {
    id?: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeEdgeCreateOrConnectWithoutAutomationInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    create: XOR<AutomationNodeEdgeCreateWithoutAutomationInput, AutomationNodeEdgeUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationNodeEdgeCreateManyAutomationInputEnvelope = {
    data: AutomationNodeEdgeCreateManyAutomationInput | AutomationNodeEdgeCreateManyAutomationInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutAutomationsInput = {
    update: XOR<TeamUpdateWithoutAutomationsInput, TeamUncheckedUpdateWithoutAutomationsInput>
    create: XOR<TeamCreateWithoutAutomationsInput, TeamUncheckedCreateWithoutAutomationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutAutomationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutAutomationsInput, TeamUncheckedUpdateWithoutAutomationsInput>
  }

  export type TeamUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type AutomationNodeUpsertWithWhereUniqueWithoutAutomationInput = {
    where: AutomationNodeWhereUniqueInput
    update: XOR<AutomationNodeUpdateWithoutAutomationInput, AutomationNodeUncheckedUpdateWithoutAutomationInput>
    create: XOR<AutomationNodeCreateWithoutAutomationInput, AutomationNodeUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationNodeUpdateWithWhereUniqueWithoutAutomationInput = {
    where: AutomationNodeWhereUniqueInput
    data: XOR<AutomationNodeUpdateWithoutAutomationInput, AutomationNodeUncheckedUpdateWithoutAutomationInput>
  }

  export type AutomationNodeUpdateManyWithWhereWithoutAutomationInput = {
    where: AutomationNodeScalarWhereInput
    data: XOR<AutomationNodeUpdateManyMutationInput, AutomationNodeUncheckedUpdateManyWithoutAutomationInput>
  }

  export type AutomationNodeScalarWhereInput = {
    AND?: AutomationNodeScalarWhereInput | AutomationNodeScalarWhereInput[]
    OR?: AutomationNodeScalarWhereInput[]
    NOT?: AutomationNodeScalarWhereInput | AutomationNodeScalarWhereInput[]
    id?: StringFilter<"AutomationNode"> | string
    automationId?: StringFilter<"AutomationNode"> | string
    type?: EnumNodeTypeFilter<"AutomationNode"> | $Enums.NodeType
    createdAt?: DateTimeFilter<"AutomationNode"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationNode"> | Date | string
    data?: JsonNullableFilter<"AutomationNode">
  }

  export type AutomationNodeEdgeUpsertWithWhereUniqueWithoutAutomationInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    update: XOR<AutomationNodeEdgeUpdateWithoutAutomationInput, AutomationNodeEdgeUncheckedUpdateWithoutAutomationInput>
    create: XOR<AutomationNodeEdgeCreateWithoutAutomationInput, AutomationNodeEdgeUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationNodeEdgeUpdateWithWhereUniqueWithoutAutomationInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    data: XOR<AutomationNodeEdgeUpdateWithoutAutomationInput, AutomationNodeEdgeUncheckedUpdateWithoutAutomationInput>
  }

  export type AutomationNodeEdgeUpdateManyWithWhereWithoutAutomationInput = {
    where: AutomationNodeEdgeScalarWhereInput
    data: XOR<AutomationNodeEdgeUpdateManyMutationInput, AutomationNodeEdgeUncheckedUpdateManyWithoutAutomationInput>
  }

  export type AutomationNodeEdgeScalarWhereInput = {
    AND?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
    OR?: AutomationNodeEdgeScalarWhereInput[]
    NOT?: AutomationNodeEdgeScalarWhereInput | AutomationNodeEdgeScalarWhereInput[]
    id?: StringFilter<"AutomationNodeEdge"> | string
    automationId?: StringFilter<"AutomationNodeEdge"> | string
    sourceId?: StringFilter<"AutomationNodeEdge"> | string
    targetId?: StringFilter<"AutomationNodeEdge"> | string
    createdAt?: DateTimeFilter<"AutomationNodeEdge"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationNodeEdge"> | Date | string
    label?: StringNullableFilter<"AutomationNodeEdge"> | string | null
    animated?: BoolFilter<"AutomationNodeEdge"> | boolean
  }

  export type AutomationCreateWithoutNodesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    team: TeamCreateNestedOneWithoutAutomationsInput
    edges?: AutomationNodeEdgeCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutNodesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    teamId: string
    edges?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutNodesInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutNodesInput, AutomationUncheckedCreateWithoutNodesInput>
  }

  export type AutomationNodeEdgeCreateWithoutSourceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
    automation: AutomationCreateNestedOneWithoutEdgesInput
    target: AutomationNodeCreateNestedOneWithoutEdgesToInput
  }

  export type AutomationNodeEdgeUncheckedCreateWithoutSourceInput = {
    id?: string
    automationId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeEdgeCreateOrConnectWithoutSourceInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    create: XOR<AutomationNodeEdgeCreateWithoutSourceInput, AutomationNodeEdgeUncheckedCreateWithoutSourceInput>
  }

  export type AutomationNodeEdgeCreateManySourceInputEnvelope = {
    data: AutomationNodeEdgeCreateManySourceInput | AutomationNodeEdgeCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type AutomationNodeEdgeCreateWithoutTargetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
    automation: AutomationCreateNestedOneWithoutEdgesInput
    source: AutomationNodeCreateNestedOneWithoutEdgesFromInput
  }

  export type AutomationNodeEdgeUncheckedCreateWithoutTargetInput = {
    id?: string
    automationId: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeEdgeCreateOrConnectWithoutTargetInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    create: XOR<AutomationNodeEdgeCreateWithoutTargetInput, AutomationNodeEdgeUncheckedCreateWithoutTargetInput>
  }

  export type AutomationNodeEdgeCreateManyTargetInputEnvelope = {
    data: AutomationNodeEdgeCreateManyTargetInput | AutomationNodeEdgeCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type AutomationUpsertWithoutNodesInput = {
    update: XOR<AutomationUpdateWithoutNodesInput, AutomationUncheckedUpdateWithoutNodesInput>
    create: XOR<AutomationCreateWithoutNodesInput, AutomationUncheckedCreateWithoutNodesInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutNodesInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutNodesInput, AutomationUncheckedUpdateWithoutNodesInput>
  }

  export type AutomationUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutAutomationsNestedInput
    edges?: AutomationNodeEdgeUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamId?: StringFieldUpdateOperationsInput | string
    edges?: AutomationNodeEdgeUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationNodeEdgeUpsertWithWhereUniqueWithoutSourceInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    update: XOR<AutomationNodeEdgeUpdateWithoutSourceInput, AutomationNodeEdgeUncheckedUpdateWithoutSourceInput>
    create: XOR<AutomationNodeEdgeCreateWithoutSourceInput, AutomationNodeEdgeUncheckedCreateWithoutSourceInput>
  }

  export type AutomationNodeEdgeUpdateWithWhereUniqueWithoutSourceInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    data: XOR<AutomationNodeEdgeUpdateWithoutSourceInput, AutomationNodeEdgeUncheckedUpdateWithoutSourceInput>
  }

  export type AutomationNodeEdgeUpdateManyWithWhereWithoutSourceInput = {
    where: AutomationNodeEdgeScalarWhereInput
    data: XOR<AutomationNodeEdgeUpdateManyMutationInput, AutomationNodeEdgeUncheckedUpdateManyWithoutSourceInput>
  }

  export type AutomationNodeEdgeUpsertWithWhereUniqueWithoutTargetInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    update: XOR<AutomationNodeEdgeUpdateWithoutTargetInput, AutomationNodeEdgeUncheckedUpdateWithoutTargetInput>
    create: XOR<AutomationNodeEdgeCreateWithoutTargetInput, AutomationNodeEdgeUncheckedCreateWithoutTargetInput>
  }

  export type AutomationNodeEdgeUpdateWithWhereUniqueWithoutTargetInput = {
    where: AutomationNodeEdgeWhereUniqueInput
    data: XOR<AutomationNodeEdgeUpdateWithoutTargetInput, AutomationNodeEdgeUncheckedUpdateWithoutTargetInput>
  }

  export type AutomationNodeEdgeUpdateManyWithWhereWithoutTargetInput = {
    where: AutomationNodeEdgeScalarWhereInput
    data: XOR<AutomationNodeEdgeUpdateManyMutationInput, AutomationNodeEdgeUncheckedUpdateManyWithoutTargetInput>
  }

  export type AutomationCreateWithoutEdgesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    team: TeamCreateNestedOneWithoutAutomationsInput
    nodes?: AutomationNodeCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutEdgesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    teamId: string
    nodes?: AutomationNodeUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutEdgesInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutEdgesInput, AutomationUncheckedCreateWithoutEdgesInput>
  }

  export type AutomationNodeCreateWithoutEdgesFromInput = {
    id?: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    automation: AutomationCreateNestedOneWithoutNodesInput
    edgesTo?: AutomationNodeEdgeCreateNestedManyWithoutTargetInput
  }

  export type AutomationNodeUncheckedCreateWithoutEdgesFromInput = {
    id?: string
    automationId: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesTo?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutTargetInput
  }

  export type AutomationNodeCreateOrConnectWithoutEdgesFromInput = {
    where: AutomationNodeWhereUniqueInput
    create: XOR<AutomationNodeCreateWithoutEdgesFromInput, AutomationNodeUncheckedCreateWithoutEdgesFromInput>
  }

  export type AutomationNodeCreateWithoutEdgesToInput = {
    id?: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    automation: AutomationCreateNestedOneWithoutNodesInput
    edgesFrom?: AutomationNodeEdgeCreateNestedManyWithoutSourceInput
  }

  export type AutomationNodeUncheckedCreateWithoutEdgesToInput = {
    id?: string
    automationId: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeUncheckedCreateNestedManyWithoutSourceInput
  }

  export type AutomationNodeCreateOrConnectWithoutEdgesToInput = {
    where: AutomationNodeWhereUniqueInput
    create: XOR<AutomationNodeCreateWithoutEdgesToInput, AutomationNodeUncheckedCreateWithoutEdgesToInput>
  }

  export type AutomationUpsertWithoutEdgesInput = {
    update: XOR<AutomationUpdateWithoutEdgesInput, AutomationUncheckedUpdateWithoutEdgesInput>
    create: XOR<AutomationCreateWithoutEdgesInput, AutomationUncheckedCreateWithoutEdgesInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutEdgesInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutEdgesInput, AutomationUncheckedUpdateWithoutEdgesInput>
  }

  export type AutomationUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutAutomationsNestedInput
    nodes?: AutomationNodeUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamId?: StringFieldUpdateOperationsInput | string
    nodes?: AutomationNodeUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationNodeUpsertWithoutEdgesFromInput = {
    update: XOR<AutomationNodeUpdateWithoutEdgesFromInput, AutomationNodeUncheckedUpdateWithoutEdgesFromInput>
    create: XOR<AutomationNodeCreateWithoutEdgesFromInput, AutomationNodeUncheckedCreateWithoutEdgesFromInput>
    where?: AutomationNodeWhereInput
  }

  export type AutomationNodeUpdateToOneWithWhereWithoutEdgesFromInput = {
    where?: AutomationNodeWhereInput
    data: XOR<AutomationNodeUpdateWithoutEdgesFromInput, AutomationNodeUncheckedUpdateWithoutEdgesFromInput>
  }

  export type AutomationNodeUpdateWithoutEdgesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    automation?: AutomationUpdateOneRequiredWithoutNodesNestedInput
    edgesTo?: AutomationNodeEdgeUpdateManyWithoutTargetNestedInput
  }

  export type AutomationNodeUncheckedUpdateWithoutEdgesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesTo?: AutomationNodeEdgeUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AutomationNodeUpsertWithoutEdgesToInput = {
    update: XOR<AutomationNodeUpdateWithoutEdgesToInput, AutomationNodeUncheckedUpdateWithoutEdgesToInput>
    create: XOR<AutomationNodeCreateWithoutEdgesToInput, AutomationNodeUncheckedCreateWithoutEdgesToInput>
    where?: AutomationNodeWhereInput
  }

  export type AutomationNodeUpdateToOneWithWhereWithoutEdgesToInput = {
    where?: AutomationNodeWhereInput
    data: XOR<AutomationNodeUpdateWithoutEdgesToInput, AutomationNodeUncheckedUpdateWithoutEdgesToInput>
  }

  export type AutomationNodeUpdateWithoutEdgesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    automation?: AutomationUpdateOneRequiredWithoutNodesNestedInput
    edgesFrom?: AutomationNodeEdgeUpdateManyWithoutSourceNestedInput
  }

  export type AutomationNodeUncheckedUpdateWithoutEdgesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type TeamCreateWithoutCustomDomainsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    webhooks?: WebhookCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCustomDomainsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCustomDomainsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCustomDomainsInput, TeamUncheckedCreateWithoutCustomDomainsInput>
  }

  export type TeamUpsertWithoutCustomDomainsInput = {
    update: XOR<TeamUpdateWithoutCustomDomainsInput, TeamUncheckedUpdateWithoutCustomDomainsInput>
    create: XOR<TeamCreateWithoutCustomDomainsInput, TeamUncheckedCreateWithoutCustomDomainsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutCustomDomainsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutCustomDomainsInput, TeamUncheckedUpdateWithoutCustomDomainsInput>
  }

  export type TeamUpdateWithoutCustomDomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCustomDomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type WebhookEventCreateWithoutWebhookInput = {
    id?: string
    eventType: $Enums.WebhookEventType
    createdAt?: Date | string
  }

  export type WebhookEventUncheckedCreateWithoutWebhookInput = {
    id?: string
    eventType: $Enums.WebhookEventType
    createdAt?: Date | string
  }

  export type WebhookEventCreateOrConnectWithoutWebhookInput = {
    where: WebhookEventWhereUniqueInput
    create: XOR<WebhookEventCreateWithoutWebhookInput, WebhookEventUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookEventCreateManyWebhookInputEnvelope = {
    data: WebhookEventCreateManyWebhookInput | WebhookEventCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutWebhooksInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserCreateNestedManyWithoutTeamInput
    invites?: TeamInviteCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateCreateNestedManyWithoutTeamInput
    lists?: MailingListCreateNestedManyWithoutTeamInput
    automations?: AutomationCreateNestedManyWithoutTeamInput
    campaigns?: CampaignCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutWebhooksInput = {
    id?: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput
    templates?: EmailTemplateUncheckedCreateNestedManyWithoutTeamInput
    lists?: MailingListUncheckedCreateNestedManyWithoutTeamInput
    automations?: AutomationUncheckedCreateNestedManyWithoutTeamInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTeamInput
    smtpConfigs?: SmtpConfigUncheckedCreateNestedManyWithoutTeamInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTeamInput
    customDomains?: CustomDomainUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutWebhooksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutWebhooksInput, TeamUncheckedCreateWithoutWebhooksInput>
  }

  export type WebhookEventUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookEventWhereUniqueInput
    update: XOR<WebhookEventUpdateWithoutWebhookInput, WebhookEventUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookEventCreateWithoutWebhookInput, WebhookEventUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookEventUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookEventWhereUniqueInput
    data: XOR<WebhookEventUpdateWithoutWebhookInput, WebhookEventUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookEventUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookEventScalarWhereInput
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookEventScalarWhereInput = {
    AND?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
    OR?: WebhookEventScalarWhereInput[]
    NOT?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    eventType?: EnumWebhookEventTypeFilter<"WebhookEvent"> | $Enums.WebhookEventType
    webhookId?: StringFilter<"WebhookEvent"> | string
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
  }

  export type TeamUpsertWithoutWebhooksInput = {
    update: XOR<TeamUpdateWithoutWebhooksInput, TeamUncheckedUpdateWithoutWebhooksInput>
    create: XOR<TeamCreateWithoutWebhooksInput, TeamUncheckedCreateWithoutWebhooksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutWebhooksInput, TeamUncheckedUpdateWithoutWebhooksInput>
  }

  export type TeamUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUpdateManyWithoutTeamNestedInput
    lists?: MailingListUpdateManyWithoutTeamNestedInput
    automations?: AutomationUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput
    templates?: EmailTemplateUncheckedUpdateManyWithoutTeamNestedInput
    lists?: MailingListUncheckedUpdateManyWithoutTeamNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutTeamNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTeamNestedInput
    smtpConfigs?: SmtpConfigUncheckedUpdateManyWithoutTeamNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTeamNestedInput
    customDomains?: CustomDomainUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type WebhookCreateWithoutEventsInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
    team: TeamCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
  }

  export type WebhookCreateOrConnectWithoutEventsInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutEventsInput, WebhookUncheckedCreateWithoutEventsInput>
  }

  export type WebhookUpsertWithoutEventsInput = {
    update: XOR<WebhookUpdateWithoutEventsInput, WebhookUncheckedUpdateWithoutEventsInput>
    create: XOR<WebhookCreateWithoutEventsInput, WebhookUncheckedCreateWithoutEventsInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutEventsInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutEventsInput, WebhookUncheckedUpdateWithoutEventsInput>
  }

  export type WebhookUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    team?: TeamUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailCreateManyTemplateInput = {
    id?: string
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
  }

  export type CampaignUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutCampaignsNestedInput
    mailingList?: MailingListUpdateOneRequiredWithoutCampaignsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUpdateOneWithoutCampaignNestedInput
    smtpConfig?: SmtpConfigUpdateOneWithoutCampaignsNestedInput
    emailJobs?: EmailJobUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput
    emailJobs?: EmailJobUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaign?: CampaignUpdateOneWithoutSentEmailsNestedInput
    team?: TeamUpdateOneRequiredWithoutSentEmailsNestedInput
    emailJob?: EmailJobUpdateOneWithoutSentEmailsNestedInput
    subscriber?: SubscriberUpdateOneWithoutSentEmailsNestedInput
    tracking?: EmailTrackingUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    tracking?: EmailTrackingUncheckedUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamInviteCreateManyInviterInput = {
    id?: string
    teamId: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
  }

  export type TeamInviteUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type TeamInviteUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInviteUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyTeamInput = {
    id?: string
    name?: string | null
    email: string
    password: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.UserStatus
  }

  export type TeamInviteCreateManyTeamInput = {
    id?: string
    inviterId: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
  }

  export type EmailTemplateCreateManyTeamInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MailingListCreateManyTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationCreateManyTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type CampaignCreateManyTeamInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyTeamInput = {
    id?: string
    name: string
    key: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: ApiKeyCreatescopesInput | string[]
    rateLimit?: number
    isActive?: boolean
  }

  export type SmtpConfigCreateManyTeamInput = {
    id?: string
    provider?: string
    host: string
    port: string
    username: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailCreateManyTeamInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
  }

  export type CustomDomainCreateManyTeamInput = {
    id?: string
    domain: string
    sslStatus?: string
    sslCertificate?: string | null
    sslPrivateKey?: string | null
    sslExpiresAt?: Date | string | null
    verificationToken?: string
    dnsChallenge?: string | null
    dnsChallengeToken?: string | null
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateManyTeamInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStatus?: number | null
    lastAttempt?: Date | string | null
    retryCount?: number
  }

  export type UserUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    invitesSent?: TeamInviteUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    invitesSent?: TeamInviteUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
  }

  export type TeamInviteUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    inviter?: UserUpdateOneRequiredWithoutInvitesSentNestedInput
  }

  export type TeamInviteUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInviteUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTemplateUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTemplateNestedInput
    category?: EmailCategoryUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MailingListUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: SubscriberUpdateManyWithoutMailingListNestedInput
    campaigns?: CampaignUpdateManyWithoutMailingListNestedInput
  }

  export type MailingListUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: SubscriberUncheckedUpdateManyWithoutMailingListNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutMailingListNestedInput
  }

  export type MailingListUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nodes?: AutomationNodeUpdateManyWithoutAutomationNestedInput
    edges?: AutomationNodeEdgeUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nodes?: AutomationNodeUncheckedUpdateManyWithoutAutomationNestedInput
    edges?: AutomationNodeEdgeUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CampaignUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    mailingList?: MailingListUpdateOneRequiredWithoutCampaignsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUpdateOneWithoutCampaignNestedInput
    smtpConfig?: SmtpConfigUpdateOneWithoutCampaignsNestedInput
    emailJobs?: EmailJobUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput
    emailJobs?: EmailJobUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageStats?: ApiKeyUsageUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageStats?: ApiKeyUsageUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: ApiKeyUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SmtpConfigUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutSmtpConfigNestedInput
  }

  export type SmtpConfigUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutSmtpConfigNestedInput
  }

  export type SmtpConfigUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateUpdateOneWithoutSentEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutSentEmailsNestedInput
    emailJob?: EmailJobUpdateOneWithoutSentEmailsNestedInput
    subscriber?: SubscriberUpdateOneWithoutSentEmailsNestedInput
    tracking?: EmailTrackingUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    tracking?: EmailTrackingUncheckedUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomDomainUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    sslStatus?: StringFieldUpdateOperationsInput | string
    sslCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    sslPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    sslExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: StringFieldUpdateOperationsInput | string
    dnsChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    dnsChallengeToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomDomainUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    sslStatus?: StringFieldUpdateOperationsInput | string
    sslCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    sslPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    sslExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: StringFieldUpdateOperationsInput | string
    dnsChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    dnsChallengeToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomDomainUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    sslStatus?: StringFieldUpdateOperationsInput | string
    sslCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    sslPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    sslExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: StringFieldUpdateOperationsInput | string
    dnsChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    dnsChallengeToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    events?: WebhookEventUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    events?: WebhookEventUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatus?: NullableIntFieldUpdateOperationsInput | number | null
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type ApiKeyUsageCreateManyApiKeyInput = {
    id?: string
    endpoint: string
    method: string
    timestamp?: Date | string
    success?: boolean
    error?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiKeyUsageUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageUncheckedUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageUncheckedUpdateManyWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SentEmailCreateManyCampaignInput = {
    id?: string
    templateId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
    subscriberId?: string | null
  }

  export type EmailJobCreateManyCampaignInput = {
    id?: string
    status?: $Enums.JobStatus
    totalEmails: number
    processedEmails?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateUpdateOneWithoutSentEmailsNestedInput
    team?: TeamUpdateOneRequiredWithoutSentEmailsNestedInput
    emailJob?: EmailJobUpdateOneWithoutSentEmailsNestedInput
    subscriber?: SubscriberUpdateOneWithoutSentEmailsNestedInput
    tracking?: EmailTrackingUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    tracking?: EmailTrackingUncheckedUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailJobUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUpdateManyWithoutEmailJobNestedInput
    logs?: EmailJobLogUpdateManyWithoutEmailJobNestedInput
  }

  export type EmailJobUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutEmailJobNestedInput
    logs?: EmailJobLogUncheckedUpdateManyWithoutEmailJobNestedInput
  }

  export type EmailJobUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    totalEmails?: IntFieldUpdateOperationsInput | number
    processedEmails?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberCreateManyMailingListInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    address?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    status?: $Enums.SubscriberStatus
    unsubscribedAt?: Date | string | null
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyMailingListInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    smtpConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUpdateWithoutMailingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberUncheckedUpdateWithoutMailingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberUncheckedUpdateManyWithoutMailingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SubscriberUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriberStatusFieldUpdateOperationsInput | $Enums.SubscriberStatus
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutMailingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    team?: TeamUpdateOneRequiredWithoutCampaignsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUpdateOneWithoutCampaignNestedInput
    smtpConfig?: SmtpConfigUpdateOneWithoutCampaignsNestedInput
    emailJobs?: EmailJobUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMailingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput
    emailJobs?: EmailJobUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutMailingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    smtpConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailCreateManySubscriberInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: string | null
  }

  export type SentEmailUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateUpdateOneWithoutSentEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutSentEmailsNestedInput
    team?: TeamUpdateOneRequiredWithoutSentEmailsNestedInput
    emailJob?: EmailJobUpdateOneWithoutSentEmailsNestedInput
    tracking?: EmailTrackingUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    tracking?: EmailTrackingUncheckedUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateManyWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailTrackingCreateManySentEmailInput = {
    id?: string
    type: $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailTrackingUpdateWithoutSentEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackingTypeFieldUpdateOperationsInput | $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingUncheckedUpdateWithoutSentEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackingTypeFieldUpdateOperationsInput | $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingUncheckedUpdateManyWithoutSentEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackingTypeFieldUpdateOperationsInput | $Enums.TrackingType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailCreateManyEmailJobInput = {
    id?: string
    templateId?: string | null
    campaignId?: string | null
    recipient: string
    subject: string
    content?: string | null
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    teamId: string
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriberId?: string | null
  }

  export type EmailJobLogCreateManyEmailJobInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SentEmailUpdateWithoutEmailJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    template?: EmailTemplateUpdateOneWithoutSentEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutSentEmailsNestedInput
    team?: TeamUpdateOneRequiredWithoutSentEmailsNestedInput
    subscriber?: SubscriberUpdateOneWithoutSentEmailsNestedInput
    tracking?: EmailTrackingUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateWithoutEmailJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    tracking?: EmailTrackingUncheckedUpdateManyWithoutSentEmailNestedInput
  }

  export type SentEmailUncheckedUpdateManyWithoutEmailJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailJobLogUpdateWithoutEmailJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJobLogUncheckedUpdateWithoutEmailJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailJobLogUncheckedUpdateManyWithoutEmailJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateManyCategoryInput = {
    id?: string
    name: string
    subject: string
    content?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    html?: string | null
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailTemplateUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    team?: TeamUpdateOneRequiredWithoutTemplatesNestedInput
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
    sentEmails?: SentEmailUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    html?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignCreateManySmtpConfigInput = {
    id?: string
    name: string
    description?: string | null
    templateId: string
    teamId: string
    status?: $Enums.CampaignStatus
    scheduledFor?: Date | string | null
    schedule?: $Enums.CampaignSchedule | null
    listId: string
    recurringSchedule?: $Enums.CampaignRecurringSchedule | null
    cronExpression?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutSmtpConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    team?: TeamUpdateOneRequiredWithoutCampaignsNestedInput
    mailingList?: MailingListUpdateOneRequiredWithoutCampaignsNestedInput
    sentEmails?: SentEmailUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUpdateOneWithoutCampaignNestedInput
    emailJobs?: EmailJobUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSmtpConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentEmails?: SentEmailUncheckedUpdateManyWithoutCampaignNestedInput
    analytics?: CampaignAnalyticsUncheckedUpdateOneWithoutCampaignNestedInput
    emailJobs?: EmailJobUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutSmtpConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedule?: NullableEnumCampaignScheduleFieldUpdateOperationsInput | $Enums.CampaignSchedule | null
    listId?: StringFieldUpdateOperationsInput | string
    recurringSchedule?: NullableEnumCampaignRecurringScheduleFieldUpdateOperationsInput | $Enums.CampaignRecurringSchedule | null
    cronExpression?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationNodeCreateManyAutomationInput = {
    id?: string
    type: $Enums.NodeType
    createdAt?: Date | string
    updatedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AutomationNodeEdgeCreateManyAutomationInput = {
    id?: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeUpdateManyWithoutSourceNestedInput
    edgesTo?: AutomationNodeEdgeUpdateManyWithoutTargetNestedInput
  }

  export type AutomationNodeUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    edgesFrom?: AutomationNodeEdgeUncheckedUpdateManyWithoutSourceNestedInput
    edgesTo?: AutomationNodeEdgeUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type AutomationNodeUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AutomationNodeEdgeUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    source?: AutomationNodeUpdateOneRequiredWithoutEdgesFromNestedInput
    target?: AutomationNodeUpdateOneRequiredWithoutEdgesToNestedInput
  }

  export type AutomationNodeEdgeUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationNodeEdgeUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationNodeEdgeCreateManySourceInput = {
    id?: string
    automationId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeEdgeCreateManyTargetInput = {
    id?: string
    automationId: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    label?: string | null
    animated?: boolean
  }

  export type AutomationNodeEdgeUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    automation?: AutomationUpdateOneRequiredWithoutEdgesNestedInput
    target?: AutomationNodeUpdateOneRequiredWithoutEdgesToNestedInput
  }

  export type AutomationNodeEdgeUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationNodeEdgeUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationNodeEdgeUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
    automation?: AutomationUpdateOneRequiredWithoutEdgesNestedInput
    source?: AutomationNodeUpdateOneRequiredWithoutEdgesFromNestedInput
  }

  export type AutomationNodeEdgeUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationNodeEdgeUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    animated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WebhookEventCreateManyWebhookInput = {
    id?: string
    eventType: $Enums.WebhookEventType
    createdAt?: Date | string
  }

  export type WebhookEventUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWebhookEventTypeFieldUpdateOperationsInput | $Enums.WebhookEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}